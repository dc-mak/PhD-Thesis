So far I have demonstrated that it is possible to design a type system for most
of real-world C. In particular, such a type system supports resource management
in the presence of complex control flow, variable scoping and aliasing, and has
a conceptually simple extension to handle loose evaluation order.

One of the features I glossed over was the subtle and complex rules regarding
pointer manipulations, which cannot be ignored or simplified away in practice,
especially given \kl{CN}'s headline goal (\cref{sec:cn-intro}) to work
correctly above pre-existing C programs and observed behaviour.

The subtlety around observed behaviour for pointer manipulations stems from the
competing forces which shaped C.\sidenote{Inherited portability requirements,
proximity to hardware, and the desire for more aggressive optimisations.} As I
explained in \cref{sec:c-lang}, a completely concrete view of pointers would
invalidate fundamental optimisations we would like to perform on our code, but
a completely abstract view where pointers cannot alias each other is simply
incompatible with C's ability to take addresses of variables and compute with
pointers (increment, calculate offsets, cast them to and from integers).

Whilst many aspects of C are specified using an elaboration, the representation
of pointers, and the choice of rules for manipulating them, are factored out
into a \emph{memory interface}. This interface is visible in
\cref{fig:effectful-core-grammar}: the memory operations $\mathit{memop}$ and
the memory $\mathit{actions}$; a \intro{memory object model}\sidenote{Named so
to distinguish it from a memory model in a concurrency setting.} is an
implementation of that interface.

Remember that C has a lot of different stakeholders, and so a memory model
which is acceptable to the standards committee needs to walk a fine line
between being concrete enough to enable as many low-level idioms as possible,
whilst being abstract enough to permit as many optimisations as possible. The
key concept which enables this is the idea of pointer \intro{provenance},
tracking where a pointer came from. With this, because C allows casting to and
from integers, the question naturally arises about whether this provenance
should be tracked via integers or not. Unfortunately, that is not the only
choice point involved in coming up with an acceptable memory object model;
\sidetextcite{memarian2022cerberus} documents and explains the trade-offs
between this and other choices.

Any set of choices must nagivate the tension between allowing
low-level idioms relied upon by existing code, allowing opportunities for
optimisations exhibited by existing compilers, and limiting the scope of both.
The cost of doing so (in a consistent manner\sidenote{None of the memory models
discussed are consistent with all observed behaviour, and it is not clear that
there is a consistent one which would be.}) is that the so far preferred (but
not yet officially adopted) memory object model,
\kl{PNVI-ae-udi},\sidenote{Provenance not tracked via integers, for addresses
which are exposed and provenances user-disambiguated. I will explain this imminently.} is a
complex minefield of \kl{UB} no human should be expected to navigate
unassisted.

\kl{PVNI-ae-udi} is complex enough that even implementing it in a C
verification tool is undesirable, especially because in that context, it is
reasonable to place a small extra burden of annotation on the user if it
simplifies verifying the code. This is the motivation behind the development of
\kl{VIP}~\sidecite{lepigre2022vip}, a memory model which is sound with respect
to PNVI-ae-udi,\sidenote{Quoting from the paper, ``every PNVI-ae-udi step can
be simulated by a VIP step, and that every step that raises
\kl[UB]{undefined behaviour} in PNVI-ae-udi also raises \kl[UB]{undefined
behaviour} in VIP.''} but simpler (it is fine to reject more programs, i.e.\
have more \kl{UB}).

\kl{VIP} as a memory model is \emph{simpler}, but it is not trivial. It is
defined operationally as a step relation between concrete (i.e.\ not symbolic)
heavily structured heaps, and the steps have complex premises.

In this part, I will detail the challenges and choices I faced in designing,
formalising and implementing \kl{CN-VIP}, the memory model of \kl{CN} as a scheme
within the formalised and implemented type systems.
\begin{itemize}
    \item \textbf{Expressiveness vs simplicity.} \kl{VIP} makes a particular
        set of choices about its representation of pointers and integers, and relatedly
        about the idioms it supports. I will explain it, and the other
        design around it, both simpler and more expressive. In particular,
        I will explain important and subtle complexities around round-trip casts,
        \cinline{memcpy} and \cinline{memcmp}, which are handled in
        \kl{VIP}/\kl{PNVI-*} test-suite, but not discussed.
    \item \textbf{Integration into \kl{Kernel CN}.} As I mentioned in
        \cref{sec:res-terms}, the novel structure for heaps abstracts away
        some aspects of its representation. I will explain how I adapted the
        static and dynamic semantics to use \kl{VIP}, and proved the new system
        sound with less repeated effort than typical.
    \item \textbf{Implementation in \kl{CN}.} I will explain how I incrementally
        developed, gated and deployed a complex change to memory model of \kl{CN}.
        By the time I had designed and formalised \kl{CN-VIP}, \kl{CN} had
        users, a tutorial, a test-suite and a continuous integration pipeline,
        so I had to be careful in adding support for \kl{VIP}, avoid difficult
        code merges and test updates.
    \item \textbf{Impact on annotations and performance.} Finally, I will explain
        how switching over to \kl{CN-VIP} (without round-trip casts) impacted
        the annotations and performance on existing \kl{CN} tests and tutorial
        examples.
\end{itemize}

\chapter{Memory object models, explained}\label{chap:mem-model-explained}

\margintoc%

From the perspective of \kl{Core} and \kl{ResCore}, the representation of
pointers, integers and memory itself are left abstract, and memory operations
and memory actions are defined by an interface (\cref{fig:mem-model-intf}).

\begin{figure}[tbhp]
    \small%
    \raggedright%
    \cngrammarcompressed{\textwidth}{%
        \cnkillXXkind{}\cnafterlastrule{}
    }
    \begingroup%
    %\renewcommand{\cnprodline}[6]{\cnprodlinecomment{#1}{#2}{#3}{}{#5}{#6}}
    \renewcommand{\cnprodline}{\cnprodlinecomment}
    \grammartabularSTY{%
        \cnaction{}\cninterrule{}
        \cnmemop{}\cnafterlastrule{}
    }
    \endgroup%
    \caption{\kl{ResCore} memory interface, a simplified subset of the \kl{Core}
        memory interface. I omit constructs for handling variable-length
        arguments and loose expression evaluation order.}\label{fig:mem-model-intf}
\end{figure}

The key concept which begins this brief overview of memory object models is
that of provenance. To optimise our code, compilers would like to assume that a
programmer may only create pointers in a ``reasonable'' ways, and that certain
basic assumptions about those pointers are always true: (a) function
arguments may not alias local variables and (b) pointers created in a function
may not alias the local variables of any caller (c) pointers created by
guessing concrete addresses are always invalid.

Let us revisit the example from \cref{fig:ptr-from-int-ub}, reproduced in
\cref{fig:mem-model-ptr-from-int} for convenience.  It guesses that
\cinline{ADDRESS_PFI_1I} is the address of a variable local to function
\cinline{f}, and passes that guess in as an argument \cinline{f(j)}. Inside the  % chktex 36
function, it declares a local variable \cinline{i} and then creates a pointer
\cninline{p} from the argument. If this new pointer is equal to the address of
the local variable, it writes to that location (\cinline{if (p == &i) *p=7;}).
The value of the local variable is then printed.

Assuming the address is guessed correctly, this program raises two questions:
Does this program have undefined behaviour, and if so, where and why?  What will
it print?

Indeed, it does have undefined behaviour, because the pointer \cinline{p} is not
constructed in a ``reasonable'' way and it can print 5, because the compiler may
assume that \cninline{p} cannot alias the local variable \cinline{i}, and thus
perform constant propagation over the assignment.

To optimise pointer code, compilers assume that pointers in C are \emph{not}
completely concrete, and are only constructed in ``reasonable'' ways. However,
to support low-level idioms of \emph{computing} with pointers (incrementing,
offsetting, casting to and from integers), compilers also assume that pointers
are \emph{not} completely abstract.  Compilers must also be conservative in such
assumptions. \emph{Despite a lack of dataflow between} \cinline{k} and
\cinline{j}, uncommenting line 6 would make the program defined and print 7.

\begin{marginfigure}
    \raggedright%
    \cfile{code/pointer_from_integer_1i.c}
    \caption{A modified version of examples
        pointer\_from\_integer\_\{1i,1ie\}.c
        from~\textcite{memarian2019exploring}.}\label{fig:mem-model-ptr-from-int}
\end{marginfigure}%

\section{PNVI-ae-udi}

The rules justifying the ``reasonable ways'' in which a pointer may be
constructed are set out in the \kl{PNVI-ae-udi} memory model, upon which VIP is
defined. Though the name is clunky and not euphonious, it is descriptive as each
part defines a particular choice to focus on.

\subsection{Provenance not tracked via integers}

For the purposes of defining the dynamic semantics of the memory object model,
each pointer can be thought of as either $\mathsf{NULL}$ or a \emph{pair} of an
address $a$ and an provenance $\pi$. The address is simply what programmers
might be familiar with as `the pointer', which, unlike the provenance, may be
inspected or manipulated directly from the C program at runtime. From the
perspective of separation logic verification, the provenance can be thought of
as the ghost part of a pointer, but it does play an integral part of the model
of memory I will outline next.

Provenances are either $@\mathsf{empty}$, or allocation IDs $@i$ for integer
$i$. Allocation IDs are allocated fresh
globally\sidenote{PNVI-ae-udi does not support concurrency.} for every new
allocation, and thus guaranteed to be unique. An \intro{allocation history}
$\mathit{A}$ is a partial map indexed by allocation IDs, which tracks their
base address, size, and liveness. The pointer
resulting from successfully creating a fresh allocation is a pair of base
address and the allocation ID\@. When an allocation is destroyed, the entry is
not removed, but merely updated to record the allocation as dead. The
allocation history includes other information too, which I will ignore because
it is not relevant to the key concepts.

The \kl{allocation history} merely tracks information about the allocation as a
whole; to track values of what resides in those allocations, \kl{PNVI-ae-udi}
also uses a memory $M$ as part of the abstract state. This is not just a map
from addresses to bytes, but pairs of a (potentially empty) provenance and a
concrete 8-bit byte or $\mathsf{unspec}$ value for uninitialised or padding
bytes.\sidenote{There is an additional component, an optional \intro{pointer
    index} (an integer $j$ or $\mathsf{none}$) which stores which part of a
    pointer a byte came from. This is only relevant if either (a) pointers are
    not uniform, i.e.\ different pointers types can have different sizes or (b)
    provenance is tracked via integers (PVI) and bytes of those pointers have
    been overwritten.}\label{sn:ignore-ptr-index}

Reading from and writing to memory is done via the \coreinline{load} and
\coreinline{store} actions, at a specific C type, and these actions handle
structured \kl{Core} values, not sequences of bytes. Marshalling between the
two is handled via $\mathrm{repr}$ and $\mathrm{abst}$ functions. So for
example, a pointer $(@i, a)$ as a value is going to be stored as a sequence of
bytes in memory based on its address $a$, each byte with its provenance
$@i$.\sidenote{There is also an optional \kl{pointer index} for each byte's
position in the pointer, see note~\ref{sn:ignore-ptr-index}.}

One of the idioms existing code relies upon frequently is casting a pointer to
an integer and back again, and this \intro{round-trip} property is in fact
guaranteed by the ISO standard.\sidenote{ยง6.3.2.3\#5: An integer may be
    converted to any pointer type. Except as previously specified, the result
is implementation-defined, might not be correctly aligned, might not point to
an entity of the referenced type, and might be a trap representation.}. A
straightforward way to model the round-trip property is to ensure casts from
pointers to integers do not lose any information, by augmenting the model of
integer values to also carry (as ghost information) provenance. This is called
\intro{PVI} for \emph{provenance-via-integers}. However, the updates to the
integer operations to preserve their provenances would break the algebraic
properties of integers relied upon for optimisations by compilers.

Hence the reason for the first crucial design choice in PNVI-ae-udi: the
representation of integer values. As the name suggests, in contrast to PVI,
provenance is not tracked via integers. Casts of integers to pointers therefore
must pick some provenance: a first approximation is to say the result gets the
provenance of an allocation which is live at the time of the cast, whenever the
address is within its footprint.

\subsection{Ae: Considering only address-exposed allocations for round-trips}

Whilst the result of an integer-to-pointer cast getting the provenance of any
live allocation it happens to be contained in is a reasonable choice,
discussions with the standards committee, particularly the memory object model
study group, worried that this would forbid too many non-aliasing assumptions
(required for many optimisations to be applied validly).

A refinement of this approach is to limit the set of considered allocations to
not just the ones which are live, but also the ones which have their addresses
\intro{exposed} (-ae). The \kl{allocation history} would thus also track if an
allocation has been exposed or not, and the semantics of an integer-to-pointer
cast would then only examine those (\cref{fig:pnvi-ival-to-pval}).

\begin{figure}
\begin{mathpar}
  \inferrule[{[PNVI-ae-udi: $\textbf{ptrFromInt}\langle\tau\rangle(x) = (@i, x)$]}]{%
      \exists{} \, i.\ A (i) = (n, a, \mathsf{alive}, \mathsf{\color{blue}{exposed}}) \wedge{} x \in{} [a \ldots a + n - 1]
  }{%
    (A, S, M) \rightarrow (A, S, M)}
  \\
  \inferrule[{[PNVI-ae-udi: $\textbf{ptrFromInt}\langle\tau\rangle(x) = (@\mathsf{empty}, x)$]}]{%
    \neg (\exists \, i.\ A(i) = (n, a, \mathsf{alive}, \mathsf{\color{blue}{exposed}}) \wedge x \in [a \ldots a + n - 1]) \\\\
    x \neq 0 \\ x \textrm{ is not the address of a function}%
  }{%
    (A, S, M) \rightarrow (A, S, M)}
\end{mathpar}\caption{Simplified PNVI-* rules for casting an integer to a
    pointer. Based
    on~\textcite{memarian2022cerberus}.}\label{fig:pnvi-ival-to-pval}
\end{figure}

\begin{definition}[Exposed allocation]
An allocation is \emph{exposed} iff a pointer to anywhere within that
allocation
\begin{itemize}
    \item Is cast to an integer.
    \item Has its representation byte read (via a non-pointer lvalue).
    \item Is output via the format specifier \cinline|%p|.
\end{itemize}
\end{definition}

The `within that allocation' is key because one-past pointers (frequently used
to compare against the exclusive end of an allocation) which do not happen to
be that start of an adjacent object would then be assigned an $\mathsf{@empty}$
provenance. In turn, this would break the round-trip property for one-past
pointers.

\subsection{Udi: disambiguating one-past pointers based on subsequent use}

Restoring round-trip casts for one-past pointers requires an additional
complication to the memory object model, \intro{symbolic} provenances. The
symbolic provenances are mapped to a set of either one or two allocation IDs
via an additional finite map $\mathit{S}$. Thus in the case where an integer
is cast to a one-past pointer on the boundary between two live allocations, its
provenance is assigned to be symbolic, containing both allocations' IDs
(\cref{fig:pnvi-ival-to-pval-symbolic}).

\begin{figure}
\[
  \inferrule[{[PNVI-ae-udi: $\textbf{ptrFromInt}\langle\tau\rangle(x) = ({\color{violet}\iota}, x)$]}]{%
    \exists \, i_1.\ A(i_1) = (n_1, a_1, \mathsf{alive}, \mathsf{\color{blue}{exposed}}) \wedge x \in [a_1 \ldots a_1 + n_1] \\\\
    \exists \, i_2.\ A(i_2) = (n_2, a_2, \mathsf{alive}, \mathsf{\color{blue}{exposed}}) \wedge x \in [a_2 \ldots a_2 + n_2] \\\\
    {\color{violet}i_1 \neq i_2} \\ {\color{violet}\iota \notin \mathrm{dom}(S)}
  }{%
    (A, S, M) \rightarrow (A, S{\color{violet}[\iota \mapsto \{ i_1 , i_2 \}]}, M)}
\]\caption{Simplified PNVI-ae-udi rule for casting an integer to a
    pointer when the value is the address on the boundary between two live
    allocations. Based
    on~\textcite{memarian2022cerberus}.}\label{fig:pnvi-ival-to-pval-symbolic}
\end{figure}

Whilst useful for capturing many idioms and optimisations, the problem with these
symbolic provenances is that they complicate every other rule which requires
knowing the provenance of a pointer, usually to do some liveness and bounds checks.
Furthermore, these provenances can stay symbolic indefinitely, but if disambiguated
by what the user wrote (udi), must remain consistent from then onwards. The
most egregious example of this is the rule for subtracting pointers: there
are \emph{four} cases, \emph{three} of which stem from the existence of symbolic
provenances.
\begin{enumerate}
    \item \textbf{Neither pointer has symbolic provenance.} Both must be within
        bounds of the live allocation signified by their (equal) allocation
        IDs.
    \item \textbf{One pointer has symbolic provenance.} Both pointers must be
        within bounds of the live allocation signified by the concrete
        provenance, which must must be a member of symbolic one; the latter in
        turn is marked as disambiguated.
    \item \textbf{Both pointers have equal symbolic provenances.} Both must
        be within the bounds of either live allocations signified by the
        symbolic provenances, both of which remain ambiguous.
    \item \textbf{Both pointers have symbolic provenances with one in common.}
        Both must be within the bounds of the common live allocation, and
        both their symbolic provenances are marked as disambiguated.
\end{enumerate}

\section{VIP:\ Verified Integer Pointer Casts}

\kl{VIP}, by \sidetextcite{lepigre2022vip}, is a memory object model designed
to be a sound abstraction of PNVI-ae-udi. In particular, it relies on (the
acceptable trade-off of) requiring a small additional annotation burden to
simplify verification. Every \kl{UB}-free VIP program corresponds to a valid
PNVI-ae-udi program, and every \kl{UB} in \kl{PNVI-ae-udi} is also \kl{UB} in
\kl{VIP} (though \kl{VIP} itself may have more \kl{UB} than \kl{PNVI-ae-udi},
achieving its simplicity by increasing its restrictiveness).

\kl{VIP} achieves this by adding a single simplifying restriction on the
round-trip property: only integer values which were cast from pointers, with no
intervening operations, can be round-trip cast back to pointers. Any
intervening operation on that integer (including adding 0) will result in an
$\mathsf{@empty}$ provenance when cast to a pointer.

This restriction is sufficient to remove both \kl{exposure tracking} and
consequently \kl{symbolic provenances} and from the memory model of
\kl{PNVI-ae-udi}. This is because fundamentally VIP tracks exposure of specific
\emph{pointer values} rather than of whole allocations. Disallowing intervening
operations (even if the integer value remains within the bounds of the same
allocation) removes the need to do a search and bounds check of all live
allocation when casting back (I will discuss how \kl{VIP} recovers allocation
IDs in such cases soon). This also means that a boundary pointer is
disambiguated as soon as it is cast back, based on what it was cast from.

This restriction, particularly the `no intervening operation', forbids too
many desirable low-level idioms, such as pointer tagging.\sidenote{Programmers
store information in the lower or upper bits of pointers by exploiting platform
pointer alignment and addressable memory constraints respectively.} To
support these idioms, \kl{VIP} provides a
\cinline[breaklines]{void *copy_alloc_id(uintptr_t, void*)} % chktex 36
primitive. This lets a programmer cast any integer to a pointer (with the
appropriate checks). It is given both a direct semantics above the
VIP abstract state, and a translation into \kl{PNVI-ae-udi}.

The way that both of these are achieved is a very limited form of tracking
provenances via integers. Integer values in VIP model are represented by a
datatype with two constructors: $\mathit{Loc}\,(@i, a) \mid \mathit{Int}\,(z \in
\mathbb{Z})$. Casts from pointers $(@i, a)$ to integers just embed the pointer
into the $\mathit{Loc}$ constructor, and casts back to pointers just take the
value out (\cref{fig:vip-ival-to-pval}). If the integer value has any
intervening operations, only the integer parts (the address $a$ in
$\mathit{Loc}$, the payload $z$ in $\mathit{Int}$) are projected and used, any
provenance is forgotten (\cref{fig:vip-arith-binop}). If the integer has no
provenance, then \cinline{copy_alloc_id} can be used to annotate it with one
(\cref{fig:vip-copy-alloc-id}).

\begin{figure}[tp]
\[
  \inferrule[{[VIP: $\textbf{intFromPtr}\langle\tau\rangle((@i, x)) = \mathit{Loc}\,(@i, x)$]}]{%
    A(i) = (n, a, \mathsf{alive}, \mathsf{\color{blue}{exposed}}) \\ x \in \mathsf{range}(\tau)%
  }{%
    (A, M) \rightarrow (A, M)}
\]\caption{The \kl{VIP} rules to cast an integer into a pointer which
    preserves the round-trip property.}\label{fig:vip-ival-to-pval}
\end{figure}

\begin{marginfigure}
\[
  \inferrule[{[VIP: $\textbf{arith\_bin\_op} (\oplus, x_1, x_2) = x$]}]{%
    x = \mathit{Int}\,(\mathrm{to\_int}(x_1), \mathrm{to\_int}(x_2))
  }{%
    (A, M) \rightarrow (A, M)}
\]\caption{\kl{VIP} arithmetic operations on
    integers.}\label{fig:vip-arith-binop}
\end{marginfigure}

\begin{figure}[tp]
\[
  \inferrule[{[VIP: $\textbf{copy\_alloc\_id} (x, (@i, \_)) = (@i, \mathrm{to\_int} (x))$]}]{%
    A(i) = (n, a, \mathsf{alive}) \\ \mathrm{to\_int}(x) \in [a \ldots a + n]
  }{%
    (A, M) \rightarrow (A, M)}
\]\caption{\kl{VIP} \cinline{copy_alloc_id} primitive to create a
    pointer with a specific provenance.}\label{fig:vip-copy-alloc-id}
\end{figure}

The VIP \cinline{copy_alloc_id} primitive needs to be expressible in
PNVI-ae-udi for it to be a sound abstraction, the way this is done is by
essentially implementing it as a C function
(\cref{fig:vip-copy-alloc-id-impl}). The implementation triggers two events in
\kl{PNVI-ae-udi}, the composition of which have the same effect as
\cinline{copy_alloc_id}: it ensures the allocation is \kl{exposed} by casting
it to an integer type, and then casts the integer to the pointer type. There
are some subtleties relating to the fact that the resulting provenance is
always concrete in \kl{VIP} but may be symbolic in \kl{PNVI-ae-udi}, but this
is not an issue because in well-defined programs, they differ only in
\emph{when} the disambiguation takes place (eagerly for \kl{VIP} and lazily for
\kl{PNVI-ae-udi}) rather than which way it disambiguates.

\begin{marginfigure}
    \cfile[breaklines,fontsize=\footnotesize]{code/copy_alloc_id.c}
    \caption{Implementation of \kl{VIP} \cinline{copy_alloc_id} primitive in C, to
        work above existing compilers, modelled via
        \kl{PNVI-ae-udi}.}\label{fig:vip-copy-alloc-id-impl}
\end{marginfigure}


\section{Design space}

Given this background, I will now consider some of the trade-offs involved
expressing different features of \kl{PNVI-ae-udi} and \kl{VIP} in \kl{CN}.

\subsection{Symbolic provenances}

Symbolic provenances initially seem like they should be easy to implement,
especially on top an SMT solver we use to do symbolic execution anyway. Whilst
the rules might be complicated, the potential advantage of not needing further
memory object model related annotations may be significant enough to be worth
it.

However, the symbolic nature of SMT problems turns out to not be helpful or
sufficient by itself to model symbolic provenances. The biggest reason why is
because of \intro{demonic allocation address non-determinism}. This is
orthogonal to \kl{PNVI-ae-udi} and \kl{VIP}, which are defined with respect to
a trace on a specific choice of addresses. It means that a program is deemed to
have \kl{UB} if there exists at least one choice of addresses for allocations
for which the memory object would signal \kl{UB}. In practise, this means that
the C program should not rely on objects being located at pre-determined
addresses or laid out with particular adjacencies, since both of those can be
changed with a different choice of addresses for allocations.

In a symbolic setting, this means an integer cast into an ambiguous one-past
pointer could belong to \emph{any} live allocation, not just one of two as in
the concrete address case.

Another serious problem is that the disambiguation of a provenance is a
\emph{relevant} fact: forgetting this would enable disambiguating the pointer
in inconsistent ways. This means that the disambiguation would need to be
tracked in the (linear) resource context, not the (intuitionistic) constraint
context.

So the choice is this: either use annotations to thread pointer disambiguation in
pre- and postconditions, or change the code to pass in a pointer with the
correct provenance to use with \cinline{copy_alloc_id}, forcing eager
disambiguation and sidestepping the associated implementation complexity. I
chose the latter.

\subsection{Exposure tracking}

Exposure tracking is another feature that \kl{PNVI-ae-udi} has but \kl{VIP}
does not. Remember that exposure tracking was devised to support round-trip
casts, but restrict the number of aliases which could be considered for the
results of those casts.

Exposure tracking has the distinct advantage over \kl{VIP} that round-trip
casts can happen (a) in the presence of intervening operations on the integer
value and (b) more importantly, \emph{without} a pointer to the specific
allocation we care about being available at runtime.

That being said, it is difficult to think of any idioms which require both of
these constraints to be true. One example is XOR linked-lists, where each node
stores the bitwise exclusive-or of the address of its previous and next
pointers, allowing a list to be traversed in forwards and reverse direction,
whilst saving the space for an additional pointer per node, and ``opinions
differ as to whether that idiom matters for modern
code''~\sidecite{gustedt2021provenance}.

Unlike provenance disambiguation, exposure is an intuitionistic fact:
forgetting an exposure would lead to fewer valid programs, but not
unsoundness. But still, this means that to be useful the trade-off here is
similar: use annotations to thread allocation exposure in pre- and
postconditions, or (if possible) change the code to pass in a pointer with the
correct provenance to use with \cinline{copy_alloc_id}. \kl{VIP} rules
already require tracking allocation liveness linearly, and so in principle,
adding exposure to that is not a very big change.

That being said, it is not clear to me how much this exposure tracking reflects
the analysis inside compilers, especially across functions. Address exposure
seems to be a syntactic over-approximation to pointer capture and escape
analyses.\sidenote{\url{https://jonasdevlieghere.com/post/escape-analysis-capture-tracking-in-llvm/}}
It seems unlikely to me that if a call to a function exposed an
allocation, but did so without leaking any information about the exposed
address to the caller, that analyses in the caller would add that allocation to
the list of potential aliases resulting from an integer-to-pointer cast.

So whilst tracking allocation address exposure would be a reasonable choice,
especially given an important implementation advantage (which I will discuss
next), and would likely be sound with respect to \kl{PNVI-ae-udi}, I ultimately
decided that (a) it is not clear it is worth the additional complexity and (b)
it can be added later straightforwardly if the need arose.

\subsection{Provenance in integers and bytes}\label{subsec:prov-int-bytes}

It is a little ironic that after eschewing provenance via integers (\kl{PVI}),
that \kl{VIP} reinstates them albeit in a very limited form (i.e.\ not preserved
via integer operations to retain a simple theory of integers for optimisation).

From the view of a formalisation, an extra constructor or optional field on
each integer value does not make too much of a difference, since all the rules
handle this uniformly and sensibly. But, as I hinted at earlier, this comes
with a disadvantage for implementations above SMT solvers which, at first
glance, looks like it could be sidestepped by tracking exposure instead.

The concern with enriching the SMT representation of integers (currently
represented with plain bit vectors) is that it may lead to a slow down of
\emph{all} integer related problems handled by the SMT solver, and complicate
counter-examples for users. This presents us with four options.
\begin{itemize}
    \item \textbf{Drop support for round-trip casts.} Use only
        \cinline{copy_alloc_id} instead, at the cost of being able
        to verify fewer programs.
    \item \textbf{Add an extra constructor (or optional field) to the SMT
        representation of all integer types.} Support all \kl{VIP} verifiable
        programs, at the cost of the cost of complicating specification of
        and slowing verification for code which did not use this feature.
    \item \textbf{Restrict the ability to perform round-trip casts to new C
        types.} Require some modification to \kl{VIP} programs, but
        make any specification complication or performance penalty opt-in. This
        makes the user-visible memory object model more complex.\sidenote{For
            example, users opt-in with a
            \cinline[breaklines]{typedef uintptr_t rt_uintptr [[roundtrip]];}
            so the C program treats them identically, but \kl{CN} would
            need casts between them.}\label{sn:optin-typedef}
    \item \textbf{Associate the provenance to \emph{a location} rather than a
        value, and track it in the resource system.} Such a resource would need
        to be duplicated, moved and destroyed in sync with the \emph{value} it
        is meant to be tracking via all memory actions.
\end{itemize}

There is another possibility, which we could entertain if we also allowed
exposure tracking:
\begin{itemize}
    \item \textbf{Recover provenance from ambient exposed allocations.} This
        would obviate the need to put allocation IDs in integer values at all.
\end{itemize}

If round-trip casts were the only issue related to provenance in integers, then
the situation would be relatively simple to handle. However, two of the
features of \kl{VIP} and \kl{PNVI-ae-udi} which does not get discussed very
much, but are quite important, is pointer bytes and
\cinline{memcpy}/\cinline{memcmp}.

In C, it is possible to convert any pointer to an (\cinline{unsigned})
\cinline{char*} value and manipulate its byte representation. For example,
given a particular platform\sidenote{Endianness is an implementation-defined
property.} programmers can store information in the lower or upper bits of
pointers\sidenote{By exploiting platform pointer alignment and addressable
memory constraints respectively.} by writing to bytes of a pointer directly
\emph{without reading them first and thus exposing (parts of) their allocation
address}. So long as at least one byte remains of the original pointer, the
provenance is preserved.

A byte-level view of pointers also supports type-punning pointers via union
fields, since the representation bytes could be written at the pointer type,
and reinterpreted at another.

Relatedly, programmers can also \cinline{memcpy} pointers and use the copied
pointers in the destination \emph{with the provenance carried over}, or
\cinline{memcmp} pointers, though the semantics of this is to ignore
provenances and compare addresses only. A further complication arises from the
fact that if a programmer writes their own version of \cinline{memcpy}, then
that must also preserve provenance, and that calls to such code may validly be
replaced by a call to the library \cinline{memcpy} as a compiler
optimisation.\sidenote{\cinline{memcpy} does not expose allocations, but a
    user-defined one will, so justifying this optimisation is still an open
    question~\cite{gustedt2021provenance}. Additionally, the value of padding
    bits are unspecified (ยง6.2.6.2\#3).}

In both \kl{VIP} and \kl{PNVI-ae-udi}, all these use-cases are supported by
having the abstract bytes in the abstract memory $M$ store not just the
byte value (or \coreinline{Unspecified}) but also a provenance. Pointer bytes
can be individually overwritten, but so long as one is untouched, the original
provenance can be recovered. Unions with a pointer field can be supported
similarly. Library \cinline{memcpy} simply copies over the abstract bytes to a
new location, and user-defined ones.

This leads to even more options.
\begin{itemize}
    \item \textbf{Drop support for byte-level provenance.} This would prevent
        manipulating pointer bytes, pointer type-punning in unions and
        user-defined \cinline{memcpy} from retaining provenance. It would
        also complicate the resource management required to have
        \cinline{memcpy} support copying provenances.\sidenote{Ideally,
            \cinline{memcpy} has a simple specification dealing with iterated
            ownerships of bytes, and leave handling structured values and
            resources (and the accompanying polymorphism) to other parts of the
            type system.}
    \item \textbf{Add an extra constructor (or optional field) to the SMT
        representation of characters}. Support all aforementioned idioms, at
        the cost of complicating specifications of and slowing verification for
        code which did not use this feature.
    \item \textbf{Restrict the ability to have provenance in bytes to a new C
        type.} Require some modification to \kl{VIP} programs, but make any
        performance penalty opt-in. This makes the user-visible memory object
        model more complex.\sidenote{See note~\ref{sn:optin-typedef}
        for a potential outline.}
    \item \textbf{Associate the provenance to \emph{a location} rather than a
        value, and track it in the resource system.} Such a resource would need
        to be duplicated, moved and destroyed in sync with the \emph{value} it
        is meant to be tracking via all memory actions.
\end{itemize}

There is another possibility, which we could entertain if we also allowed
exposure tracking:
\begin{itemize}
    \item \textbf{Prevent byte-level provenance features, \emph{unless} the
        allocation has already been exposed.} If the type system did
        track exposure, then the provenance could be recovered from ambient
        exposed allocations rather than from the bytes themselves.
\end{itemize}

The options for supporting round-trip casts are very similar to the options for
supporting byte-level provenance, even though on the surface, both features are
in principle, there to support very different low-level C idioms. This confluence
happens because:
\begin{itemize}
    \item In \kl{VIP} (unlike in \kl{PNVI-ae-udi}), round-trip casts are made
        possible by byte-level provenance (to preserve the $\mathit{Loc}$
        constructor through loads and stores).
    \item Both idioms seem to reflect a \emph{more general round-trip} property
        of casting (part of) a pointer to another representation and back.
    \item Both \cinline{char} and \cinline{uintptr_t} are \emph{integer} types in
        C, just of different widths. So it might be strange to a programmer if
        one supported round-trips but another did not.\sidenote{Fun fact: if
            its address is small enough, it is perfectly valid to cast a whole
            pointer into an \cinline{unsigned short} or \cinline{unsigned char}.}
\end{itemize}

In the face of these options, I first implemented \kl{VIP} \emph{without}
support for provenance in integers and bytes (in any form). This was
informative because it showed that the lack of provenance in bytes was much
more restrictive (on the \kl{VIP}/\kl{PNVI-ae-udi} tests cases) than the lack
of provenance in integers.

Considering this, and the options outlined above, I chose to restrict
the features (supporting round-trip casts, and having provenance in
bytes) to different, new C types. Aside from making any complexity and
performance penalties opt-in, it also follows the convention set out in C++17
with the introduction \mintinline{cpp}{std::byte}, which is specifically
intended to be used to access byte representation of objects. For simplicity, I
chose to defer any implementation of subtyping resources automatically.

\subsection{Non-deterministic pointer equality}\label{subsec:non-det-ptr-eq}

The official presentation of the \kl{VIP} memory model uses a strict variant of
the pointer equality memory operation, which only looks at the addresses to
determine whether two pointers are considered equal.

Disappointingly, things are not quite so simple in actual C
(\cref{fig:nd-ptr-eq-example}). Because of provenance analysis, the compiler can
\emph{sometimes, but not always} detect when two pointers of an
equality test must have different provenances, and so optimise the result to be
false.

\begin{figure}
    \cfile[breaklines]{code/provenance_equality_global_yx.c}
    \caption{An example C program which prints identical addresses but
        in some cases, a false result for pointer equality.}\label{fig:nd-ptr-eq-example}
\end{figure}

Therefore, when the pointers of an \cinline{==} have equal
addresses but distinct provenances, the result will be
non-deterministically true or false (\cref{fig:nd-ptr-eq}). In practice, this will
only happen if one of the pointers is one-past, or out-of-bounds as
the result of permissive array/member shift, or has an $@\mathsf{empty}$
provenance as the result of a cast from an integer.

\begin{figure*}
\begin{mathpar}
  \begingroup%
  \mprset{vskip=1ex}
  \inferrule[{[PNVI-ae-udi: $\textbf{eq\_ptrval} (p_1, p_2) = b$]}]{%
    {\color{violet} \pi_1 =_S \pi_2 \eqdef
        \left( \pi_1 = \iota_1 \wedge \pi_2 = \iota_2 \wedge S(\iota_1) = S(\iota_2) = \{\, i \,\} \right)} \\\\%
%
    {\color{violet} \pi_1 \neq_S \pi_2 \eqdef
        \left( \pi_1 = \iota_1 \wedge \pi_2 = \iota_2 \wedge \neg \left ( S(\iota_1) = S(\iota_2) = \{\, i \,\} \right) \right)} \\\\%
%
    \pi_1 =_\mathrm{id} \pi_2 \eqdef \left (\pi_1 = @i_1 \wedge \pi_2 = @i_2 \wedge i_1 = i_2 \right)\\\\%
%
    b \in {\begin{cases}
        \{\, \mathsf{true} \,\} &
            \mathrm{if}\ p_1 = p_2 = \mathsf{NULL} \\%
%
        \{\, \mathit{ident}_1 = \mathit{ident}_2 \,\} &
            \mathrm{if}\ p_1 = \mathsf{funptr}\,(\mathit{ident_1})
                \wedge p_2 = \mathsf{funptr}\,(\mathit{ident_2}) \\%
%
        \{\, a_1 =_{\mathbb{Z}} a_2 \,\} &
            \mathrm{if}\ p_1 = (\pi_1, a_1)
                \wedge p_2 = (\pi_2, a_2)
                \wedge \left( {\color{violet} \pi_1 =_S \pi_2} \vee \pi_1 =_\mathrm{id} \pi_2 \right) \\%
%
        \{\, (a_1 =_{\mathbb{Z}} a_2),  \mathsf{false} \,\} &
            \mathrm{if}\ p_1 = (\pi_1, a_1)
                \wedge p_2 = (\pi_2, a_2)
                \wedge \left( {\color{violet} \pi_1 \neq_S \pi_2} \vee {\color{red}\pi_1 \neq \pi_2} \right) \\%
%
        \{\, \mathsf{false} \,\} & \mathrm{otherwise} \\
    \end{cases}}
  }{%
    (A, {\color{violet}S,}\, M) \rightarrow (A, {\color{violet}S,}\, M)}
  \endgroup%
\end{mathpar}\caption{\kl{PNVI-ae-udi} rule for pointer equality. When addresses
    are equal but provenances are distinct (captured by the fourth case), the
    result of \cinline{==} operator will be non-deterministically either true or
    false. \textcolor{violet}{Parts specific to \kl{PNVI-ae-udi}, relating to
    \kl{symbolic provenances} $\iota$ are coloured in violet}.
    \textcolor{red}{Parts which break monotonicity with respect to the
    $@\mathsf{empty}$ provenance are highlighted in red}.}\label{fig:nd-ptr-eq}
\end{figure*}

\begin{figure}
\begin{mathpar}
  \begingroup%
  \mprset{vskip=1ex}
  \inferrule[{[PNVI-ae-udi: $\textbf{eq\_ptrval} (p_1, p_2) = b$]}]{%
    \mathsf{NULL} \cong \mathsf{NULL} \\
    \mathsf{funptr}\,(\mathit{ident}) \cong \mathsf{funptr}\,(\mathit{ident}) \\
    (@i, a) \cong (@i, a) \\\\
%
    {\color{violet} \iota_1 \approx \iota_2 \ \mathrm{if}\ S(\iota_1) = S(\iota_2) = \{\, i \,\}} \\
    {\color{violet} (\iota_1, a) \cong (\iota_2, a)\ \mathrm{if}\ \iota_1 \approx \iota_2} \\
    {\color{violet} (\iota_1, a) \questeq (\iota_2, a)\ \mathrm{if}\ \iota_1 \napprox \iota_2} \\
    {\color{red} (\pi_1, a) \questeq (\pi_2, a)\ \mathrm{if}\ \pi_1 \neq \pi_2} \\\\
%
    b = \mathsf{true}\ \mathrm{if}\ p_1 \cong p_2 \\
    b \in \{\, \mathsf{true},  \mathsf{false} \,\}\ \mathrm{if}\ p_1 \questeq p_2 \\
    b = \mathsf{false}\ \mathrm{otherwise}
  }{%
    (A, {\color{violet}S,}\, M) \rightarrow (A, {\color{violet}S,}\, M)}
  \endgroup%
\end{mathpar}\caption{\kl{PNVI-ae-udi} rule for pointer equality, rephrased to
    highlight the conditions for ambiguity. As in~\cref{fig:nd-ptr-eq},
    \textcolor{violet}{parts specific to \kl{PNVI-ae-udi}, relating to
    \kl{symbolic provenances} $\iota$ are coloured in violet};
    \textcolor{red}{parts which break monotonicity with respect to the
    $@\mathsf{empty}$ provenance are highlighted in red}.}\label{fig:nd-ptr-eq-rephrased}
\end{figure}

\begin{figure*}
\begin{tikzcd}[cramped,sep=small]
	& {(@i, @j)} && {\{\,\mathsf{true}\,\}} & & {\{\,\mathsf{false}\,\}} \\
	{(@i, @\mathsf{empty})} && {(@\mathsf{empty}, @j)} \\
	& {(@\mathsf{empty}, @\mathsf{empty})} &&& {\{\,\mathsf{true}, \mathsf{false}\,\}}
	\arrow[from=2-1, to=1-2, color=gray]
	\arrow[from=2-3, to=1-2, color=gray]
	\arrow[from=3-2, to=2-1, color=gray]
	\arrow[from=3-2, to=2-3, color=gray]
    \arrow[from=3-5, to=1-4, color=gray]
    \arrow[from=3-5, to=1-6, color=gray]
    \arrow[from=1-2, to=1-4, dashed]
    \arrow[from=2-1, to=3-5, dashed, crossing over, crossing over clearance=0.5ex, bend right=2]
    \arrow[from=2-3, to=3-5, dashed, bend left=6]
    \arrow[from=3-2, to=1-6, dashed, crossing over, color=red, bend right=8]
\end{tikzcd}%
\caption{Hasse diagram showing why the condition {\color{red}$\pi_1 \neq \pi_2$},
    represented by the dashed arrows $\rightdasharrow$, is not monotonic (when
    addresses are equal). $d_1 {\color{gray}\rightarrow} d_2$ if $d_1$ leads to
    more undefined behaviour than $d_2$. On the left is the domain of pairs of
    provenances, assuming $i \neq j$. On the right is the domain of sets of
    boolean values. The problematic, non-monotonic mapping is the red dashed
    arrow $\color{red}\rightdasharrow$.}\label{fig:ptr-eq-hasse}
\end{figure*}

This introduces a small syntactic inconsistency between the specification
language and C:\ in \kl{CN}'s specification language, \cninline{==} means
equality of pointers (address and provenance), but in C, \cinline{==} has
this strange non-deterministic behaviour. I sidestepped this issue by issuing a
warning whenever users write \cninline{==} in their specifications, pointing
them towards more informative (but verbose) named functions such as
\cninline{ptr_eq}, \cninline{addr_eq}, and \cninline{is_null}.

Unfortunately, adapting \kl{VIP} to handle the non-deterministic
pointer-equality rule is not straightforward. As it is defined in the paper and
appendix, the authors assume strict (address-only) pointer equality rule for both
\kl{VIP} and \kl{PNVI-ae-udi}. This means they sidestep the issue I present
next.

The issue is that, as stated, empty provenances do not lead to strictly more
undefined behaviour under PNVI-ae-udi, and the proof of soundness of VIP above
PNVI-ae-udi relies on this property. The example
in~\cref{fig:non-det-ptr-eq-problem} illustrates this problem.\sidenote{ As
mentioned in
\href{https://github.com/rems-project/cerberus/issues/954}{Cerberus\#954}, the
Cerberus implementation and formalisation differ in how they treat
$(@\mathsf{empty}, a) == (@\mathsf{empty}, a)$. The Cerberus implementation
treats it as always $\mathsf{true}$, whereas the Cerberus formalisation treats
it as always $\mathsf{false}$. Both are problematic as
per~\cref{fig:ptr-eq-hasse}, but need opposite if-conditions (\cinline{p != q} % chktex 26
and \cinline{p == q}, respectively) for their counter-examples
(\cref{fig:non-det-ptr-eq-problem}).}

\begin{figure}
    \cfile[breaklines]{code/non-det-ptr-eq-problem.c}%
    \caption{Counter-examples to the desirable property that
    $@\mathsf{empty}$ provenance leads to more undefined behaviour.  As is,
    \cinline{p} has $@\mathsf{empty}$ provenance at the time of the pointer
    equality test and does not lead to undefined behaviour, because the
    \cinline{p == q} always evaluates to \cinline{false} according to the rule
    in~\cref{fig:nd-ptr-eq}. If \cinline{p = &x} is uncommented, then
    \cinline{p} has non-$@\mathsf{empty}$ provenance, which leads to the
    non-deterministic case, which allows for executing the then-branch. This
    branch has undefined behaviour because \cinline{q} has $@\mathsf{empty}$
    provenance.}\label{fig:non-det-ptr-eq-problem}
\end{figure}

The examples rely on being able to construct two pointers \cinline{p} and
\cinline{q}, with the same address. What differs is that in one version, both
have $@\mathsf{empty}$ provenances (lines 10 and 11), and in the other,
\cinline{p} has a non-$@\mathsf{empty}$ provenance (uncommenting line 12). They
are tested for equality in the condition of an if-statement, in which the true
branch,\sidenote{But the false branch for the Cerberus implementation.} there is
\cinline{*q}, which is always undefined since it has $@\mathsf{empty}$
provenance and loads requires a non-$@\mathsf{empty}$, live allocation ID\@.

When \cinline{p} and \cinline{q} both have $@\mathsf{empty}$ provenance, the
test is always \cinline{false},\sidenote{But always \cinline{true} in the
implementation.} and so the undefined behaviour load is never run. However, when
\cinline{p} has a non-$@\mathsf{empty}$ provenance, the value of the condition
is non-deterministically \cinline{true} or \cinline{false}, and so both branches
of the if-statement could run, and so if either branch has undefined behaviour,
the whole statement (and whole program) is deemed to have undefined behaviour.

The mathematically elegant solution to this is to adjust the rule for pointer
equality so that the $(@\mathsf{empty}, a) == (@\mathsf{emtpy}, a)$ case is also
non-deterministic. This also benefits the \kl{CN} implementation because, in
most cases\sidenote{Except for memory bytes, see~\nameref{subsec:smt-rep}.}
$@\mathsf{empty}$ provenances can be represented in the SMT solver problem as
fresh unconstrained allocation IDs, rather than requiring a datatype with two
separate constructors.

It is worth noting that ISO/IEC TS 6010:2025, the technical standard for a
provenance aware memory object model for C (specifically, C17), eschews
non-deterministic pointer equality and opts to use only address
equality~\sidecite{gustedt2021provenance}.

\subsection{Allocation history}\label{subsec:alloc-history}

The allocation history in \kl{VIP} and \kl{PNVI-ae-udi} is mostly append-only
(new allocations are added, but old allocations are never removed) with the
exception that when an allocation is \coreinline{kill}ed, a boolean flag in its
entry (which is marked true when it is created) is set to false.

An allocation being live is important for some pointer operations, such as
relational ones, which require the operand pointers to be in bounds of the same
live allocation for the operation to not have \kl{UB}. However, for other
operations (such as member shifting), it must still satisfy a bounds check, but
whether an allocation is live is irrelevant. There is no operation which
requires knowing that an allocation is dead.

So bounds checks do not require live allocation, some operations require
live allocations but do not change that, and \coreinline{kill} requires
a live allocation but changes this.

As such, in \kl{CN}, I chose to represent the bounds check information as
\emph{constraints}, whereas I chose to represent liveness itself as an
\emph{allocation token} \cninline{Alloc}.

For the former, the type system and programmers need a way to refer to the
allocation history. It can be thought of as an implicit logical parameter
passed into and out of every function, and so I model it with an initially
unconstrained SMT variable. As \kl{CN} type-checks a \kl{ResCore} program, it
will learn constraints: either from creating new allocations, or from
postconditions of called functions, or derive them from allocation tokens
\cninline{Alloc}, in the resource context on the allocation history.

For the latter, \cninline{Alloc} take an allocation ID as an argument,
unlike \cninline{RW}/\cninline{W} and user-defined predicates
which are restricted to pointers only.

Unlike pointer disjointness facts based on \coreinline{RW}/\cninline{W}, I do
not derive allocation or ID disjointness facts from
multiple allocation tokens, since there has been no visible need for it
yet.\sidenote{The only rule which needs to know whether two provenances are
\emph{not} equal is the non-deterministic case in the pointer equality rule,
and a relatively simple, if not slightly confusing annotation,
\cninline[breaklines]{ptr_eq(p,q) || !addr_eq(p,q)} can rule that % chktex 26 chktex 36
out.}\label{sn:ptr-eq-annotation} Dead allocations may perfectly well overlap
with live ones, though their allocation IDs will still be distinct, so tracking
all forms of disjointness accurately would add significant complexity for
little benefit.

\subsection{SMT representations}\label{subsec:smt-rep}

One of the tricky aspects of adapting the memory object models to \kl{CN} is
that the models are defined over \emph{concrete} values and executions, whereas
\kl{CN} is fundamentally computing over \emph{symbolic} values.

Another is that adding extra variables (for default values in an infinite
domain) to an SMT problem is cheap (both to implement and to query) but can
affect usability, or worse, soundness if done incorrectly. Using algebraic
datatypes and adding an extra constructor takes more time, and may slow down
queries, but is necessary when those extra constructors need to be inspected.

\paragraph{Addresses.}%
The advantage of using symbolic values for addresses, is that this gives us
(demonic) allocation address non-determinism for free (whilst cheerfully
sacrificing the ability to say anything about the layout of local or global
variables, without the use of lemmas).

\paragraph{Provenances.}%
Should provenances be concrete? Any choice must respect how they are used  \textemdash{}
for querying whether two are equal; for querying whether two are distinct (only
for non-deterministic pointer equality); for the non-$@\mathsf{empty}$ ones
(allocation IDs), used as keys to get the associated base address and size from
the allocation history.

\paragraph{Empty provenance.}%
If the memory object model uses the empty provenance monotonically with respect
to undefined behaviour, then it may be represented as an unconstrained
allocation ID.\@ Currently, there are two places where this is not the case.
The first is non-deterministic pointer equality as mentioned previously, but
this is easy to fix. The second is in recovering provenance from bytes: this
is important to support, but is limited only to bytes, which can be represented
as a distinct C type. Thus $@\mathsf{empty}$ provenances can be represented
as unconstrained allocation IDs for pointer and roundtrip-integer types,
and represented as an option type for bytes.

% Still, we can entertain how one might
% proceed in each of the three situations.
% \begin{itemize}
%     \item \textbf{Drop $@\mathsf{empty}$ provenances.} This requires
%         no representation of this construct.
%     \item \textbf{Drop totality for pointer equality.}
%         A single, global unconstrained variable, with explicit constraints that
%         non-empty provenances are not equal to it, would work.
%     \item \textbf{Drop non-determinism for pointer equality.}
%         A single, global unconstrained variable would work. However, since with
%         this option, all rules are monotonic with respect to $@\mathsf{empty}$
%         provenances, i.e.\ any rule which uses an empty provenance will end up
%         failing its bounds checks and thus signalling \kl{UB}, there is no need
%         to add non-empty provenance constraints to the context.
% \end{itemize}

\paragraph{Non-empty provenances (allocation IDs).}%
As for non-$@\mathsf{empty}$ provenances (allocation IDs), it is simpler to
leave them symbolic rather than try assign concrete values to them: two pointer
arguments to a function can validly have the same or different provenances, and
so it is best to leave the user to write constraints about the (in)equality of % chktex 36
relevant provenances.

\paragraph{Omitting function pointers.}%
With the representation of provenance and addresses fixed, the representation
of pointers I chose was guided by that given in \kl{VIP} and \kl{PNVI-ae-udi}:
a special constructor for the \cinline{NULL} pointer, or a pair of a
provenance and an address. I omit support for function pointers;
they would need care to be integrated ergonomically. For example, in defining
predicates which take pointer arguments, almost all the time a pointer will be
intended to be either \cinline{NULL} or pointing to an object, so
the default should opt out of the function pointer case.

\paragraph{\cinline{NULL} pointer.}%
Though I do not know why \cinline{NULL} is not represented as
$(@\mathsf{empty}, 0)$ in the memory model,\sidenote{My conjecture is that it
    was a historical accident where PVI was developed first and in that model,
    $(@\mathsf{empty}, 0)$ represented an integer value, so a separate value
was used to represent \cinline{NULL} pointers.} I did observe a
small but useful reason to have it as a separate constructor during
implementation. With pointer equality in C (non-deterministic or otherwise),
the only information that the true branch of a pointer equality test gives the
programmer is that the addresses are equal; it says nothing about the
provenances. Conversely, with non-deterministic pointer equality, the false
branch does \emph{not} guarantee that the addresses are distinct: they could be
equal but have distinct provenances.

As I mentioned in \nameref{subsec:alloc-history}, to deduce \cinline{p} equals
\cinline{q} from testing \cinline{p == q}, a programmer needs the slightly
confusing annotation that \cninline[breaklines=true]{ptr_eq(p,q) || !addr_eq(p,q)}. % chktex 26 chktex 36
This constraint excludes the counter-intuitive (and non-deterministic) case of
the provenances being distinct but the addresses equal.\sidenote{Stated another
way, it can be seen as a promise that neither of the pointers are one-past
pointers, nor out-of-bounds as the result of a permissive array/member shift,
nor have an empty provenance as a result of a cast from an integer. A
sufficient (but not necessary) condition for this is that both pointers are
strictly within bounds of their allocations.} Whilst \kl{CN} aims to minimise
obvious annotations, this one seems difficult to avoid due to the
inherited complexity of pointer equality tests, and the complexity with
tracking allocation and ID disjointness in the type system.

However, whilst programmers do check two pointers for equality often, they
check whether or not pointers are \cinline{NULL} far more. If \cinline{NULL} is
represented by $(@\mathsf{empty}, 0)$, then (in the presence of permissive
array/member offsets, since the other cases cannot apply) such checks would
need constraints too. A distinct \coreinline{null} constructor removes the need
for adding such constraints before every null-check.

\paragraph{Bytes, initialisation, padding and unions}%

The \kl{ISO} standard is unclear about the semantics of reads from
uninitialised memory and padding bytes, and there is no consensus de facto
practice. Completely banning reads from them is not ideal because we would like
to permit byte-by-byte copying if possible.

\kl{Cerberus} opts for a defined semantics for reads of uninitialised objects,
involving a notion of \intro{unspecified values}.\sidenote{From 4.6.2 in
    \textcite{memarian2022cerberus}: \textit{``\ldots an abstract unspecified
        value which is propagated by arithmetic in a strict way, with the
        exception that operations that can have undefined behaviour are
        daemonic \ldots the unsigned addition operator over integer types has
        no undefined behaviour \ldots applying an unspecified value as right
operand of the division operator has undefined behaviour \ldots When the
controlling expression of a statement evaluates to an unspecified value, the
control-flow will non-deterministically behave''.}} These would map well to
unconstrained variables in SMT solvers.

In constrast, \kl{CN} takes a more conservative stance and forbids reads from
uninitialised memory. The justification for this is that, in a verification
context, it pays to be safer and is easier to debug a failed proof if the error
message directly mentions the user tried to read from uninitialised memory
rather than figure out how an unconstrained value entered the context.

% At the same time, the rest of the \kl{CN} presently forbids reads from
% uninitialised memory, and it would be inconsistent to subvert this design
% choice via accessing byte representations. The distinction is enforced with
% \cninline{W} for uninitialised memory (write-only) and \cninline{RW} for
% initialised (read and write).\sidenote{See \nameref{sec:partial-init-structs}
% for a discussion.}

Hence, bytes need to be represented in a way such that they (a) represent the
`least upper-bound' for all C types and (b) for consistency, preserve the
distinction between uninitialised and initialised memory whilst (c) allowing
arbitrary reads and writes, including being passed to \cinline{memcpy}.

The SMT representation for this (in OCaml syntax) is
\coreinline[breaklines]{type byte = (u8 * alloc_id option) option}. The outer
\coreinline{option} captures whether the byte is from initialised or
uninitialised memory. The inner option captures the fact provenance may be
recovered from bytes if all non-$@\mathsf{empty}$ provenances agree with each
other, which is not a monotonic operation.

The choice of bytes feeds two birds with one scone because it also hints at how
to support unions ergonomically in \kl{CN}. Ownership of a union gives
ownership of an array of bytes, and this array can be transfomred to and from
ownership of each of its fields, and a token representing ownership of the
padding.\sidenote{\kl{Cerberus} does not currently support switching on
endianness, so I match its default big-endianness, which is also suitable for
verifying \kl{pKVM} on Arm}

Consider a \cinline[breaklines]{union u { int x; uintptr_t y; int *p z; }}.
Ownership \cninline{take u = RW<union u>(p)} would mean \cninline{u: array byte}. % chktex 36
If one wishes to write or read a field, then the ownership would need to
be transformed into \cninline{take z = RW<int*>(member_shift(p,z))}, and % chktex 36
padding resource \cninline{take p = Padding<union u, z>(p)}, along with % chktex 36
constraints relating byte array \cninline{u} to integer \cninline{z} and byte
array \cninline{p}. Note that the padding may be effectively empty, but is
still necessary to reconstruct the union from its members.

% \paragraph{Memory bytes.}%
% As I mentioned before, the issue of pointer bytes meant that I chose to have a
% new C type for manipulating the byte-level representation of C objects. Not
% only does this need to handle provenance in bytes
% (\cref{subsec:prov-int-bytes}), but also uninitialised and padding bytes as
% mentioned above. As a result, I chose to represent the \intro{memory bytes} as
% a datatype with two constructors: one for $\mathsf{unspec}$, one for a pair of
% a 8-bit vector and an optional allocation ID (for writing and recovering
% pointer provenance). The representation of \cninline{W}s and padding bytes
% are mapped to \cninline{unspec} values, the representation of \cninline{RW}
% values I map to their appropriate byte (depending on
% index), and an allocation ID if it is part of a pointer.

\paragraph{Permissive array and member offsets}%
In \kl{VIP} and \kl{PNVI-ae-udi}, array and member offsets are only defined on
pointers with a provenance. Permissive member shifts are defined for
\cinline{NULL} pointers; they result in a pointer with an $@\mathsf{empty}$
provenance, and the \cinline{offsetof} value in the address. However, when
encoding these operations in SMT problems, such offsetting needs to be total,
defined on all values. The operation is morally partial, but is used in a total
setting \emph{for the specification language}, and so needs a defined
semantics. Since \kl{CN} does not support permissive member shifts (programmers
can use \cinline{offsetof} in such cases), I chose the semantics to be
\cninline[breaklines]{member_shift<tag>(NULL, _) == NULL} (and similarly % chktex 36
for \cninline{array_shift}).

\subsection{Summary}

\begin{itemize}
    \item \textbf{All pointers on a platform are the same size.} This
        allows me to drop the pointer index component of the abstract bytes
        from the abstract memory (see note~\ref{sn:ignore-ptr-index}).
    \item \textbf{All provenances must be disambiguated immediately.} This
        requires using \cinline{copy_alloc_id}, but saves tracking
        disambiguation in the resource system (and sidesteps wondering what
        adjacent addresses look like in a symbolic evaluation setting).
    \item \textbf{Allocation address exposure is not tracked.} This prevents
        verifying code like XOR-lists, and complicates support for round-trip
        casts and limits options for byte-level provenance. If needed,
        implementing such tracking should be a straightforward extension in the
        future.
    \item \textbf{Initially, no support for provenances in integers or bytes
        (or a resource polymorphic \cinline{memcpy}).}
        This prevents a substantial amount of the \kl{VIP}/\kl{PNVI-ae-udi}
        test-suite from passing without additional annotations.
    \item \textbf{Later, support provenance in integers and bytes via new C
        types.} This makes their associated complexity and any performance
        penalties opt-in.
    \item \textbf{Allocation history tracked in constraints.} This makes
        bounds checks easy to state and check.
    \item \textbf{Allocation liveness tracked in resources.} This leverages the
        existing resource context set up to manage allocations correctly and
        check if pointers are live.
    \item \textbf{Allocation and ID disjointness is not inferred.} Tracking
        this accurately would be complicated, and the benefit (of reducing
        annotations required for testing pointer equality) would be limited.
    \item \textbf{Use extra constructors for \cinline{NULL} and
        \coreinline{Unspecified} bytes, and unconstrained variables everywhere
        else.} This means using variables for addresses and allocation IDs.
\end{itemize}
