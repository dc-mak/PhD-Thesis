\documentclass{article}
\usepackage{amsmath,amssymb}%
\usepackage{unicode-math}%

%% begin auto-gen
\newcommand{\cndruleIXXCmpXXNameXXNeq}[1]{\cndrule[#1]{%
\cnpremise{{ \alpha }_{{\mathrm{1}}}  \neq  { \alpha }_{{\mathrm{2}}}}%
}{
\symrm{ \Phi }  \vdash   \cnkw{each}  \left(\! \cnkw{integer} \ x;  \_  \right)\, \left\{  { \alpha }_{{\mathrm{1}}}  \left(  \_  \right)  \, \right\}   \mathrel{ {\sqsubseteq}{?} }   \cnkw{each}  \left(\! \cnkw{integer} \ x;  \_  \right)\, \left\{  { \alpha }_{{\mathrm{2}}}  \left(  \_  \right)  \, \right\}   \leadsto   \outpol{  \cnkw{None}  } }{%
{\cndrulename{I\_Cmp\_Name\_Neq}}{}%
}}


\newcommand{\cndruleIXXCmpXXIGXXNeq}[1]{\cndrule[#1]{%
\cnpremise{\symrm{ \Phi }  \vdash \, \cnkw{cmp\_min} \, \left(  \cnnt{iguard}  \cnsym{,}  \cnnt{iguard'}  \right)  \leadsto   \outpol{  \cnkw{None}  } }%
}{
\symrm{ \Phi }  \vdash   \cnkw{each}  \left(\! \cnkw{integer} \ x;  \cnnt{iguard}  \right)\, \left\{  { \alpha }  \left(  \_  \right)  \, \right\}   \mathrel{ {\sqsubseteq}{?} }   \cnkw{each}  \left(\! \cnkw{integer} \ x;  \cnnt{iguard'}  \right)\, \left\{  { \alpha }  \left(  \_  \right)  \, \right\}   \leadsto   \outpol{  \cnkw{None}  } }{%
{\cndrulename{I\_Cmp\_IG\_Neq}}{}%
}}


\newcommand{\cndruleIXXCmpXXIArgXXNeq}[1]{\cndrule[#1]{%
\cnpremise{\symrm{ \Phi }  \vdash \, \cnkw{cmp\_min} \, \left(  \cnnt{iguard}  \cnsym{,}  \cnnt{iguard'}  \right)  \leadsto   \outpol{  \cnnt{cmp}  \cnsym{,}  \cnnt{iguard''}  } }%
\cnpremise{\cnnt{term}  \eqdef  \cnnt{iguard''}  \rightarrow  \left(  \cnnt{iargs}  \right)  \cnsym{=}  \left(  \cnnt{iargs'}  \right)}%
\cnpremise{\cnkw{smt} \, \left(  \symrm{ \Phi }  \Rightarrow  \exists \, \cnmv{x}  . \:  \neg \, \cnnt{term}  \right)}%
}{
\symrm{ \Phi }  \vdash   \cnkw{each}  \left(\! \cnkw{integer} \ x;  \cnnt{iguard}  \right)\, \left\{  { \alpha }  \left(  \cnnt{iargs}  \right)  \, \right\}   \mathrel{ {\sqsubseteq}{?} }   \cnkw{each}  \left(\! \cnkw{integer} \ x;  \cnnt{iguard'}  \right)\, \left\{  { \alpha }  \left(  \cnnt{iargs'}  \right)  \, \right\}   \leadsto   \outpol{  \cnkw{None}  } }{%
{\cndrulename{I\_Cmp\_IArg\_Neq}}{}%
}}


\newcommand{\cndruleIXXCmpXXComparable}[1]{\cndrule[#1]{%
\cnpremise{\symrm{ \Phi }  \vdash \, \cnkw{cmp\_min} \, \left(  \cnnt{iguard}  \cnsym{,}  \cnnt{iguard'}  \right)  \leadsto   \outpol{  \cnnt{cmp}  \cnsym{,}  \cnnt{iguard''}  } }%
\cnpremise{\cnnt{term}  \eqdef  \cnnt{iguard''}  \rightarrow  \left(  \cnnt{iargs}  \right)  \cnsym{=}  \left(  \cnnt{iargs'}  \right)}%
\cnpremise{\cnkw{smt} \, \left(  \symrm{ \Phi }  \Rightarrow  \forall \, \cnmv{x}  . \:  \cnnt{term}  \right)}%
}{
\symrm{ \Phi }  \vdash   \cnkw{each}  \left(\! \cnkw{integer} \ x;  \cnnt{iguard}  \right)\, \left\{  { \alpha }  \left(  \cnnt{iargs}  \right)  \, \right\}   \mathrel{ {\sqsubseteq}{?} }   \cnkw{each}  \left(\! \cnkw{integer} \ x;  \cnnt{iguard'}  \right)\, \left\{  { \alpha }  \left(  \cnnt{iargs'}  \right)  \, \right\}   \leadsto   \outpol{  \cnnt{cmp}  } }{%
{\cndrulename{I\_Cmp\_Comparable}}{}%
}}
\newcommand{\cndefnIXXCmp}[1]{\begin{cndefnblock}[#1]{$\symrm{ \Phi }  \vdash  \cnnt{ipred\_term}  \mathrel{ {\sqsubseteq}{?} }  \cnnt{ipred\_term'}  \leadsto  \outpol{ opt\_cmp }$}{\cncom{given constraints $\symrm{ \Phi }$ , $\cnnt{ipred\_term}$ is potentially included in $\cnnt{ipred\_term'}$ (or vice-versa) with ordering $\outpol{ opt\_cmp }$}}
\cnusedrule{\cndruleIXXCmpXXNameXXNeq{}}
\cnusedrule{\cndruleIXXCmpXXIGXXNeq{}}
\cnusedrule{\cndruleIXXCmpXXIArgXXNeq{}}
\cnusedrule{\cndruleIXXCmpXXComparable{}}
\end{cndefnblock}}
% end auto-gen

% Can define/renew these to heart's content
\newcommand{\cndrule}[4][]{{\displaystyle\frac{\begin{array}{l}#2\end{array}}{#3}\quad\cndrulename{#4}}}
\newcommand{\cnusedrule}[1]{\[#1\]}
\newcommand{\cnpremise}[1]{ #1 \\}
\newenvironment{cndefnblock}[3][]{ \framebox{\mbox{#2}} \quad #3 \\[0pt]}{}
\newenvironment{cnfundefnblock}[3][]{ \framebox{\mbox{#2}} \quad #3 \\[0pt]\begin{displaymath}\begin{array}{l}}{\end{array}\end{displaymath}}
\newcommand{\cnfunclause}[2]{ #1 \equiv #2 \\}
\newcommand{\cnnt}[1]{\mathit{#1}}
\newcommand{\cnmv}[1]{\mathit{#1}}
\newcommand{\cnkw}[1]{\mathbf{#1}}
\newcommand{\cnsym}[1]{#1}
\newcommand{\cncom}[1]{\text{#1}}
\newcommand{\cndrulename}[1]{\textsc{#1}}
\newcommand{\cncomplu}[5]{\overline{#1}^{\,#2\in #3 #4 #5}}
\newcommand{\cncompu}[3]{\overline{#1}^{\,#2<#3}}
\newcommand{\cncomp}[2]{\overline{#1}^{\,#2}}
\newcommand{\cngrammartabular}[1]{\begin{supertabular}{llcllllll}#1\end{supertabular}}
\newcommand{\cnmetavartabular}[1]{\begin{supertabular}{ll}#1\end{supertabular}}
\newcommand{\cnrulehead}[3]{$#1$ & & $#2$ & & & \multicolumn{2}{l}{#3}}
\newcommand{\cnprodline}[6]{& & $#1$ & $#2$ & $#3 #4$ & $#5$ & $#6$}
\newcommand{\cnfirstprodline}[6]{\cnprodline{#1}{#2}{#3}{#4}{#5}{#6}}
\newcommand{\cnlongprodline}[2]{& & $#1$ & \multicolumn{4}{l}{$#2$}}
\newcommand{\cnfirstlongprodline}[2]{\cnlongprodline{#1}{#2}}
\newcommand{\cnbindspecprodline}[6]{\cnprodline{#1}{#2}{#3}{#4}{#5}{#6}}
\newcommand{\cnprodnewline}{\\}
\newcommand{\cninterrule}{\\[5.0mm]}
\newcommand{\cnafterlastrule}{\\}

% ----------------------------------------------------------------
% For \Asterisk: mathabx conflicts with other packages sometimes..
% ----------------------------------------------------------------
% Setup the mathb font (from mathabx.sty)
\DeclareFontFamily{U}{mathb}{\hyphenchar\font45}
\DeclareFontShape{U}{mathb}{m}{n}{
      <5> <6> <7> <8> <9> <10> gen * mathb
      <10.95> mathb10 <12> <14.4> <17.28> <20.74> <24.88> mathb12
      }{}
\DeclareSymbolFont{mathb}{U}{mathb}{m}{n}

% Define a subset character from that font (from mathabx.dcl)
% to completely replace the \subset character, you can replace
% \varsubset with \subset

% Magic "06 obtained from looking at font table
% \usepackage{fonttable}
% \fonttable{mathb10}
\DeclareMathSymbol{\Asterisk}{3}{mathb}{"06}
\usepackage{scalerel}
\DeclareMathOperator*{\bigAst}{\scalerel*{\Asterisk}{\sum} }
% ----------------------------------------------------------------


% Cosmetic
\renewcommand{\cnnt}[1]{ \symit{#1} }
\renewcommand{\cnmv}[1]{ \symit{#1} }
\renewcommand{\cnkw}[1]{ \symtt{#1} }
\renewcommand{\cndrule}[4][]{ {\displaystyle\frac{\begin{array}{l}#2\end{array} }{#3}\quad\cndrulename{#4} }\\[\baselineskip] }
\renewcommand{\cngrammartabular}[1]{ \begin{supertabular}{llcllll}#1\end{supertabular} }

% Grammar production comments on the next line
\renewcommand{\cnprodline}[6]{%
& & $#1$ & $#2$ & $#3 #4$ & $#5$ &%
\ifthenelse{ \equal{}{#6} }%
{#6}%
{\\ & & & \multicolumn{4}{p{.5\textwidth} }{#6} } }
\renewcommand{\cnrulehead}[3]{$#1$ & & $#2$ & \multicolumn{4}{l}{#3} }

% Green comments - can't do colorbox because it doesn't wrap (neither does \usepackage{soul}'s \hl)
\usepackage[dvipsnames,usenames]{xcolor}
\definecolor{darkgreen}{rgb}{.0, 0.392, .0}
\renewcommand{\cncom}[1]{ \textcolor{darkgreen}{ #1 } }

% https://tex.stackexchange.com/questions/33401/a-version-of-colorbox-that-works-inside-math-environments
\setlength{\fboxsep}{1pt}
\newcommand{\outpol}[1]{\mathchoice%
  {\colorbox{red!8}{$\displaystyle      \symit{ #1 } $} }%
  {\colorbox{red!8}{$\textstyle         \symit{ #1 } $} }%
  {\colorbox{red!8}{$\scriptstyle       \symit{ #1 } $} }%
  {\colorbox{red!8}{$\scriptscriptstyle \symit{ #1 } $} } }%
\newcommand{\norm}[1]{ \underline{\symit{#1} } }
\newcommand{\mathTT}[1]{\mathchoice%
  {\displaystyle      \texttt{ #1 } }%
  {\textstyle         \texttt{ #1 } }%
  {\scriptstyle       \texttt{ #1 } }%
  {\scriptscriptstyle \texttt{ #1 } } }%

% Futzing
\ExplSyntaxOn
\NewDocumentCommand{\onlyUseNthCnPremise}{m +m}
 {
   \group_begin:

   \seq_set_split:Nnn \l_indices { , } { #1 }
   % \seq_show:N \l_indices

   % Backup original \cndrule
   \cs_set_eq:NN \orig_cndrule: \cndrule

  % Using \seq_map_indexed_inline caused weird scoping issues inside the body
  % Couldn't figure out how to get ##2 to refer to the inner rather than outer
  % version (###2 didn't work - maybe because the \cs_set_protected should
  % really be a RenewDocumentCommand
  \cs_set_protected:Nn \handle_premise:nn
    {
      % #1 - index
      % #2 - item (a token list like { \symrm{\Phi} \vdash ... })
      \seq_if_in:NnTF \l_indices { ##1 }
        {
          \seq_put_right:Nn \l_filtered { \cnpremise { ##2 } }
          % \iow_term:x { Adding~premise~\int_to_arabic:n {##1}:~\tl_to_str:n {##2} }
        }
        {
          % \iow_term:x { Skipping~premise~\int_to_arabic:n {##1}:~\tl_to_str:n {##2} }
        }
    }

   % Locally override \cndrule
   \cs_set_protected:Npn \cndrule [##1]##2##3##4
     {
       % Split on \cnpremise
       \seq_set_split:Nnn \l_premises { \cnpremise } { ##2 }
       % First one is empty
       \seq_pop_left:NN \l_premises \l_tmpa_tl%
       % \seq_show:N \l_premises

       \seq_clear_new:N \l_filtered
       \seq_map_indexed_function:NN \l_premises \handle_premise:nn
       % \seq_show:N \l_filtered

       \orig_cndrule: [##1]{\seq_use:Nn \l_filtered {}}{##3}{##4}
     }

   #2
   \group_end:
 }

\cs_new_eq:NN\StrIfInTF\str_if_in:nnTF
\ExplSyntaxOff%



\begin{document}

\cnusedrule{\onlyUseNthCnPremise{1,3}{\cndruleIXXCmpXXComparable{}}}
\cnusedrule{\onlyUseNthCnPremise{1,3}{\cndruleIXXCmpXXComparable{}}}

\end{document}
