% vim: ft=tex
\PassOptionsToPackage{dvipsnames,usenames}{color}
\documentclass[11pt]{article}%

% Ignore TODOs for now
\newcommand{\todo}[1]{}
\newcommand{\TODO}[1]{}
\usepackage{wrapfig}

\usepackage{hyperref}
%\hypersetup{colorlinks=true,linkcolor=DarkGreen,urlcolor=DarkGreen,citecolor=DarkGreen}
\hypersetup{colorlinks=true,linkcolor=OliveGreen,urlcolor=OliveGreen,citecolor=OliveGreen}
\usepackage{amsmath,amssymb}%
\usepackage{unicode-math}%
% supertabular package required if using the default grammar tabular
\usepackage{supertabular}
\usepackage[margin=1in]{geometry}
\geometry{landscape}
\usepackage{ifthen}

% the un-wrapped (-tex_wrap false) generated LaTeX file for CN
\include{_gen/cn_included}
% the package that allows customized layout described in this document
\usepackage{ott/ottlayout}
% the automatically generated file (with our Makefile) to link the generated
% LaTeX with the ottlayout package
\include{_gen/cn_override}
\include{_gen/cn_drulenames}
\ottstyledefaults{numberpremises=yes,premisenamelayout=topright,rulelayout=nobreaks}

\usepackage{titlesec}
\newcommand{\sectionbreak}{\clearpage}

\renewcommand{\thesection}{A\arabic{section}}
\makeatletter
\renewcommand{\l@section}{\@dottedtocline{1}{1.5em}{2.6em}}
\renewcommand{\l@subsection}{\@dottedtocline{2}{4.0em}{3.6em}}
\renewcommand{\l@subsubsection}{\@dottedtocline{3}{7.4em}{4.5em}}
\makeatother

\title{\vspace{-2cm} Formal definition of the kernel type system}
\author{Dhruv C. Makwana}
\date{}

\begin{document}

\maketitle%


%% \begin{abstract}
%% CN is a type system for the C programming language.
\noindent
The formalisation is defined
over a let-normalised version of the Core language of
\href{https://github.com/rems-project/cerberus}{Cerberus}. A proof of soundness
of type checking is given in a separate document.
%% \end{abstract}

{\let\clearpage\relax \tableofcontents}

\section{Commentary}
\label{sec:commentary}

In this document, we formalise ``kernel CN'',
which is essentially ordinary CN with no type and
resource inference. In particular, we assume that all
universal quantifiers are explicitly instantiated, that all
existential quantifiers have explicit witnesses, and all resource
manipulations have proof terms with linear/substructural
types. However, we do not require proof terms for the logical
properties, since by construction all of the entailments fall
into the SMT fragment. Since our inference algorithm can be extended
to an elaboration algorithm producing a fully-annotated program,
kernel CN could serve as an intermediate representation for the CN
compiler (which we have formalised elaboration for iterated resource
manipulation, though not footprint analysis).
Moreover, the lack of inference makes it a simpler language
to prove type safety for.

The kernel CN is a calculus in A-normal form, with a bidirectional
type system. Since we handle the majority of C, the entire system is very
large, and so we only provide commentary on the highlights.

\subsection{Types and Terms}

As in the paper, CN programs have both computational and logical terms.
Every such term, computational or ghost, has a \emph{base type} $[[ base_type ]]$,
which are things like unit, booleans, (mathematical) integers, locations,
and records of other base types. Each C type $[[ ct ]]$ is mapped to a
corresponding base type -- for example, \ $[[ to_base ( int * ) ]] = [[ loc ]]$.
Logical terms are variously referred to as $[[ term ]]$, $[[ ptrt ]]$
(for pointers), $[[ valuet ]]$ (for pointees), $[[ iarg ]]$ (for
input-arguments), $[[ oarg ]]$ (output-arguments, of type record or array of
records), and $[[ iguard ]]$ (for boolean guards of iterated resources).

\begin{wrapfigure}{l}{.5\textwidth}
\vspace{-1.5\baselineskip}
\begin{align*}
    [[ res ]] &::= [[ emp ]] \mid [[ term ]] \mid [[ pred ]] \mid [[ qpred ]] \mid [[ res1 * res2 ]]
        \mid [[ exists y : base_type . res' ]] \mid [[ if term then res1 else res2 ]]\\
    [[ pred ]] &::= [[ a ( ptrt , iargs ) ( oarg ) ]] \\
    [[ qpred ]] &::= [[ { x ; iguard . a ( ptrt + step , iargs ) } ( oarg ) ]] \\[1em]
%     [[ qpred_term ]] &::= [[   ]]\\[1em]
    [[ res_term ]] &::= [[ emp ]] \mid [[ TERM ]] \mid [[ pred_term ]] \mid [[ qpred_term ]] \mid [[ < res_term1 , res_term2 > ]]
        \mid [[ pack ( oarg , res_term' ) ]]\\
       & \qquad [[ r ]] \mid [[ fold res_term : pred ]] \mid [[ pred_ops ]] \\
    [[ pred_ops ]] &::=
           [[ explode ( res_term )                       ]]
    \mid   [[ implode ( res_term , ty_tag )              ]]
    \mid   [[ iterate ( res_term , ty_int )              ]]\\
    &\quad [[ congeal ( res_term , ty_int )              ]]
    \mid   [[ break ( res_term , term )                  ]]
    \mid   [[ glue ( res_term )                          ]]\\
    &\quad [[ inj ( res_term , ptrt , step , x . iargs ) ]]
    \mid   [[ chop ( res_term , iguard )                 ]]
\end{align*}
\caption{\vspace{-2\baselineskip}Grammar of Resource Terms}
\label{fig:resource-grammar}
\end{wrapfigure}

In Figure~\ref{fig:resource-grammar}, we give the grammar of resource types
(i.e., separation logic predicates) and resource terms (the proof terms used by
the kernel Core typechecker).
%
The standard resources $[[ res ]]$ can be an empty heap $[[ emp ]]$, a boolean
condition $[[ term ]]$, the separating conjunction $[[ res1 * res2 ]]$, an
existential type $[[ exists y : base_type . res ]]$, and the disjunction $[[ if
term then res1 else res2 ]]$. We use a conditional rather than a traditional
disjunction to avoid backtracking during typechecking.

Resource predicates have special syntax to handle the division of their
arguments into inputs and outputs. An occurrence of a predicate is written
$[[ a ( ptrt , iargs ) ( oarg )]]$. This is read as the predicate $[[ a ]]$,
applied to a pointer argument $[[ ptrt ]]$ and a list of other input arguments
$[[ iargs ]]$. The output argument $[[ oarg ]]$ is
\colorbox{red!10}{highlighted} and in a second set of parentheses. Every
predicate has exactly one output argument, of type record (with zero or more
fields).
%
A $[[ qpred ]]$ represents the iterated separating conjunction of predicate
instances; it quantifies over integer indices $[[ x ]]$ satisfying a guard $[[
iguard ]]$, and is with input arguments $[[ iargs ]]$ and output $[[ oarg ]]$.
It represents an instance of $[[ a ]]$ beginning at $[[ ptrt ]]$, and repeating
every $[[ step ]]$ bytes, for as long as the $[[ iguard ]]$ is true.


Each resource type has introduction and elimination forms -- e.g.
$[[ res1 * res2 ]]$ has pairing and pattern matching proof terms. The
standard resource types have the expected rules, and predicate types
can be introduced by explicitly folding a predicate definition
$[[ fold res_term : pred ]]$, and unfolded via pattern-matching.


In addition, there are resource operations recording the
resource-manipulation steps inference uses to successfully type a
program.  If we suppress the book-keeping of checking that input
arguments match, calculating indices, and updating output arguments,
most of these operations have simple intuitions.
%
$[[ explode ( res_term ) ]]$ and $[[ implode ( res_term , ty_tag ) ]]$
are operations on structs and their members; the first takes an
$[[ Owned < struct ty_tag > ]]$ and turns it into a
$[[ Owned < cti > ]]$ for each of of its members; the second does the
inverse.  $[[ iterate ( res_term , ty_int ) ]]$ and
$[[ congeal ( res_term , ty_int ) ]]$ function similarly, but for C's
fixed-size arrays, returning a \emph{quantified} $[[ Owned < ct > ]]$
instead.

Morally,
$\cnkw{break}$ has type $[[ qpred ]] [[ -> ]] [[ qpred * pred ]]$: it
extracts a single predicate from a quantified one, and must return the
remainder as well because resource terms are linearly typed;
$\cnkw{glue}$ has type $[[ qpred * pred ]] [[ -> ]] [[ qpred ]]$: it
is the inverse to $\cnkw{break}$; $\cnkw{split}$ has type
$[[ qpred * iguard ]] [[ -> ]] [[ qpred * qpred ]]$: given a
quantified predicate of index-guard $[[ iguard' ]]$, and an
$[[ iguard ]]$, if $[[ iguard -> iguard' ]]$ then it splits the given
quantified predicate into two disjoint parts (one of index-guard
$[[ iguard ]]$ and the other of $[[ iguard' /\ neg iguard ]]$);
$\cnkw{inj}$ has type
$[[ pred * ptrt * step ]] [[ * ]] [[ iargs ]] [[ -> ]] [[ qpred ]]$:
it turns a predicate $[[ a ( ptrt' , iargs' ) ]]$ into a quantified
predicate, with $[[ iguard = ( x = k ) ]]$, where
$[[ k = ( ptrt' - ptrt ) / step ]]$ and
$[[ iargs' ]] = [[ k / x ( iargs ) ]]$. Because our inference
algorithm does not support inferring merging
arrays, there is no inverse to
$\cnkw{split}$ of type $[[ qpred * qpred ]] [[ -> ]] [[ qpred ]]$.

\subsection{Judgements and Example Rules}
\label{subsec:judgm_eg_rules}

The contexts for the rules consist of four parts: (1) $[[ C ]]$ containing the
computational variables from the Core program; (2) $[[ L ]]$ containing purely
logical variables mentioned in specifications; (3) $[[ N ]]$, the constraint
context, containing a list of (non-quantified) SMT constraints; and (4) $[[ R ]]$ a
\emph{linear} context containing the resources available at that point during
type-checking. Assuming a constraint context of only non-quantified constraints
is an acceptable simplification, because the elaboration pass can annotate terms
with fully-instantiated constraints, whose quantifiers were either supplied
by lemmas, annotations or default instantiation.

We focus on the judgements for typing resource terms and memory actions. The
judgement $[[ C ; L ; N ; R |- res_term => res ]]$ should be read as ``under a
context of computational variables $[[ C ]]$, logical variables $[[ L ]]$,
constraints $[[ N ]]$ and resources $[[ R ]]$, the resource term
$[[ res_term ]]$ synthesises resource type $[[ out_res ]]$'' (the highlighting shows the
part of the judgement with an \colorbox{red!10}{output mode}). The judgement
$[[ C ; L ; N ; R |- res_term <= res ]]$ reads similarly, replacing
`synthesises' with `checks against'.

We need both judgements because variables, folding, predicate operations are
naturally typed as synthesising rules, whereas constraints, packing
existentials, and conditional resources require checking.  Furthermore, as we
shall see soon, memory actions require a synthesising judgement (to obtain and
manipulate the output argument of $[[ Owned < ct > ]]$), whereas top-level
values (such as typing spines) require checking judgements.

\begin{figure}[t]
\small
\centering
\begin{minipage}{.45\textwidth}
\vspace{-2\baselineskip}
\cndruleResXXChkXXIfXXTrue{}%
\\[-1\baselineskip]
\cndrule{%
    \cnpremise{ [[ ret eq sigma yp : loc . term /\ exists y : record sym_init : bool sym_value : to_base ( ct ) . ret' ]] }%
    \cnpremise{ [[ ret' eq ( yp |- y dot sym_init - ct -> y dot sym_value ) *o y dot sym_init = false /\ I]] }%
}{%
  [[ C ; L ; N ; cdot |- create ( pval , ct ) Symbol_prefix => ret ]]
}{\ExplIsActionCreate}%
\\[-1\baselineskip]
\cndrule{
    \cnpremise{ [[ C ; L ; N ; R |- res_term => term |- _init - ct -> _t ]] }%
    \cnpremise{ [[ smt ( N =>  term = inj pval0 ) ]] }%
    \cnpremise{ [[ ret eq sigma _ : unit . ( inj pval0 |- true - ct -> inj pval1 ) *o I ]] }%
}{%
    [[ C ; L ; N ; R |- store ( _b , ct , pval0 , pval1 , _mem_order , res_term ) => ret ]]
}{\ExplIsActionStore}
\vspace{-2\baselineskip}
\end{minipage}
\begin{minipage}{.45\textwidth}
\vspace{-2\baselineskip}
\cndrule{%
    \cnpremise{ [[ pred eq a ( ptrt , </ iargi // i /> ) ( oarg ) ]] }%
    \cnpremise{ [[ a eq xp : loc , </ xi : base_typei // i  /> , y : record </ Symbol_identifierj : base_type'j // j /> |-> res inEnv Globals ]] }%
    \cnpremise{ [[ C ; L ; N ; R |- res_term <= [ oarg / y , [ </ iargi / xi // i /> ] , ptrt / xp ] ( res ) ]] }%
}{%
    [[ C ; L ; N ; R |- fold res_term : pred => pred ]]
}{\ResSynPred}%
\\[-1\baselineskip]
\cndrule{%
    \cnpremise{ [[ C ; L ; N ; R |- res_term => term |- init - ct -> inj pval1 ]] }%
    \cnpremise{ [[ smt ( N => ( term = inj pval0 ) /\ ( init = true ) ) ]] }%
    \cnpremise{ [[ ret eq sigma y : to_base ( ct ) . y = inj pval1 /\ ( inj pval0 |- true - ct -> inj pval1 ) *o I ]] }%
}{%
    [[ C ; L ; N ; R |- load ( ct , pval0 , _mem_order , res_term ) => ret ]]
}{\ExplIsActionLoad}%
\\[-1\baselineskip]
\cndrule{
    \cnpremise{ [[ C ; L ; N ; R |- res_term => term |- _init - ct -> _t ]] }%
    \cnpremise{ [[ smt ( N =>  term = inj pval ) ]] }%
}{%
    [[ C ; L ; N ; R |-  kill ( static ct , pval , res_term ) => sigma _ : unit . I ]]
}{\ExplIsActionKillStatic}
\vspace{-2\baselineskip}
\end{minipage}
\end{figure}


Above is one of two rules for checking a conditional resource.
Thanks to the ordered disjunction, the rule is simple: if the SMT
solver can statically prove $[[ term ]]$, then check the
resource term against the $[[ res1 ]]$. The converse (omitted) checks against
$[[ res2 ]]$ if the SMT solver can prove the negation of the condition; if
neither is provable, the rules try to synthesise an under-determined
conditional resource (the only way this is possible is if $[[ res_term ]]$ is a
variable of an SMT-equivalent type).

The rule for folding predicates shown is simplified for presentation (omitting
only the type checking of the all the predicate arguments, and the exclusion of
the $[[ Owned < ct > ]]$ predicate because it cannot be folded). The first line
is a simple lookup based on the predicate name of types of the arguments, and
the ``body'' $[[ res ]]$ of the predicate. The second checks $[[ res_term ]]$
against the $[[ res ]]$ with its arguments (supplied by the fold term)
substituted in.

The above rules for typing memory actions are also simplified for
presentation.  Allocating memory (which takes an alignment $[[ pval ]]$ and a C
type $[[ ct ]]$) synthesises a return type $[[ ret ]]$ representing: a newly
created pointer (referred to in the type by the name $[[ yp ]]$), some omitted
constraints about alignment and representability ($[[ term ]]$), a logical
value ($[[ y ]]$) representing the output argument of a points-to/$[[ Owned< ct
> ]]$ resource (which differs slightly from the implementation in that it
additionally contains the initialisedness status), the resource itself
($[[ Owned <ct> ( yp , ) ( y ) ]]$ is pretty-printed in more familiar $[[ |-> ]]$
notation), and a constraint that the points-to is not initialised.

Loading from a memory location requires a correctly typed resource term,
\emph{and} its output argument's initialisedness status $[[ init ]]$ to be
true. Because the types are linear, it not only returns the pointed-to value,
but also the same permission it consumed.

Storing to a memory location is similar to loading: it requires a points-to permission,
but without any constraints on its initialisedness. The permission it returns
reflects the fact that the pointee is definitely initialised, and that a new
value is pointed to by this location.

De-allocating memory is the converse of allocating memory: a resource term is
required, but not returned.

\subsection{Differences from Implementation}

There are some minor differences between the implementation and the
formalisation. The formalisation has a richer grammar of resources:
this means it can support tagged unions more succinctly and can open
predicates in more cases. The formalisation assumes that iterated
resources output arguments have type array of records, whereas the
implementation uses records of arrays.


% This is important for LaTeX to not overflow rules off the page
\raggedright%

\section{Types and Patterns}

\subsection{Resource Related}
\cndefnsresXXjudge%

\subsection{Return Type Equality}
\cndefnsretXXjudge%

\subsection{Patterns}
\cndefnspatXXjudge%

\section{Explicit System}

\subsection{Pure Expressions}
\cndefnsexplXXpure%

\subsection{Resource Terms}
\cndefnsexplXXres%

\subsection{Spine Judgement}
\cndefnsexplXXspine%

\subsection{Indet.\ seq.\ expressions}
\cndefnsexplXXisXXexpr%

\subsection{Sequenced expressions}
\cndefnsexplXXseqXXexpr%

\subsection{Top-level Expressions}
\cndefnsexplXXtop%

% Elaboration rules are out of date
%\TODO{
\section{Elaboration System}
\cndefnsinfXXres%
\cndefnselabXXisXXexpr%
\cndefnselabXXspine%
\cndefnselabXXseqXXexpr%
\cndefnselabXXtop%
%}

\section{Operational Semantics}
\cndefnssubsXXjudge%
\cndefnspureXXopsemXXdefns%
\cndefnsopsemXXdefns%

\section{Miscellaneous}
\cndefnsproofXXdefns%
\cndefnsspecXXdefns%
\cndefnsheapXXsat

\section{Metvars and Grammar}
\cnmetavars\\[\baselineskip]
\cngrammar%

\end{document}
