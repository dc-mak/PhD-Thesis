grammar

  state , s :: 'State_' ::= {{ com state }}
    | alloct ; heap :: M :: def

  heap {{ tex \mathit{ heap } }} , h , f :: 'Heap_' ::= {{ com heaps }}
    | { pred & opt_def_heap }         ::   :: pointsto
    | { ipred & arr_def_heap }        ::   :: ipred
    | </ heapi // + // i />           :: M :: concat
    | subs ( heap )                   :: M :: subs
    | cdot                            ::   :: empty
    | opt_def_heap dot int            :: M :: def_heap_proj

  opt_res_val_heap , opt_def_heap :: 'Opt_res_val_heap' ::= {{ com optional resource term value }}
    | None                  :: :: None
    | def & heap            :: :: Some
    | arr_def_heap [ term ] :: :: ArrGet

  arr_opt_res_val_heap , arr_def_heap :: 'Arr_Opt_ResTV_Val' ::= {{ com array of optional resource term value }}
    | cdot                                  :: :: Empty
    | arr_def_heap [ term ] := opt_def_heap :: :: Update

  opsem_extra :: 'opsem_extra_' ::= {{ com extra judgements for operational semantics }}
    | forall i lt j . not ( pati = pval ~> subsi )     ::   :: forall_i_lt_j_not_decons {{ com all patterns prior to $[[j]]$ failed to match/deconstruct        }}
    | int notIn dom ( alloct )                  ::   :: fresh_alloc_id           {{ com $ @ [[int]]$ is a fresh allocation id                     }}
    | int inEnv newAlloc ( heap , pval , term ) ::   :: newAlloc                 {{ com set of new addresses for an allocation                           }}
    | heap eq heap'                                    ::   :: heap_abbrev              {{ com heap abbreviations                                               }}

defns
  subs_judge :: 'Subs_' ::=

  defn term |- smt ( qterm ) :: :: SMT_ :: SMT_
  {{ com given allocation history $[[ term ]]$, $[[ qterm ]]$ is SMT-provable }} by

    smt ( cdot => term / allocv < qterm > )
    -------------------------------------- :: Alloc
    term |- smt ( qterm )

  defn pat = pval ~> out_subs :: :: Pat_Value_ :: Pat_Value_
  {{ com computational value deconstruction: $[[ pat ]]$ deconstructs $[[ pval ]]$ to produce substitution $[[out_subs]]$ }} by


    ----------------------------- :: Wild
    _ = pval ~> cdot


    -------------------------------------------- :: Sym
    x = pval ~> pval / x


    --------------------------------------------------- :: Nil
    Nil base_type ( ) = Nil base_type ( ) ~> cdot


    pat1 = pval1 ~> subs1
    pat2 = pval2 ~> subs2
    --------------------------------------------------------------------------------------------------- :: Cons
    Cons ( pat1 , pat2 ) = Cons ( pval1 , pval2 ) ~> [ subs1 , subs2 ]


    indexed </ pati = pvali ~> subsi // i />
    ------------------------------------------------------------------------------------------- :: Tuple
    Tuple ( </ pati // i /> ) = Tuple ( </ pvali // i /> ) ~> [ </ subsi // i /> ]


    indexed </ pati = pvali ~> subsi // i />
    -------------------------------------------------------------------------------------------- :: Array
    Array ( </ pati // i /> ) = Array ( </ pvali // i /> ) ~> [ </ subsi // i /> ]


  defn < h ; res_pat = res_val > ~> < h' ; out_subs > :: :: Pat_Res :: Pat_Res_
  {{ com resource term deconstruction: $[[res_pat]]$ deconstructs $[[res_val]]$ to produce substitution $[[out_subs]]$ }} by

    --------------------------------- :: Emp
    < h ; emp = emp > ~> < h ; cdot >

    ------------------------------------- :: Phi
    < h ; TERM = TERM > ~> < h ; cdot >

    % Not having pats and matching rules for (q)preds makes substitutions
    % and their typing match up more closely.

    ------------------------------------------ :: Var
    < h ; r = res_val > ~> < h ; res_val / r >


    < h ; res_pat1 = res_val1 > ~> < h1 ; subs1 >
    < h1 ; res_pat2 = res_val2 > ~> < h2 ; subs2 >
    ------------------------------------------------------------------------------------------------ :: Pair
    < h ; < res_pat1 , res_pat2 > = < res_val1 , res_val2 > > ~> < h2 ; [ subs1 , subs2 ] >


    < h ; res_pat = res_val > ~> < h' ; subs >
    ----------------------------------------------------------------------------------------------------------- :: Pack
    < h ; pack ( x , res_pat ) = pack ( oarg , res_val ) > ~> < h' ; [ oarg / x , subs ] >


    < h + h' ; res_pat = def > ~> < h'' ; subs >
    ----------------------------------------------------------------------------------------------- :: Fold
    < h + { pred_term ( oarg ) & def & h' } ; fold ( res_pat ) = pred_term > ~> < h'' ; subs >


  defn < h ; </ ret_pati = ret_termi // , // i /> > ~> < h' ; out_subs > :: :: Pat_Ret :: Pat_Ret_
  {{ com return value deconstruction: $ret\_pat_i$ deconstructs $ret\_val_i$ to produce substitution $[[out_subs]]$ }} by


    ------------------------- :: Empty
    < h ; > ~> < h ; cdot >

    % This more general definition only exists for the more general version of
    % "well-typed values pattern-match successfully". You could get rid of it,
    % and make the definitions & proofs simpler.
    pat = pval ~> subs
    < h ; </ ret_pati = ret_termi // i /> > ~> < h' ; psi >
    -------------------------------------------- :: Comp
    < h ; comp pat = pval , </ ret_pati = ret_termi // i /> > ~> < subs ( h' ) ; [ subs , psi ] >


    % This more general definition only exists for the more general version of
    % "well-typed values pattern-match successfully". You could get rid of it,
    % and make the definitions & proofs simpler.
    < h ; </ ret_pati = ret_termi // i /> > ~> < h' ; subs >
    -------------------------------------------- :: Log
    < h ; log y = oarg , </ ret_pati = ret_termi // i /> > ~> < oarg / y ( h' ) ; [ oarg / y , subs ] >


    alloct | < h ; res_term > ||v < h1 ; res_val >
    < h ; res_pat = res_val > ~> < h2 ; subs >
    < h2 ; </ ret_pati = ret_termi // i /> > ~> < h3 ; psi >
    --------------------------------------------- :: Res
    < h ; reso res_pat = res_term , </ ret_pati = ret_termi // i /> > ~> < h3 ; [ subs , psi ] >


  defn term | param_spine :; fon >> < out_subs ; out_ret > :: :: Spine :: Spine_
  {{ com function call spine: given alloction history $[[ term ]]$ and $[[param_spine]]$
      for function of type $[[ fon ]]$, substitution $[[ out_subs ]]$ and result type $[[ out_ret ]]$ }} by

    ------------------------------------------ :: Empty
    alloct | :; ret >> < cdot ; ret >


    alloct | </ xi = spine_elemi // i /> :; pval / x ( fon ) >> < subs ; ret >
    ------------------------------------------------ :: Comp
    alloct | x = pval , </ xi = spine_elemi // i /> :; pi x : base_type . fon >> < [ pval / x , subs ] ; ret >


    alloct | </ xi = spine_elemi // i /> :; oarg / x ( fon ) >> < subs ; ret >
    ------------------------------------------------ :: Log
    alloct | x = oarg , </ xi = spine_elemi // i /> :; forall x : base_type . fon >> < [ oarg / x , subs ] ; ret >


    alloct | </ xi = spine_elemi // i /> :; fon >> < subs ; ret >
    ------------------------------------------------ :: Res
    alloct | x = res_term , </ xi = spine_elemi // i /> :;  res --o fon >> < [ res_term / x , subs ] ; ret >


    alloct |- smt ( term )
    alloct | </ xi = spine_elemi // i /> :; fon >> < subs ; ret >
    --------------------------------------------------------------- :: Phi
    alloct | </ xi = spine_elemi // i /> :;  term -) fon >> < subs ; ret >


defns
  pure_opsem_defns :: '' ::=

  defn term | < pexpr > --> < tpexpr : pure_ret > :: :: PE_TP :: PE_TP_ by

    int eq xor_uf ( int1 , int2 )
    pure_ret eq sigma y : integer . y = xor_uf ( int1 , int2 )  /\ I
    -------------------------------------------------------------------------- :: Ctor_IvXOR
    _ | < ctor_expr ( int1 , int2 ) > --> < int : pure_ret >

    % DEFER (not implemented) other ctor_expr
    % ctor_expr ( </ pvali // , // i /> )

    x eq alloct [ alloc_id ]
    inj ptr' eq array_shift<ct>(inj ptr, int)
    alloct |- smt ( x dot base =< inj ptr' dot addr =< x dot base + x dot len )
    pure_ret eq sigma y : loc . y = inj ptr' /\ I
    --------------------------------------------------------------------------- :: Array_Shift
    alloct | < array_shift < ct > ( ptr , int ) > --> < ptr' : pure_ret >


    x eq alloct [ alloc_id ]
    inj ptr' eq member_shift < tagged tag > ( inj ptr , member )
    alloct |- smt ( x dot base =< inj ptr' dot addr =< x dot base + x dot len )
    pure_ret eq sigma y : loc . y = inj ptr' /\ I
    --------------------------------------------------------------------- :: Member_Shift
    alloct | < member_shift < tagged tag > ( ptr , member ) > --> < ptr' : pure_ret >


    inj bool_value eq inj ptr1 dot addr = inj ptr2 dot addr
    pure_ret eq sigma y : loc . y = ( inj ptr1 dot addr = inj ptr2 dot addr ) /\ I
    --------------------------------------------------------------------------- :: Ptr_Eq
    _ | < ptr1 = ptr2 > --> < bool_value : pure_ret >


    ------------------------------------ :: Not_True
    _ | < not ( True ) > --> < False : sigma y : bool . y = neg inj True /\ I >


    ------------------------------------ :: Not_False
    _ | < not ( False ) > --> < True : sigma y : bool . y = neg inj False /\ I >


    int eq int1 ' arith_binop ' int2
    pure_ret eq sigma y : integer . y = int1 ' arith_binop ' int2 /\ I
    ----------------------------------------------------------------- :: Arith_Binop
    _ | < int1 arith_binop int2 > --> < int : pure_ret >


    inj bool_value eq int1 ' rel_binop ' int2
    pure_ret eq sigma y : bool . y = int1 ' rel_binop ' int2 /\ I
    ------------------------------------------------------------------ :: Rel_Binop
    _ | < int1 rel_binop int2 > --> < bool_value : pure_ret >


    inj bool_value eq inj bool_value1 ' bool_binop ' inj bool_value2
    pure_ret eq sigma y : bool . y = inj bool_value1 ' bool_binop ' inj bool_value2 /\ I
    --------------------------------------------------------------------------- :: Bool_Binop
    _ | < bool_value1 bool_binop bool_value2 > --> < bool_value : pure_ret >


    % DEFER (not implemented) memberof ( tag , member , pval )


    ------------------------------------------------------------------- :: Assert_Undef
    _ | < assert_undef ( True , UB_name ) > --> < Unit : sigma _ : unit . I >


    ---------------------------------------------------- :: Bool_To_Integer_True
    _ | < bool_to_integer ( True ) > --> < 1 : sigma y : integer . y = 1 /\ I >


    ---------------------------------------------------- :: Bool_To_Integer_False
    _ | < bool_to_integer ( False ) > --> < 0 : sigma y : integer . y = 0 /\ I >

    % DEFER conv_int ( ct , pval )

    abbrev1 eq max ct - min ct + 1
    abbrev2 eq inj pval REM abbrev1
    int' eq if abbrev2 =< max ct then abbrev2 else abbrev2 - abbrev1
    pure_ret eq sigma y : integer . y = int' /\ I
    ------------------------------------------------------------------------------- :: WrapI
    _ | < wrapI ( ct , int ) > --> < int' : pure_ret >


    name : pure_fun eq </ xi // i /> |-> tpexpr inEnv Globals
    alloct | </ xi = pvali // i /> :; pure_fun >> < subs ; pure_ret >
    ----------------------------------------------------------------------------- :: Call
    alloct | < name ( </ pvali // i /> ) > --> < subs ( tpexpr ) : pure_ret >


  defn term | < tpexpr > --> < tpexpr' > :: :: TP_TP :: TP_TP_ by

    patj = pval ~> subsj
    forall i lt j . not ( pati = pval ~> subsi )
    ------------------------------------------------------------------------------------------------------- :: Case
    _ | < case pval of </ | pati => tpexpri // i /> end > --> < subsj ( tpexprj ) >


    pat = pval ~> subs
    ------------------------------------------------------------ :: Let_Sub
    _ | < let pat = pval in tpexpr > --> < subs ( tpexpr ) >


    alloct | < pexpr > --> < pval : pure_ret >
    ------------------------------------------- :: Let_Let
    alloct | < let pat = pexpr in tpexpr > --> < let pat : pure_ret = pval in tpexpr >


    alloct | < pexpr > --> < tpexpr1 : pure_ret >
    ---------------------------------------------------------------------- :: Let_LetT
    alloct | < let pat = pexpr in tpexpr2 > --> < let pat : pure_ret = tpexpr1 in tpexpr2 >


    pat = pval ~> subs
    ------------------------------------------- :: LetT_Sub
    _ | < let pat : pure_ret = pval in tpexpr > --> < subs ( tpexpr ) >


    alloct | < tpexpr1 > --> < tpexpr1' >
    ------------------------------------------- :: LetT_LetT
    alloct | < let pat : pure_ret = tpexpr1 in tpexpr2 > --> < let pat : pure_ret = tpexpr1' in tpexpr2 >


    ------------------------------------------------------------------------------- :: If_True
    _ | < if True then tpexpr1 else tpexpr2 > --> < tpexpr1 >


    -------------------------------------------------------------------------------- :: If_False
    _ | < if False then tpexpr1 else tpexpr2 > --> < tpexpr2 >


defns
  opsem_defns :: '' ::=

  defn term | < h ; pred_ops > ||v < h' ; res_val > :: :: PredOps_ResV :: PredOps_ResV_
  {{ com big-step resource (q)points-to operation reduction: given alloction history $[[ term ]]$, $[[ < ]] [[ h ]] [[ ; ]] [[ pred_ops ]] [[ > ]]$ reduces to $[[ < ]] [[ h' ]] [[ ; ]] [[ res_val ]] [[ > ]]$ }} by


   alloct | < h ; res_term > ||v < h' + { pred_term ( oarg ) & None } ; pred_term >
   pred_term eq Owned < init , array n ct > ( ptrt )
   ipred_term eq each (integer x; 0 =< x =< n - 1) { Owned < init , ct > ( array_shift < ct > ( ptrt , x ) ) }
   -------------------------------------------------------------------------------------------- :: Iterate
   alloct | < h ; iterate ( res_term , n ) > ||v < h' + { ipred_term ( oarg ) & cdot } ; ipred_term >


   alloct | < h ; res_term > ||v < h' + { ipred_term ( oarg ) & cdot } ; ipred_term >
   ipred_term eq each (integer x; iguard) { Owned < init , ct > ( array_shift < ct > ( ptrt , x ) ) }
   alloct |- smt ( forall x. iguard <-> ( 0 =< x =< n - 1 ) )
   x eq alloct [ ptrt dot alloc_id ]
   alloct |- smt ( x dot base =< ptrt dot addr /\ array_shift < ct > ( ptrt , n ) dot addr  =< x dot base + x dot len )
   pred_term eq Owned < init , array n ct > ( ptrt )
   ---------------------------------------------------------------------------- :: Congeal
   alloct | < h ; congeal ( res_term , n ) > ||v < h' + { pred_term ( oarg ) & None } ; pred_term >


   alloct | < h ; res_term > ||v < h' + { pred & None } ; pred_term >
   pred eq Owned < init , struct tag > ( ptrt ) ( oarg )
   tagged tag & </ memberi : cti // i /> inEnv Globals
   indexed </ ptrti eq member_shift < struct tag > ( ptrt , memberi ) // i />
   indexed </ pred_termi eq Owned < init , cti > ( ptrti ) // i />
   -------------------------------------------------------------------------- :: Explode
   alloct | < h ; explode ( res_term ) > ||v < h' + </ { pred_termi ( oarg dot memberi ) & None } // i /> ; < </ pred_termi // i /> > >


   alloct | < h ;  res_term > ||v < h' + </ { pred_termi ( oargi ) & None } // i /> ; < </ pred_termi // i /> > >
   tagged tag & </ memberi : cti // i /> inEnv Globals
   indexed pred_termi eq Owned < init , cti > ( ptrti )
   term eq ptrt0 dot addr - offsetof tag member0
   alloct |- smt ( /\\ ( </ term = ptrti dot addr - offsetof tag memberi /\ ptrt0 dot alloc_id = ptrti dot alloc_id // i /> ) )
   x eq alloct [ ptrt0 dot alloc_id ]
   alloct |- smt ( x dot base =< ptrt dot addr /\ ptrt dot addr + sizeof struct tag =< x dot base + x dot len )
   pred_term eq Owned < init , struct tag > ( ( @ ptrt0 dot alloc_id , term ) )
   ---------------------------------------------------------------------------------------- :: Implode
   alloct | < h ; implode ( res_term , tag ) > ||v < h' + { pred_term ( { </ memberi = oargi // i /> } ) & None } ; pred_term >


   alloct | < h ; res_term > ||v < h' + { ipred_term ( oarg ) & arr_def_heap } ; ipred_term >
   ipred_term eq each (integer x; iguard) { a ( array_shift < ct > ( ptrt , x ) , </ iargi // i /> ) }
   alloct |- smt ( term / x ( iguard ) )
   ptrt' eq  array_shift <ct> ( ptrt , term )
   ipred_term' eq each (integer x; iguard /\ ( x != term ) ) { a ( array_shift < ct > ( ptrt , x ) , </ iargi // i /> ) }
   pred_term eq a ( ptrt' , term / x ( </ iarg // i /> ) )
   h'' eq h' + { ipred_term' ( oarg ) & arr_def_heap } + { pred_term ( oarg [ term ] ) & arr_def_heap [ term ] }
   ------------------------------------------------------------------------------------------------------------- :: Break
   alloct | < h ; break ( res_term , term ) > ||v < h'' ;  < ipred_term' , pred_term > >


   alloct | < h ; res_term > ||v < h'' ;  < ipred_term , pred_term > >
   h'' eq h' + { ipred_term ( oarg1 ) & arr_def_heap } + { pred_term ( oarg2 ) & opt_def_heap }
   ipred_term eq each (integer x; iguard) { a ( array_shift < ct > ( ptrt1 , x ) , </ iarg1i // i /> ) }
   pred_term eq a ( ptrt2  , </ iarg2i // i /> )
   term eq ( ptrt2 dot addr - ptrt1 dot addr ) / sizeof ct
   alloct |- smt ( ptrt1 = array_shift < ct > ( ptrt2 , term ) )
   alloct |- smt ( /\\ ( </ term / x ( iarg1i ) = iarg2i // i /> ) )
   x eq alloct [ ptrt1 dot alloc_id ]
   alloct |- smt ( x dot base =< ptrt1 dot addr /\ ptrt2 dot addr + sizeof ct =< x dot base + x dot len )
   ipred_term' eq each (integer x; iguard \/ x = term) { a ( array_shift < ct > ( ptrt1 , x ) , </ iarg1i // i /> ) }
   ---------------------------------------------------------------------------------------------------------------------------- :: Glue
   alloct | < h ; glue ( res_term ) > ||v < h' + { ipred_term' ( oarg1 [ term ] := oarg2 ) & arr_def_heap [ term ] := opt_def_heap } ; ipred_term' >


   alloct | < h ; res_term > ||v < h' + { pred_term ( oarg ) & opt_def_heap } ; pred_term >
   pred_term eq a ( ptrt2 , </ iarg2i // i /> )
   term eq ( ptrt1 dot addr - ptrt2 dot addr ) / sizeof ct
   alloct |- smt ( ptrt1 = array_shift < ct > ( ptrt2 , term ) ) 
   alloct |- smt ( /\\ ( </ term / x ( iarg1i ) = iarg2i // i /> ) )
   x eq alloct [ ptrt1 dot alloc_id ]
   alloct |- smt ( x dot base =< ptrt1 dot addr /\ ptrt2 dot addr + sizeof ct =< x dot base + x dot len )
   ipred_term eq each (integer x; x = term) { a ( array_shift<ct>(ptrt1, x) , </ iarg1i // i /> ) }
   cdot ; cdot |- oarg => base_type
   ----------------------------------------------------------------- :: Inj
   alloct | < h ; inj ( res_term , ptrt1 , ct , x . </ iarg1 // i /> ) > ||v < h' + { ipred_term ( const oarg ) & cdot [ term ] := opt_def_heap } ; ipred_term >


   alloct | < h ; res_term > ||v < h' + { ipred_term ( oarg ) & arr_def_heap } ; ipred_term >
   ipred_term eq each (integer x; iguard') { a ( array_shift <ct> ( ptrt , x ) , </ iargi // i /> ) }
   alloct |- smt ( forall x . iguard -> iguard' )
   ipred_term1 eq each (integer x; iguard) { a ( array_shift < ct > ( ptrt , x ) , </ iargi // i /> ) }
   ipred_term2 eq each (integer x; iguard' /\ neg iguard) { a ( array_shift < ct > ( ptrt , x ) , </ iargi // i /> ) }
   ---------------------------------------------------------------------------------------------------------------------------------------------- :: Chop
   alloct | < h ; chop ( res_term , iguard ) > ||v < h' + { ipred_term1 ( oarg ) & arr_def_heap } + { ipred_term2 ( oarg ) & arr_def_heap } ; < ipred_term1 , ipred_term2 > >


  defn footprint_of res_val in h ~> h1 REM h2 :: :: Footprint :: Footprint_
  {{ com footprint of $[[ res_val ]]$ in heap $[[ h ]]$ is $[[ h1 ]]$ with $[[ h2 ]]$ remainder/frame }} by

    ------------------------------------------- :: Emp
    footprint_of emp in h ~> cdot REM h

    -------------------------------------------- :: Term
    footprint_of TERM in h ~> cdot REM h

    --------------------------------------------------------------------------------------------- :: Pred
    footprint_of pred_term in h + { pred_term ( oarg ) & opt_def_heap } ~> { pred_term ( oarg ) & opt_def_heap } REM h

    ------------------------------------------------------------------------------------------- :: IPred
    footprint_of ipred_term in h + { ipred_term ( oarg ) & arr_def_heap } ~> { ipred_term ( oarg ) & arr_def_heap } REM h

    footprint_of res_val1 in h ~> h1 REM h'
    footprint_of res_val2 in h' ~> h2 REM h''
    ------------------------------------------------------------ :: SepPair
    footprint_of < res_val1 , res_val2 > in h ~> h1 + h2 REM h''

    footprint_of res_val in h ~> h' REM h''
    ----------------------------------------------------------- :: Pack
    footprint_of pack ( oarg , res_val ) in h ~> h' REM h''


  defn term | < h ; res_term > ||v < h' ; res_val > :: :: ResT_ResV :: ResT_ResV_
  {{ com big-step resource term reduction: given alloction history $[[ term ]]$, $[[ < ]] [[ h ]] [[ ; ]] [[ res_term ]] [[ > ]]$ reduces to $[[ < ]] [[ h' ]] [[ ; ]] [[ res_val ]] [[ > ]]$ }} by

    --------------------------------------------- :: Val
    alloct | < h ; res_val > ||v < h ; res_val >


    alloct | < h  ; res_term1 > ||v < h1 ; res_val1 >
    alloct | < h1 ; res_term2 > ||v < h2 ; res_val2 >
    -------------------------------------------------------------------------------- :: SepPair
    alloct | < h ; < res_term1 , res_term2 > > ||v < h2 ; < res_val1 , res_val2 > >


    alloct | < h ; pred_ops >  ||v < h' ; res_val >
    ------------------------------------------- :: PredOps
    alloct | < h ; pred_ops > ||v < h' ; res_val >


    alloct | < h ; res_term > ||v < h1 ; def >
    footprint_of def in h1 ~> h2 REM h3
    -------------------------------------------------------------------------------------------------- :: Fold
    alloct | < h ; fold res_term : pred_term ( oarg ) > ||v < h3 + { pred_term ( oarg ) & def & h2 }  ; pred_term >


    alloct | < h ; res_term > ||v < h' ; res_val >
    ---------------------------------------------------------------------------------- :: Pack
    alloct | < h ; pack ( oarg , res_term ) > ||v < h' ; pack ( oarg , res_val ) >


  defn < s ; action  > --> < s' ; texpr : ret > :: :: Action_TExpr :: Action_TExpr_ by


    addr inEnv newAlloc ( h , pval , sizeof ct )
    alloc_id notIn dom ( alloct )
    inj ptr eq ( @ alloc_id , addr )
    pt eq inj ptr |- Uninit - ct -> default to_base ( ct )
    ret eq sigma yp : loc . term /\ exists x : to_base ( ct ) . ( yp |- Uninit - ct -> x ) *o Alloc ( yp ) ( sizeof ct ) *o I
    term eq representable ( ct * , inj ptr ) /\ alignedI ( int , inj ptr ) /\ allocv [ alloc_id ] = ( addr , sizeof ct )
    alloct |- smt ( term )
    h' eq h + { pt & None } + { Alloc ( inj ptr ) ( sizeof ct ) & None }
    ------------------------------------------------------------------------- :: Create
    < alloct ; h ; emp | create < ct > ( int ) > --> < alloct [ alloc_id ] := ( addr , sizeof ct ) ;  h' ; < ptr , default to_base ( ct ), Owned < Uninit , ct > ( inj ptr ) , Alloc ( inj ptr ) > : ret >


    alloct | < h ; res_term > ||v < h' + { pt & None } ; Owned < Init , ct > ( ptrt ) >
    pt eq ptrt |- Init - ct -> inj pval
    alloct |- smt ( ptrt = inj ptr )
    ret eq sigma y : to_base ( ct ) . y = inj pval /\ ( inj ptr |- Init - ct -> inj pval ) *o I
    -------------------------------------------------------------------------------------------------------------------------------------- :: Load
    < alloct ; h ; res_term | load < ct > ( ptr ) > --> < alloct ; h' + { pt & None } ; < pval , Owned < Init , ct > ( inj ptr ) > : ret >


    alloct | < h ; res_term > ||v < h' + { pt & None } ; Owned < _init , ct > (  ptrt ) >
    pt eq ptrt |- _init - ct -> _t
    alloct |- smt ( ptrt = inj ptr )
    alloct |- smt ( representable ( ct , inj pval ) )
    pt' eq inj ptr |- Init - ct -> inj pval
    ret eq sigma _ : unit . ( inj ptr |- Init - ct -> inj pval ) *o I
    ----------------------------------------------------------------------------------------- :: Store
    < alloct ; h ; res_term | store < ct > ( ptr , pval ) > --> < alloct ; h' + { pt' & None } ; < Unit , Owned < Init , ct > ( inj ptr ) > : ret >


    alloct | < h ; res_term > ||v < h' + { pred_term1 ( _t ) & None } + { pred_term2 ( term ) & None } ; < pred_term1 , pred_term2 > >
    pred_term1 eq Owned < _init , ct > ( ptrt )
    pred_term2 eq Alloc ( ptrt' )
    alloct |- smt ( ptrt = ptrt' = inj ptr /\ sizeof ct = term )
    ret eq sigma _ : unit . I
    ----------------------------------------------------------------------------------- :: Kill_Static
    < alloct ; h ; res_term | kill < ct > ( ptr ) > --> < alloct ; h' ; < Unit > : ret >

  defn term | < h ; memop  > --> < h' ; texpr : ret > :: :: Memop_TExpr :: Memop_TExpr_ by

    alloct | < h ; res_term > ||v < h1 + h2 ;  < pred_term1 , pred_term2 > >
    h2 eq </ { pred_termi ( termi ) & None } // i />
    indexed </ pred_termi eq Alloc ( ptrti ) // i />
    alloct |- smt ( alloc_id1 = alloc_id2 = ptrt1 dot alloc_id = ptrt2 dot alloc_id2 )
    alloct |- smt ( ptrt1 dot base =< addr1 =< ptrt1 dot base + term1 )
    alloct |- smt ( ptrt2 dot base =< addr2 =< ptrt2 dot base + term2 )
    inj bool_value eq addr1 ' rel_binop ' addr2
    ret eq sigma y : bool . y = ( addr1 ' rel_binop ' addr2 ) /\ pred_term1 ( term1 ) * pred_term2 ( term2 ) *o I
    -------------------------------------------------------------------------------------------------------------- :: Rel_Binop
    alloct | < h ; res_term | ( @ alloc_id1 , addr1 ) rel_binop ( @ alloc_id2 , addr2 ) > --> < h1 + h2 ; < bool_value , < pred_term1 , pred_term2 > > : ret >


    alloct | < h ; res_term > ||v < h1 + { pred_term ( term ) & None } ;  pred_term >
    pred_term eq Alloc ( ptrt )
    alloct |- smt ( alloc_id1 = alloc_id2 = ptrt dot alloc_id )
    alloct |- smt ( ptrt dot base =< ( addr1 , addr2 ) =< ptrt dot base + term )
    int eq ( addr1 - addr2 ) / sizeof ct
    ret eq sigma y : integer . y = ( addr1 - addr2 ) / sizeof ct /\ res *o I
    -------------------------------------------------------------------------------------------------------------- :: PtrDiff_Arr
    alloct | < h ; res_term | ( @ alloc_id1 , addr1 ) - array n ct - ( @ alloc_id2 , addr2 ) > --> < h1 + { pred_term ( term ) & None } ; < int , pred_term > : ret >


    alloct | < h ; res_term > ||v < h1 + { pred_term ( term ) & None } ;  pred_term >
    pred_term eq Alloc ( ptrt )
    alloct |- smt ( alloc_id1 = alloc_id2 = ptrt dot alloc_id )
    alloct |- smt ( ptrt dot base =< ( addr1 , addr2 ) =< ptrt dot base + term )
    int eq ( addr1 - addr2 ) / sizeof ct
    ret eq sigma y : integer . y = ( addr1 - addr2 ) / sizeof ct /\ res *o I
    -------------------------------------------------------------------------------------------------------------- :: PtrDiff
    alloct | < h ; res_term | ( @ alloc_id1 , addr1 ) - ct - ( @ alloc_id2 , addr2 ) > --> < h1 + { pred_term ( term ) & None } ; < int , pred_term > : ret >


    alloct | < h ; res_term > ||v < h' + { pred_term ( _t ) & None } ; pred_term >
    pred_term eq Alloc ( ptrt )
    alloct |- smt ( alloc_id = ptrt dot alloc_id /\ representable ( ct2 , addr ) )
    ret eq sigma y : integer . y = addr /\ pred_term ( _t ) *o I
    ---------------------------------------------------------------------------------- :: IntFromPtr
    _ | < h ; res_term | intFromPtr < ct1 , ct2 > ( ( @ alloc_id , addr ) ) > --> < h' + { pred_term ( _t ) & None } ; < addr , pred_term > : ret >


    alloct | < h ; res_term > ||v < h' + { pred_term ( oarg ) & None } ; pred_term >
    pred_term eq Owned < _init , ct > ( ptrt )
    x eq alloct [ ptrt dot alloc_id ]
    alloct |- smt ( x dot base =< addr =< x dot base + x dot len )
    inj ptr eq ( @ ptrt dot alloc_id , addr )
    ret eq sigma y : loc . y = ( @ ptrt dot alloc_id , addr ) /\ pred_term ( oarg ) *o I
    ---------------------------------------------------------------------------------------- :: PtrFromInt
    alloct | < h ; res_term | ptrFromInt < ct1 , ct2 > ( addr ) > --> < h' + { pred_term ( oarg ) & None } ; < ptr , pred_term > : ret >


    inj bool_value eq aligned ( ct , inj ptr )
    ret eq sigma y : bool . y = aligned ( ct , inj ptr ) /\ I
    -------------------------------------------------------- :: PtrValidForDeref
    _ | < h ; emp | ptrValidForDeref < ct > ( ptr ) > --> < h ; < bool_value > : ret >


    inj bool_value eq aligned ( ct , inj ptr )
    ret eq sigma y : bool . y = aligned ( ct , inj ptr ) /\ I
    ------------------------------------------------------------------ :: PtrWellAligned
    _ | < h ; emp | ptrWellAligned < ct > ( ptr ) > --> < h ; < bool_value > : ret >


    alloct | < h ; res_term > ||v < h' + { pred_term ( term ) & None } ; pred_term >
    pred_term eq Alloc ( ptrt )
    inj ptr' eq array_shift < ct > ( inj ptr , int )
    alloct |- smt ( alloc_id = ptrt dot alloc_id /\ inj ptr' dot addr =< ptrt dot base + term )
    ret eq sigma y : loc . y = inj ptr' /\ pred_term ( term ) *o I
    --------------------------------------------------------------------------------------------- :: PtrArrayShift
    alloct | < h ; res_term | ptrArrayShift < ct > ( ptr , int ) > --> < h ; < ptr' , pred_term > : ret >


  defn < s ; expr > --> < s' ; texpr : ret > :: :: Expr_T :: Expr_T_ by


    alloct | < h ; memop > --> < h' ; texpr : ret >
    --------------------------------------------------------- :: Memop
    < alloct ; h ; memop > --> < alloct ; h' ; texpr : ret >


    < s ; action > --> < s' ; texpr : ret >
    ---------------------------------------- :: Action
    < s ; memop > --> < s' ; texpr : ret >


    id : fon eq </ xi // i /> |-> texpr inEnv Globals
    alloct | </ xi = spine_elemi // i /> :; fon >> < subs ; ret >
    ------------------------------------------------------------- :: CCall
    < alloct ; h ; ccall ( ct , id , </ spine_elemi // i /> ) > --> < alloct ; h ; subs ( texpr ) : ret >


    name : fon eq </ xi // i /> |-> texpr inEnv Globals
    alloct | </ xi = spine_elemi // i /> :; fon >> < subs ; ret >
    --------------------------------------------------------- :: Proc
    < alloct ; h ; pcall ( name , </ spine_elemi // i /> ) > --> < alloct ; h ; subs ( texpr ) : ret >


  defn < s ; texpr > --> < s' ; texpr' > :: :: T_T :: T_T_ by


    pat = pval ~> subs
    --------------------------------------- :: LetP_Sub
    < s ; let pat = pval in texpr > --> < s ; subs ( texpr ) >


    alloct | < pexpr > --> < pval : pure_ret >
    ------------------------------------------- :: LetP_LetP
    < alloct ; h ; let pat = pexpr in texpr > --> < alloct ; h ; let pat : pure_ret = pval in texpr >


    alloct | < pexpr > --> < tpexpr : pure_ret >
    ------------------------------------------- :: LetP_LetTP
    < alloct ; h ; let pat = pexpr in texpr > --> < alloct ; h ; let pat : pure_ret = tpexpr in texpr >


    alloct | < tpexpr > --> < tpexpr' >
    ------------------------------------------- :: LetTP_LetTP
    < alloct ; h ; let pat : pure_ret = tpexpr in texpr > --> < alloct ; h ; let pat : pure_ret = tpexpr' in texpr >



    < s ; expr  > --> < s' ; texpr : ret >
    ----------------------------------------------------------------- :: LetS_LetS
    < s ; let ret_pat = expr in texpr' > --> < s' ; let ret_pat : ret = texpr in texpr' >


    < h ; </ ret_pati = ret_termi // i /> > ~> < h' ; subs >
    --------------------------------------------- :: LetT_Sub
    < alloct ; h ; let </ ret_pati // i /> : ret = < </ ret_termi // i /> > in texpr > --> < alloct ; h' ; subs ( texpr ) >


    < s ; expr > --> < s' ; texpr1 : ret >
    -------------------------------------------------------- :: Let_LetT
    < s ; let ret_pat = expr in texpr2 > --> < s' ; let ret_pat : ret = texpr1 in texpr2 >


    < s ; texpr1 > --> < s' ; texpr1' >
    -------------------------------------------- :: LetT_LetT
    < s ; let ret_pat : ret = texpr1 in texpr2 > --> < s' ; let ret_pat : ret = texpr1' in texpr2 >


    ---------------------------------------------------------- :: If_True
    < s ; if True then texpr1 else texpr2 > --> < s ; texpr1 >


    ----------------------------------------------------------- :: If_False
    < s ; if False then texpr1 else texpr2 > --> < s ; texpr2 >


    patj = pval ~> subsj
    forall i lt j . not ( pati = pval ~> subsi )
    ------------------------------------------------------------ :: Case
    < s ; case pval of </ | pati => texpri // i /> end > --> < s ; subsj ( texprj ) >


    id : fon eq </ xi // i /> |-> texpr inEnv Globals
    alloct | </ xi = pvali // i /> :; fon >> < subs ; false /\ I >
    ------------------------------------------------------------ :: Run
    < alloct ; h ; run id </ pvali // i /> > --> < alloct ; h ; subs ( texpr ) >