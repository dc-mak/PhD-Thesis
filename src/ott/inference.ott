% These rules infer indices, which the implementation currently does not (but did at one point)

grammar

  res_diff {{ tex \outpol{\mathit{res\_diff} } }} :: 'Res_diff_' ::= {{ com resource difference }}
    | None                                                                                        :: :: None
      {{ com not possible to take a difference }} {{ tex \outpol{[[None]]} }}
    | out_res_term and out_oarg                                                                   :: :: Clean
      {{ com request is satisfied exactly by $[[out_res_term]]$ and the output argument is $[[out_oarg]]$ }}
    | out_oarg and out_res_req                                                                    :: :: More
      {{ com request is satisfied partially with output argument $[[out_oarg]]$ with remaining $[[out_res_req]]$ }}
    | bind out_res_pat1 : out_res1 = out_res_term1 for out_x1 & out_oarg and out_x2 : out_rem     :: :: Rem
      {{ com deconstruct $[[out_res_term1]] [[:]] [[out_res1]]$ using $[[out_res_pat1]]$ to satisfy request exactly (using $[[out_x1]]$ and $[[out_oarg]]$) with remainder $[[out_x2]] [[:]] [[out_rem]]$ }}


  res_bind :: 'res_bind_' ::= {{ com resource bindings }}
    | cdot                      :: :: nil    {{ com empty resource binding                                       }}
    | res_pat : res = res_term  :: :: cons   {{ com match $[[res_term]] [[:]] [[res]]$ against $[[res_pat]]$ }}
    | </ res_bindi // , // i /> :: :: concat {{ com concatenate resource bindings                                }}


  % OUT_HACK|res_bind
  out_res_bind {{ tex \outpol{ res\_bind } }}   :: 'Out_hack_' ::=  {{ com Ott-hack, ignore }}
    | res_bind :: :: res_bind {{ tex \outpol{ [[res_bind]] } }}

  opt_term :: 'Opt_term_' ::= {{ com optional SMT term }}
    | None :: :: None
    | term :: :: Some

  % OUT_HACK|opt_term
  out_opt_term {{ tex \outpol{ opt\_term } }}   :: 'Out_hack_' ::=  {{ com Ott-hack, ignore }}
    | opt_term :: :: opt_term {{ tex \outpol{ [[opt_term]] } }}

  cmp :: 'Cmp_' ::= {{ com result of binary comparison }}
    | Lt :: :: Lt {{ com less-than    }}
    | Eq :: :: Eq {{ com equals       }}
    | Gt :: :: Gt {{ com greater-than }}

  opt_cmp :: 'Opt_cmp_' ::= {{ com optional result of binary comparison }}
    | None :: :: None
    | cmp  :: :: Some

  % OUT_HACK|opt_cmp
  out_opt_cmp {{ tex \outpol{ opt\_cmp } }}   :: 'Out_hack_' ::=  {{ com Ott-hack, ignore }}
    | opt_cmp :: :: opt_cmp {{ tex \outpol{ [[opt_cmp]] } }}

  opt_cmp_term :: 'Opt_cmp_term_' ::= {{ com optional result of binary comparison and SMT term }}
    | None       :: :: None
    | cmp , term :: :: Some

  % OUT_HACK|opt_cmp_term
  out_opt_cmp_term {{ tex \outpol{ opt\_cmp\_term } }}   :: 'Out_hack_' ::=  {{ com Ott-hack, ignore }}
    | opt_cmp_term :: :: opt_cmp_term {{ tex \outpol{ [[opt_cmp_term]] } }}

defns
  inf_res :: '' ::=

  defn N |- pred_term in? ipred_term ~> out_opt_term :: :: PinI :: PinI_
  {{ com given constraints $[[N]]$, $[[pred_term]]$ is potentially a part of $[[ipred_term]]$ at index $[[out_opt_term]]$ }} by

    a1 != a2
    ----------------------------------------------------------------------- :: Name_Neq
    N |- a1 ( _iargs ) in? each (integer _; _t) { a2 ( _iargs ) } ~> None


    term def= ( ptrt2 - ptrt1 ) / sizeof ct
    term1 def= term / x ( iguard )
    term2 def= /\\ ( </ iarg1i = [ term / x ] ( iarg2i ) // i /> )
    smt ( N => neg ( term1 /\ term2 ) )
    -------------------------------------------------------------------------- :: IG_Or_IArg_Neq
    N |- a ( ptrt2 , </ iarg1i // i /> ) in? each (integer x; iguard) { a ( array_shift < ct > ( ptrt1 , x ) , </ iarg2i // i /> ) }  ~> None


    term def= ( ptrt2 - ptrt1 ) / sizeof ct
    term1 def= term / x ( iguard )
    term2 def= /\\ ( </  iarg1i = [ term / x ] ( iarg2i ) // i /> )
    smt ( N => term1 /\ term2 )
    -------------------------------------------------------------------------- :: Comp
    N |- a ( ptrt2 , </ iarg1i // i /> ) in? each (integer x; iguard) { a ( array_shift < ct > ( ptrt1 , x ) , </ iarg2i // i /> ) } ~> term


  defn N |- r : norm_res -? res_req ~> res_diff :: :: Res_Diff :: Res_Diff_
  {{ com the difference between $[[r]] [[:]] [[norm_res]]$ and requested $[[res_req]]$ is $[[res_diff]]$ }} by

    ---------------------------------------------------------- :: If_None
    N |- _ : if term then res1 else res2 -? res_req ~> None


    N |- pred_term def= pred_term' ~> false
    ----------------------------------------------- :: PP_None
    N |- _ : pred_term' ( _ ) -? pred_term  ~> None


    N |- pred_term def= pred_term' ~> true
    -------------------------------------------------------- :: PP_Exact
    N |- r : pred_term' ( oarg ) -? pred_term ~> r and oarg


    N |- pred_term in? ipred_term ~> None
    ------------------------------------------------ :: PI_None
    N |- _ : ipred_term ( _t ) -? pred_term ~> None


    N |- pred_term in? ipred_term ~> term
    ipred_term def= each (integer x; iguard) { a ( array_shift < ct > ( ptrt1 , x ) , </ iargi // i /> ) }
    rem def= each (integer x; iguard /\ (x != term)) { a ( array_shift < ct > ( ptrt1 , x ) , </ iargi // i /> ) } ( oarg )
    -------------------------------------------------------------------------- :: PI_Rem
    N |- r : ipred_term ( oarg ) -? pred_term ~> bind < r1 , r2 > : rem * pred_term ( oarg [ term ] ) = break ( r , term ) for r2 & oarg [ term ]  and r1 : rem


    N |- pred_term in? ipred_term ~> None
    ------------------------------------------------ :: IP_None
    N |- _ : pred_term ( _t ) -? ipred_term ~> None


    N |- pred_term in? ipred_term ~> term
    ipred_term def= each (integer x; iguard) { a ( array_shift < ct > ( ptrt1 , x ) , </ iargi // i /> ) }
    smt ( N => exists x . iguard /\ ( x != term ) )
    ------------------------------------------------------------------------------------------------ :: IP_More
    N |- r : pred_term ( oarg ) -? ipred_term ~> oarg and each (integer x; iguard /\ ( x != term ) ) { a ( array_shift < ct > ( ptrt1 , x ) , </ iargi // i /> ) }


    N |- pred_term in? ipred_term ~> term
    ipred_term def= each (integer x; iguard) { a ( array_shift < ct > ( ptrt1 , x ) , </ iargi // i /> ) }
    smt ( N => forall x . neg ( iguard /\ ( x != term ) ) )
    C ; L |- oarg => base_type
    ------------------------------------------------------------------------------------------------ :: IP_Last
    N |- r : pred_term ( oarg ) -? ipred_term ~> inj ( r , ptrt1 , ct , x . iargs ) and const oarg


    N |- ipred_term [=? ipred_term' ~> None
    -------------------------------------------------- :: II_None
    N |- _ : ipred_term' ( _t ) -? ipred_term ~> None


    N |- ipred_term' [=? ipred_term ~> Eq
    ------------------------------------------------------------------- :: II_Eq
    N |- r : ipred_term ( oarg ) -? ipred_term'  ~> r and oarg


    N |- ipred_term' [=? ipred_term ~> Lt
    % ipred_term' < ipred_term
    ipred_term def= each (integer x; iguard) { a ( array_shift<ct>(ptrt, x) , </ iargi // i /> ) }
    ipred_term' def= each (integer x; iguard') { a ( array_shift<ct>(ptrt,x) , </ iargi // i />  ) }
    rem def= each (integer x; iguard  /\ neg iguard') { a ( array_shift<ct>(ptrt,x) , </ iargi // i /> ) } ( oarg )
    ---------------------------------------------------------------------------------------- :: II_Lt
    N |- r : ipred_term ( oarg ) -? ipred_term' ~> bind < r1 , r2 > : res = chop ( r , iguard' ) for r1 & oarg [ k ] and r2 : rem


    % This would require being able to merge arrays, which the implementation does not support
    % N |- ipred_term' [=? ipred_term ~> Gt
    % % ipred_term' > ipred_term
    % ipred_term  def= { x ; iguard  . a ( ptrt + step , iargs ) }
    % ipred_term' def= { x ; iguard' . a ( ptrt + step , iargs ) }
    % ------------------------------------------------------------------ :: II_Gt
    % N |- r : ipred_term & oarg -? ipred_term'  ~> oarg and { x ; iguard' /\ neg iguard . a ( ptrt + step , iargs ) }


  defn N |- r1 : norm_res +? res_term2 : res_req & oarg2 ~> out_res_term and out_oarg3 :: :: Res_Comb :: Res_Comb_
  {{ com combining $[[r1]] [[:]] [[norm_res]]$, $[[res_term2]] [[:]] [[res_req]] \& [[oarg2]]$, results in $[[out_res_term]]$ $[[out_oarg3]]$ }} by

    N |- pred_term in? ipred_term ~> term
    C ; L |- oarg1 => base_type
    C ; L |- oarg2 => array base_type
    ---------------------------------------------------------- :: PI
    N |- r : pred_term ( oarg1 ) +? res_term : ipred_term & oarg2 ~> glue( < res_term , r > ) and oarg2 [ term ] := oarg1


  defn N ; nR |- wf res_req ~> bind out_res_bind for out_res_term and out_oarg -| out_nRp :: :: Req :: Req_
  {{ com $[[N]] ; [[nR]]$ fulfil well-formed request $[[res_req]]$ (via $[[out_res_bind]]$) for answer $[[out_res_term]]$ and $[[out_oarg]]$, with $[[out_nRp]]$ leftover }} by


    N |- r : norm_res -? res_req ~> None
    N ; nR |- wf res_req ~> bind res_bind for res_term and oarg -| nR
    ------------------------------------------------------------------------------------------------ :: Rej
    N ; nR , r : norm_res |- wf res_req ~> bind res_bind for res_term and oarg -| nR , r : norm_res


    N |- r : norm_res -? res_req ~> res_term and oarg
    ----------------------------------------------------------------------------- :: Acc_Clean
    N ; nR , r : norm_res |- wf res_req ~> bind cdot for res_term and oarg -| nR


    N |- r : norm_res -? res_req ~> bind res_pat1 : res1 = res_term1 for r1 & oarg and r2 : rem
    -------------------------------------------------------------------------------------------------------------------- :: Acc_Rem
    N ; nR , r : norm_res |- wf res_req ~> bind res_pat1 : res1 = res_term1 , cdot for r1 and oarg -| nR , r2 : rem


    N |- r : norm_res -? res_req1 ~> oarg1 and res_req2
    N ; nR |- wf res_req2 ~> bind res_bind2 for res_term2 and oarg2 -| nR2
    N |- r : norm_res +? res_term2 : res_req2 & oarg2 ~> res_term3 and oarg3
    -------------------------------------------------------------------------------------- :: Acc_More
    N ; nR , r : norm_res |- wf res_req1 ~> bind res_bind for res_term3 and oarg3 -| nR2


  defn N ; nR |- res_req ~> bind out_res_bind for out_res_term and out_oarg -| out_nRp :: :: Req_Wf :: Req_Wf_
  {{ com $[[N]] ; [[nR]]$ (check well-formedness of and then) fulfil request $[[res_req]]$ (via $[[out_res_bind]]$) for answer $[[out_res_term]]$ and $[[out_oarg]]$, with $[[out_nRp]]$ leftover }} by

    a def= _ : loc , </ _i : base_typei // i  /> , y' : base_type |-> res inEnv Globals
    C ; L |- ptrt => loc
    indexed </ C ; L |- iargi => base_typei // i />
    N ; nR |- wf a ( ptrt , </ iargi // i /> ) ~> bind res_bind for res_term and oarg -| nR'
    ----------------------------------------------------------------- :: Pred
    N ; nR |- a ( ptrt , </ iargi // i /> ) ~> bind res_bind for res_term and oarg -| nR'


    a def= _ : loc , </ _i : base_typei // i  /> , y' : base_type |-> res inEnv Globals
    C ; L |- ptrt => loc
    indexed </ C ; L |- iargi => base_typei // i />
    N ; nR |- wf each (integer x; iguard) { a ( array_shift < ct > ( ptrt , x ) , </ iargi // i /> ) } ~> bind res_bind for res_term and oarg -| nR'
    ----------------------------------------------------------------- :: IPred
    N ; nR |- each (integer x; iguard) { a ( array_shift < ct > ( ptrt , x ) , </ iargi // i /> ) } ~> bind res_bind for res_term and oarg -| nR'


  defn N ; nR |- if term then res1 else res2 ~> out_x -| out_nRp :: :: If :: If_
  {{ com under-determined conditional resource request: $[[N]] ; [[nR]]$ fulfil request for $[[if]]$ $[[term]]$ $[[then]]$ $[[res1]]$ $[[else]]$ $[[res2]]$ with \textbf{synthesising} $[[out_x]]$ and $[[out_nRp]]$ leftover }} by


    N |- norm_res def= if term then res1 else res2
    -------------------------------------------------------------- :: Acc
    N ; nR , x : norm_res |- if term then res1 else res2 ~> x -| nR


    N ; nR |- if term then res1 else res2 ~> x -| nR
    ----------------------------------------------------------------------------------- :: Rej
    N ; nR , x : norm_res |- if term then res1 else res2 ~> x -| nR , x : norm_res


  defn N ; nR |- calc y using res ~> bind out_res_bind for out_res_term and out_oarg -| out_nRp :: :: Oarg :: Oarg_
  {{ com arbirtrary resource and output-arg request: $[[N]] ; [[nR]]$ fulfil request for resource $[[res]]$ and output-arg $[[y]]$ (via $[[out_res_bind]]$) with \textbf{checking} $[[out_res_term]]$ and $[[out_oarg]]$, leaving resources $[[out_nRp]]$}} by


    -------------------------------------------------------------------- :: Empty
    N ; nR |- calc _ using emp ~> bind cdot for emp and unit -| nR


    ---------------------------------------------------------------- :: Return
    N ; nR |- calc y using term ~> bind cdot for TERM and term -| nR


    smt ( N => term )
    N ; nR |- calc y using res1 ~> bind res_bind for res_term and oarg -| nR'
    -------------------------------------------------------------------------------------------------------- :: EndIf_True
    N ; nR |- calc y using if term then res1 else res2 ~> bind res_bind for res_term and oarg -| nR'


    smt ( N => neg term )
    N ; nR |- calc y using res2 ~> bind res_bind for res_term and oarg -| nR'
    -------------------------------------------------------------------------------------------------------- :: EndIf_False
    N ; nR |- calc y using if term then res1 else res2 ~> bind res_bind for res_term and oarg -| nR'


    N ; nR |- if term then res1 else res2 ~> x -| nR'
    ---------------------------------------------------------------------------------------- :: EndIf_UnderDet
    N ; nR |- calc _ using if term then res1 else res2 ~> bind cdot for x and unit -| nR'


    N ; nR |- calc _ using if term then res1 else res2 ~> bind res_bind for res_term and unit -| nR'
    N ; nR' |- calc y using res3 ~> bind res_bind3 for res_term3 and oarg -| nR''
    ------------------------------------------------------------------------------------- :: MiddleIf
    N ; nR |- calc y using ( if term then res1 else res2 ) * res3 ~> bind res_bind , res_bind3 for < res_term , res_term3 > and oarg -| nR''


    smt ( N => term )
    N ; nR |- calc y using res ~> bind res_bind for res_term and oarg -| nR'
    ------------------------------------------------------------------------------------- :: Assert
    N ; nR |- calc y using term * res ~> bind res_bind for < TERM , res_term > and oarg -| nR'


    N ; nR |- pred_term ~> bind res_bind1 for res_term1 and oarg' -| nR'
    N ; nR' |- calc y using oarg' / y' ( res ) ~> bind res_bind2 for res_term2 and oarg -| nR''
    res_term def= pack ( oarg' , < res_term1 , res_term2 > )
    -------------------------------------------------------------------------------------------------------------- :: TakePred
    N ; nR |- calc y using exists y' : base_type.  pred_term ( y' ) * res ~> bind res_bind1 , res_bind2 for res_term and oarg  -| nR''


    N ; nR |- ipred_term ~> bind res_bind1 for res_term1 and oarg' -| nR'
    N ; nR' |- calc y using oarg' / y' ( res ) ~> bind res_bind2 for res_term2 and oarg -| nR''
    res_term def= pack ( oarg' , < res_term1 , res_term2 > )
    -------------------------------------------------------------------------------------------------------------- :: TakeIPred
    N ; nR |- calc y using exists y' : array base_type . ipred_term ( y' ) * res ~> bind res_bind1 , res_bind2 for res_term and oarg  -| nR''


defns
  elab_action :: 'Elab_' ::=

  % DEFER out_action'
  defn CLNnR |- action ~> bind out_res_bind for action' : out_norm_ret -| out_nRp :: :: Action :: Action_
  {{ com memory action elaboration: given $[[CLNnR]]$, $[[action]]$ elaborates (via $[[out_res_bind]]$) to $[[action']] [[:]] [[out_norm_ret]]$, with $[[out_nRp]]$ leftover }} by


    C ; L ; N ; nR |- emp | create < ct > ( pval ) => norm_ret
    norm_ret def= sigma yp : loc . term /\ exists x : to_base ( ct ) . ( yp |- Uninit - ct -> x ) *o I
    term def= representable ( ct * , yp ) /\ alignedI ( inj pval , yp )
    ----------------------------------------------------------------------- :: Create
    C ; L ; N ; nR |- _rest | create < ct > ( pval ) ~> bind cdot for emp | create < ct > ( pval ) : norm_ret -| nR


    % DEFER (not implemented)
    % C ; L ; N ; cdot |-> create_readonly ( vp , ct , v ) Symbol_prefix => ??


    % DEFER (not implemented) - memory order
    C |- pval0 => loc
    N ; nR |- Owned < Init , ct > ( inj pval0 ) ~> bind res_bind for res_term and oarg -| nR'
    norm_ret def= sigma y : to_base ( ct ) . y = oarg /\ pt *o I
    -------------------------------------------------------------------------- :: Load
    C ; L ; N ; nR |- _rest | load < ct >  ( pval0 ) ~> bind res_bind for res_term | load < ct > ( pval0 ) : norm_ret -| nR'


    C |- pval0 => loc
    C |- pval1 => to_base ( ct )
    % DEFER (not implemented) - locking boolean
    smt ( N => representable ( ct , inj pval1 ) )
    N ; nR |- Owned < _init , ct > ( inj pval0 ) ~> bind res_bind for res_term and _t -| nR'
    norm_ret def= sigma _ : unit . ( inj pval0 |- Init - ct -> inj pval1 ) *o I
    ------------------------------------------------------------------------------------------- :: Store
    C ; L ; N ; nR |- _rest | store < ct > ( pval0 , pval1 ) ~> bind res_bind for res_term | store < ct > ( pval0 , pval1 ) : norm_ret -| nR'


    C |- pval0 => loc
    N ; nR |- Owned < _init , ct > ( inj pval ) ~> bind res_bind for res_term and _t -| nR'
    ---------------------------------------------------------------------------------------- :: Kill_Static
    C ; L ; N ; nR |- _rest | kill < ct > ( pval ) ~> bind res_bind for res_term | kill < ct > ( pval ) : sigma _ : unit . I -| nR'


    % DEFER (not implemented)
    % C ; L ; N ; ?? |- _rest | kill < dyn > ( v ) => ??

defns
  elab_memop :: 'Elab_' ::=

  % DEFER out_memop'
  defn CLNnR |- memop ~> bind out_res_bind for memop' : out_norm_ret -| out_nRp :: :: Memop :: Memop_
  {{ com memory operation elaboration: given $[[CLNnR]]$, $[[memop]]$ elaborates to (via $[[out_res_bind]]$) to $[[memop']] [[:]] [[out_norm_ret]]$, with $[[out_nRp]]$ leftover }} by


    % DEFER - how to infer provenances

    % C |- pval1 => loc
    % C |- pval2 => loc
    % C ; L ; N ; R |- res_term => res
    % N |- inj pval1 inEnv res
    % N |- inj pval2 inEnv res
    % -------------------------------- :: Rel_Binop
    % C ; L ; N ; R |- res_term | pval1 rel_binop pval2 => sigma y : bool . y = ( inj pval1 ' rel_binop ' inj pval2 ) /\ res *o I


    % C |- pval1 => loc
    % C |- pval2 => loc
    % C ; L ; N ; R |- res_term => res
    % res def= Arr < ct > ( ptrt , _b , _b ) ( _t )
    % N |- inj pval1 inEnv res
    % N |- inj pval2 inEnv res
    % -------------------------------- :: PtrDiff_Arr
    % C ; L ; N ; R |- res_term | pval1 - array n ct - pval2 => sigma y : bool . y = ( inj pval1 - inj pval2 ) / sizeof ct /\ res *o I


    % C |- pval1 => loc
    % C |- pval2 => loc
    % C ; L ; N ; R |- res_term => res
    % N |- inj pval1 inEnv res
    % N |- inj pval2 inEnv res
    % -------------------------------- :: PtrDiff
    % C ; L ; N ; R |- res_term | pval1 - ct - pval2 => sigma y : bool . y = ( inj pval1 - inj pval2 ) / sizeof ct /\ res *o I


    % C |- pval => loc
    % C ; L ; N ; R |- res_term => res
    % N |- inj pval inEnv res
    % ------------------------------- :: IntFromPtr
    % C ; L ; N ; R |- intFromPtr ( res_term | ct1 , ct2 , pval ) => sigma y : integer . y = cast_ptr_to_int inj pval /\ res *o I


    % C |- pval => integer
    % C ; L ; N ; R |- res_term => res
    % N |- inj pval inEnv res
    % ----------------------------------- :: PtrFromInt
    % C ; L ; N ; R |- ptrFromInt ( res_term | ct1 , ct2 , pval ) => sigma y : loc . y = cast_int_to_ptr inj pval /\ res *o I

    % C |- pval1 => loc
    % C |- pval2 => integer
    % C ; L ; N ; R |- res_term => res
    % res def= Arr < ct > ( ptrt , _b , _b ) ( _t )
    % N |- inj pval1 inEnv res
    % N |- inj pval1 +ptr ( inj pval2 * sizeof ct ) inEnv res
    % ----------------------------------------------------- :: PtrArrayShift
    % C ; L ; N ; R |- ptrArrayShift ( res_term | pval1 ,  ct , pval2 ) => sigma y : loc . y = inj pval1 +ptr ( inj pval2 * sizeof ct ) /\ res *o I


    C ; L ; N ; nR |- memop => norm_ret
    --------------------------------------------------------------------- :: Rest
    C ; L ; N ; nR |- memop ~> bind cdot for memop : norm_ret -| nR


    % DEFER (not implemented)
    % memcpy ( pval1 , pval2 , pval3 )
    % memcmp ( pval1 , pval2 , pval3 )
    % realloc ( pval1 , pval2 , pval3 )
    % va_start ( pval1 , pval2 )
    % va_copy ( pval )
    % va_arg ( pval , ct )
    % va_end ( pval )


defns
  elab_spine :: 'Elab_' ::=

  % DEFER out_spine'
  defn CLNnR |- spine :; norm_fun ~> bind out_res_bind for spine' and out_norm_ret -| out_nRp :: :: Spine :: Spine_
  {{ com spine elaboration: given $[[CLNnR]]$, arguments $[[spine]]$ and function type $[[norm_fun]]$ elaborate (via $[[out_res_bind]]$ ) to $[[spine']]$ and result type $[[out_norm_ret]]$ , with $[[out_nRp]]$ leftover }} by

    -------------------------------------------------------------- :: Empty
    C ; L ; N ; nR |- :; norm_ret ~> bind cdot for and norm_ret -| nR


    C |- pval => base_type
    C ; L ; N ; nR |- spine :; pval / x  ( norm_fun ) ~> bind res_bind for spine' and norm_ret -| nR'
    ---------------------------------------------------------------------------------------------------------------- :: Comp
    C ; L ; N ; nR |- pval , spine :; pi x : base_type . norm_fun ~> bind res_bind for pval , spine' and norm_ret -| nR'


    % Could infer a pack here
    N ; nR |- pred_term ~> bind res_bind for res_term and oarg -| nR'
    C ; L ; N ; nR' |- spine :; norm_fun ~> bind res_bind' for spine' and norm_ret -| nR''
    ------------------------------------------------------------------------------------------- :: TakePred
    C ; L ; N ; nR |- spine :; forall y : base_type . pred_term ( y ) --o norm_fun ~> bind res_bind , res_bind' for oarg , res_term , spine' and norm_ret -| nR''


    N ; nR |- ipred_term ~> bind res_bind for res_term and oarg -| nR'
    C ; L ; N ; nR' |- spine :; oarg / y ( norm_fun ) ~> bind res_bind' for spine' and norm_ret' -| nR''
    --------------------------------------------------------------------------------------------------------------- :: TakeIPred
    C ; L ; N ; nR |- spine :; forall y : array base_type . ipred_term ( y ) --o norm_fun ~> bind res_bind , res_bind' for oarg , res_term , spine' and norm_ret -| nR''


    N ; nR |- calc _ using if term then res1 else res2 ~> bind res_bind for res_term and unit -| nR'
    C ; L ; N ; nR' |- spine :; norm_fun ~> bind res_bind' for spine' and norm_ret -| nR''
    ----------------------------------------------------------------------------------------------------------------------------------------------- :: MiddleIf
    C ; L ; N ; nR |- spine :;  if term then res1 else res2 --o norm_fun ~> bind res_bind , res_bind' for res_term , spine' and norm_ret -| nR''


    smt ( N => term )
    C ; L ; N ; nR |- spine :; norm_fun ~> bind res_bind for spine' and norm_ret -| nR'
    ------------------------------------------------------------------------------------------- :: Phi
    C ; L ; N ; nR |- spine :;  term -) norm_fun ~> bind res_bind for spine' and norm_ret -| nR'


defns
  elab_expr :: 'Elab_' ::=

  defn CLNnR |- expr ~> bind out_res_bind for expr' : out_ret -| out_nRp :: :: Expr :: Expr_
  {{ com (effectful) expression elaboration: given $[[CLNnR]]$, $[[expr]]$ elaborates (via $[[out_res_bind]]$) to $[[expr']] [[:]] [[out_ret]]$, with $[[out_nRp]]$ leftover }} by


    C ; L ; N |- pexpr => pure_ret
    ---------------------------------------------------------------------------- :: Pure
    C ; L ; N ; nR |- pure ( pexpr ) ~> bind cdot for pure ( pexpr ) : pure_ret -| nR


    C ; L ; N ; nR |- action ~> bind res_bind for action' : norm_ret -| nR'
    --------------------------------------------------------------------------- :: Action
    C ; L ; N ; nR |- action ~> bind res_bind for action' : norm_ret -| nR'


    C ; L ; N ; nR |- memop ~> bind res_bind for memop' : norm_ret -| nR'
    ------------------------------------------------------------------------- :: Memop
    C ; L ; N ; nR |- memop ~> bind res_bind for memop' : norm_ret -| nR'


    % </ C ; L ; N ; nRi |- stmti <= reti // i />
    % -------------------------------------------------------------------------------------------- :: Unseq
    % C ; L ; N ; </ nRi // i /> |- unseq ( </ stmti : reti // i /> ) => concat </ reti // i />


    id :  norm_fun def= </ xi // i /> |-> stmt  inEnv Globals
    C ; L ; N ; nR |- spine :; norm_fun ~> bind res_bind for </ spine_elemi // i /> and norm_ret -| nR'
    ---------------------------------------------------------------------------------------------------------------- :: CCall
    C ; L ; N ; nR |- ccall ( ct , id , spine ) ~> bind res_bind for ccall ( ct , id , </ spine_elemi // i /> ) : norm_ret -| nR'


    name :  norm_fun def= </ xi // i /> |-> stmt  inEnv Globals
    C ; L ; N ; nR |- spine :; norm_fun ~> bind res_bind for </ spine_elemi // i /> and norm_ret -| nR'
    ------------------------------------------------------------------------------------------------------------------ :: Proc
    C ; L ; N ; nR |- pcall ( name , spine ) ~> bind res_bind for pcall ( name , </ spine_elemi // i /> ) : norm_ret -| nR'


    a def= </ xi : base_typei // i  /> , y : base_type |-> res inEnv Globals
    indexed </ C |- pvali => base_typei // i />
    N ; nR |- calc y using [ </ pvali / xi // i /> ] ( res ) ~> bind res_bind for res_term and oarg -| nR'
    pred def= a ( </ inj pvali // i /> ) ( oarg )
    ---------------------------------------------------------------------------------------------------------- :: Fold
    C ; L ; N ; nR |- fold a ( </ pvali // i /> ) ~> bind res_bind for fold res_term : pred : pred *o I -| nR''


    a def= </ xi : base_typei // i  /> , y : base_type |-> res inEnv Globals
    indexed </ C |- pvali => base_typei // i />
    N ; nR |- a ( </ inj pvali // i /> ) ~> bind res_bind for res_term and oarg -| nR'
    res' def= [ oarg / y , [ </ iargi / xi // i /> ] ] ( res )
    ------------------------------------------------------------------------------------------------ :: Unfold
    C ; L ; N ; nR |- unfold a ( </ pvali // i /> ) ~> bind res_bind , fold ( r ) : a ( </ inj pvali // i /> ) ( oarg ) = res_term for r : res' *o I -| nR'


defns
  elab :: 'Elab_' ::=

  defn N |- res ~> out_res_pat :: :: Res_Pat :: Res_Pat_
  {{ com resource type normalisation by pattern-matching: under constraints $[[N]]$ , $[[res]]$ will produce a normalised resourced context if it matches against $[[out_res_pat]]$ }} by


    ---------------- :: Empty
    N |- emp ~> emp

    ----------------- :: Phi
    N |- term ~> TERM


    smt ( N => term )
    N |- res1 ~> res_pat
    ---------------------------------------------- :: If_True
    N |- if term then res1 else res2 ~> res_pat


    smt ( N => neg term )
    N |- res2 ~> res_pat
    ---------------------------------------------- :: If_False
    N |- if term then res1 else res2 ~> res_pat


    ------------- :: Var
    N |- norm_res ~> r


    N |- res1 ~> res_pat1
    N |- res2 ~> res_pat2
    ------------------------------------------------ :: SepConj
    N |- res1 * res2 ~> < res_pat1 , res_pat2 >


    N |- x / y ( res ) ~> res_pat
    ------------------------------------------------------ :: Pack
    N |- exists y : base_type . res ~> pack ( x , res_pat )



  defn N |- ret ~> out_ret_pat :: :: Ret_Pat :: Ret_Pat_
  {{ com return type normalisation by pattern-matching: under constraints $[[N]]$ , $[[ret]]$ will produce a normalised resourced context if it matches against $[[out_ret_pat]]$ }} by

  --------- :: I
  N |- I ~>


  N |- res ~> res_pat
  N |- ret ~> ret_pat
  ------------------------------------------------------------ :: Res
  N |- res *o ret ~> reso res_pat , ret_pat


  N |- ret ~> ret_pat
  ------------------------------------------------------------ :: Log
  N |- exists x : base_type . ret ~> log x , ret_pat


  defn N ; nR ~> out_res_bind :: :: Simp_Ctx :: Simp_Ctx_
  {{ com partial-simplification of resource context: given $[[N]]; [[nR]]$ can partially simplify the resources using $[[out_res_bind]]$ }} by

    ---------------- :: Empty
    N ; cdot ~> cdot

    N |- simp ( norm_res ) ~> res'
    N |- res' ~> res_pat
    N ; nR ~> res_bind
    ----------------------------------------------------------- :: Simp
    N ; nR , x : norm_res ~> res_bind , res_pat : res' = x


    N |- simp ( res ) ~> None
    N ; nR ~> res_bind
    --------------------------------- :: Skip
    N ; nR , _ : norm_res ~> res_bind


  % DEFER out_stmt
  defn CLNnR |- stmt <= norm_ret ~> stmt' :: :: Stmt :: Stmt_
  {{ com (effectful) expression elaboration: given $[[CLNnR]]$, $[[stmt]]$ elaborates to $[[stmt']]$ }} by


    C ; L ; N ; nR |- ret_terms :; to_fun norm_ret ~> bind res_bind for ret_terms' and I -| nR'
    ----------------------------------------------------------------------------------------- :: RetT
    C ; L ; N ; nR |- < ret_terms > <= norm_ret ~> insert_lets ( res_bind , < ret_terms' > )


    ---------------------------------------------------------------- :: Pure
    C ; L ; N ; nR |- pure ( pstmt ) <= pure_ret ~> pure ( pstmt )


    C ; L ; N ; nR |- expr ~> bind res_bind for expr' : ret -| nR'
    N |- ret ~> ret_pat
    N |- ret_pat : sigma y : base_type . ret ~> C1 ; L1 ; N1 ; nR1
    C , C1 ; L , L' , L1 ; N , N' , N1 ; nR' , nR1 |- stmt <= norm_ret2 ~> stmt'
    stmt'' def= insert_lets ( res_bind , let ret_pat = expr' in stmt' )
    ---------------------------------------------------------------------------------------- :: Let
    C ; L ; N ; nR |- let _ret_pat = expr in stmt <= norm_ret2 ~> stmt''


    C ; L ; N ; nR' |- stmt1 <= norm_ret1 ~> stmt1'
    N |- norm_ret1 ~> ret_pat
    N |- ret_pat : norm_ret1 ~> C1 ; L1 ; N1 ; nR1
    C , C1 ; L , L1 ; N , N1 ; nR , nR1 |- stmt2 <= norm_ret2 ~> stmt2'
    stmt'' def= let ret_pat : norm_ret1 = stmt1' in stmt2'
    ---------------------------------------------------------------------- :: Annot
    C ; L ; N ; nR' , nR |- let _ret_pat : norm_ret1 = stmt1 in stmt2 <= norm_ret2 ~> stmt''


    C |- pval => bool
    N , inj pval = true ; nR ~> res_bind1
    C ; L ; N , inj pval = true  ; nR1 |- insert_lets ( res_bind1 , stmt1 ) <= norm_ret ~> stmt1'
    N , inj pval = false ; nR2 ~> res_bind2
    C ; L ; N , inj pval = false ; nR2 |- insert_lets ( res_bind2 , stmt2 ) <= norm_ret ~> stmt2'
    ------------------------------------------------------------------------- :: If
    C ; L ; N ; nR |- if pval then stmt1 else stmt2 <= norm_ret ~> if pval then stmt1' else stmt2'


    C |- pval => base_type1
    indexed pati : base_type1 ~> Ci with termi
    indexed </ N , termi = inj pval ; nR ~> res_bindi // i />
    indexed </ C , Ci ; L ; N , termi = inj pval ; nR |- insert_lets ( res_bindi , stmti ) <= norm_ret ~> stmt'i // i />
    ------------------------------------------------------------------------------------------------------ :: Case
    C ; L ; N ; nR |- case pval of </ | pati => stmti // i /> end <= norm_ret ~> case pval of </ | pati => stmt'i // i /> end


    id : norm_fun def= </ xi // i /> |-> stmt inEnv Globals
    C ; L ; N ; cdot |- </ xi = pvali // i /> :; norm_fun >> subs ; false /\ I
    ----------------------------------------------------------------------------- :: Run
    C ; L ; N ; cdot |- run id </ pvali // i /> <= false /\ I ~> run id </ pvali // i />
