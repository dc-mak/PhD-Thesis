% These rules infer indices, which the implementation currently does not (but did at one point)

grammar

  res_diff {{ tex \outpol{\mathit{res\_diff} } }} :: 'Res_diff_' ::= {{ com resource difference }}
    | None                                                                                        :: :: None
      {{ com not possible to take a difference }} {{ tex \outpol{[[None]]} }}
    | out_res_term and out_oarg                                                                   :: :: Clean
      {{ com request is satisfied exactly by $[[out_res_term]]$ and the output argument is $[[out_oarg]]$ }}
    | out_oarg and out_pred_ipred                                                                    :: :: More
      {{ com request is satisfied partially with output argument $[[out_oarg]]$ with remaining $[[out_pred_ipred]]$ }}
    | bind out_res_bind for out_x1 & out_oarg REM out_x2 : out_rem     :: :: Rem
      {{ com use $[[out_res_bind]]$ to satisfy request exactly (using $[[out_x1]]$ and $[[out_oarg]]$) with remainder $[[out_x2]] [[:]] [[out_rem]]$ }}


  res_bind :: 'res_bind_' ::= {{ com resource bindings }}
    | cdot                      :: :: nil    {{ com empty resource binding                                       }}
    | res_pat : res = res_term  :: :: cons   {{ com match $[[res_term]] [[:]] [[res]]$ against $[[res_pat]]$ }}
    | </ res_bindi // , // i /> :: :: concat {{ com concatenate resource bindings                                }}


  % OUT_HACK|res_bind
  out_res_bind {{ tex \outpol{ res\_bind } }}   :: 'Out_hack_' ::=  {{ com Ott-hack, ignore }}
    | res_bind :: :: res_bind {{ tex \outpol{ [[res_bind]] } }}

  opt_term :: 'Opt_term_' ::= {{ com optional SMT term }}
    | None :: :: None
    | term :: :: Some

  % OUT_HACK|opt_term
  out_opt_term {{ tex \outpol{ opt\_term } }}   :: 'Out_hack_' ::=  {{ com Ott-hack, ignore }}
    | opt_term :: :: opt_term {{ tex \outpol{ [[opt_term]] } }}

  cmp :: 'Cmp_' ::= {{ com result of binary comparison }}
    | Lt :: :: Lt {{ com less-than    }}
    | Eq :: :: Eq {{ com equals       }}
    | Gt :: :: Gt {{ com greater-than }}

  opt_cmp :: 'Opt_cmp_' ::= {{ com optional result of binary comparison }}
    | None :: :: None
    | cmp  :: :: Some

  % OUT_HACK|opt_cmp
  out_opt_cmp {{ tex \outpol{ opt\_cmp } }}   :: 'Out_hack_' ::=  {{ com Ott-hack, ignore }}
    | opt_cmp :: :: opt_cmp {{ tex \outpol{ [[opt_cmp]] } }}

  opt_cmp_term :: 'Opt_cmp_term_' ::= {{ com optional result of binary comparison and SMT term }}
    | None       :: :: None
    | cmp , term :: :: Some

  % OUT_HACK|opt_cmp_term
  out_opt_cmp_term {{ tex \outpol{ opt\_cmp\_term } }}   :: 'Out_hack_' ::=  {{ com Ott-hack, ignore }}
    | opt_cmp_term :: :: opt_cmp_term {{ tex \outpol{ [[opt_cmp_term]] } }}

defns
  inf_res :: '' ::=

  defn N |- pred_term in? ipred_term ~> out_opt_term :: :: PinI :: PinI_
  {{ com given constraints $[[N]]$, $[[pred_term]]$ is potentially a part of $[[ipred_term]]$ at index $[[out_opt_term]]$ }} by

    a1 != a2
    ----------------------------------------------------------------------- :: Name_Neq
    N |- a1 ( _iargs ) in? each (integer _; _t) { a2 ( _iargs ) } ~> None


    term def= ( ptrt2 - ptrt1 ) / sizeof ct
    term1 def= term / x ( iguard )
    term2 def= /\\ ( </ iarg1i = [ term / x ] ( iarg2i ) // i /> )
    smt ( N => neg ( term1 /\ term2 ) )
    -------------------------------------------------------------------------- :: IG_Or_IArg_Neq
    N |- a ( ptrt2 , </ iarg1i // i /> ) in? each (integer x; iguard) { a ( array_shift < ct > ( ptrt1 , x ) , </ iarg2i // i /> ) }  ~> None


    term def= ( ptrt2 - ptrt1 ) / sizeof ct
    term1 def= term / x ( iguard )
    term2 def= /\\ ( </  iarg1i = [ term / x ] ( iarg2i ) // i /> )
    smt ( N => term1 /\ term2 )
    -------------------------------------------------------------------------- :: Comp
    N |- a ( ptrt2 , </ iarg1i // i /> ) in? each (integer x; iguard) { a ( array_shift < ct > ( ptrt1 , x ) , </ iarg2i // i /> ) } ~> term


  defn N |- r : norm_res -? pred_ipred ~> res_diff :: :: Res_Diff :: Res_Diff_
  {{ com the difference between $[[r]] [[:]] [[norm_res]]$ and requested $[[pred_ipred]]$ is $[[res_diff]]$ }} by

    ---------------------------------------------------------- :: If_None
    N |- _ : if term then res1 else res2 -? pred_ipred ~> None


    N |- pred_term = pred_term' ~> false
    ----------------------------------------------- :: PP_None
    N |- _ : pred_term' ( _ ) -? pred_term  ~> None


    N |- pred_term = pred_term' ~> true
    -------------------------------------------------------- :: PP_Exact
    N |- r : pred_term' ( oarg ) -? pred_term ~> r and oarg


    N |- pred_term in? ipred_term ~> None
    ------------------------------------------------ :: PI_None
    N |- _ : ipred_term ( _t ) -? pred_term ~> None


    N |- pred_term in? ipred_term ~> term
    ipred_term def= each (integer x; iguard) { pred_term }
    rem def= each (integer x; iguard /\ (x != term)) { pred_term } ( oarg )
    oarg' def= oarg [ term ]
    res def= pred_term ( oarg' )
    -------------------------------------------------------------------------- :: PI_Rem
    N |- r : ipred_term ( oarg ) -? pred_term ~> bind < r1 , r2 > : rem * res = break ( r , term ) for r2 & oarg' REM r1 : rem


    N |- pred_term in? ipred_term ~> None
    ------------------------------------------------ :: IP_None
    N |- _ : pred_term ( _t ) -? ipred_term ~> None


    N |- pred_term in? ipred_term ~> term
    ipred_term def= each (integer x; iguard) { pred_term }
    smt ( N => neg < each (integer x; _t) { neg ( iguard /\ ( x != term ) ) } > )
    ipred_term' def= each (integer x; iguard /\ ( x != term ) ) { pred_term }
    ----------------------------------------------------------------- :: IP_More
    N |- r : pred_term ( oarg ) -? ipred_term ~> oarg and ipred_term'


    pred_term def= r ( array_shift < ct > ( ptrt1 , x ) , iargs )
    N |- pred_term in? ipred_term ~> term
    ipred_term def= each (integer x; iguard) { pred_term }
    smt ( N => each (integer x; _t) { neg ( iguard /\ ( x != term ) ) } )
    C ; L |- oarg => base_type
    ------------------------------------------------------------------------------------------------ :: IP_Last
    N |- r : pred_term ( oarg ) -? ipred_term ~> inj ( r , ptrt1 , ct , x . iargs ) and const oarg


    N |- ipred_term [=? ipred_term' ~> None
    -------------------------------------------------- :: II_None
    N |- _ : ipred_term' ( _t ) -? ipred_term ~> None


    N |- ipred_term' [=? ipred_term ~> Eq
    ------------------------------------------------------------------- :: II_Eq
    N |- r : ipred_term ( oarg ) -? ipred_term'  ~> r and oarg


    N |- ipred_term' [=? ipred_term ~> Lt
    % ipred_term' < ipred_term
    ipred_term def= each (integer x; iguard) { pred_term }
    ipred_term' def= each (integer x; iguard') { pred_term }
    rem def= each (integer x; iguard  /\ neg iguard') { pred_term } ( oarg )
    ---------------------------------------------------------------------------------------- :: II_Lt
    N |- r : ipred_term ( oarg ) -? ipred_term' ~> bind < r1 , r2 > : res = chop ( r , iguard' ) for r1 & oarg [ k ] REM r2 : rem


    % This would require being able to merge arrays, which the implementation does not support
    % N |- ipred_term' [=? ipred_term ~> Gt
    % % ipred_term' > ipred_term
    % ipred_term  def= { x ; iguard  . a ( ptrt + step , iargs ) }
    % ipred_term' def= { x ; iguard' . a ( ptrt + step , iargs ) }
    % ------------------------------------------------------------------ :: II_Gt
    % N |- r : ipred_term & oarg -? ipred_term'  ~> oarg and { x ; iguard' /\ neg iguard . a ( ptrt + step , iargs ) }


  defn N |- r1 : norm_res +? res_term2 : pred_ipred & oarg2 ~> out_res_term and out_oarg3 :: :: Res_Comb :: Res_Comb_
  {{ com combining $[[r1]] [[:]] [[norm_res]]$, $[[res_term2]] [[:]] [[pred_ipred]] \& [[oarg2]]$, results in $[[out_res_term]]$ $[[out_oarg3]]$ }} by

    N |- pred_term in? ipred_term ~> term
    C ; L |- oarg1 => base_type
    C ; L |- oarg2 => array base_type
    ---------------------------------------------------------- :: PI
    N |- r : pred_term ( oarg1 ) +? res_term : ipred_term & oarg2 ~> glue( < res_term , r > ) and oarg2 [ term ] := oarg1


  defn N ; nR |- wf pred_ipred ~> bind out_res_bind for out_res_term and out_oarg -| out_nRp :: :: Req :: Req_
  {{ com $[[N]] ; [[nR]]$ fulfil well-formed request $[[pred_ipred]]$ (via $[[out_res_bind]]$) for answer $[[out_res_term]]$ and $[[out_oarg]]$, with $[[out_nRp]]$ leftover }} by


    N |- r : norm_res -? pred_ipred ~> None
    N ; nR |- wf pred_ipred ~> bind res_bind for res_term and oarg -| nR
    ------------------------------------------------------------------------------------------------ :: Rej
    N ; nR , r : norm_res |- wf pred_ipred ~> bind res_bind for res_term and oarg -| nR , r : norm_res


    N |- r : norm_res -? pred_ipred ~> res_term and oarg
    ----------------------------------------------------------------------------- :: Acc_Clean
    N ; nR , r : norm_res |- wf pred_ipred ~> bind cdot for res_term and oarg -| nR


    N |- r : norm_res -? pred_ipred ~> bind res_pat1 : res1 = res_term1 for r1 & oarg REM r2 : rem
    -------------------------------------------------------------------------------------------------------------------- :: Acc_Rem
    N ; nR , r : norm_res |- wf pred_ipred ~> bind res_pat1 : res1 = res_term1 , cdot for r1 and oarg -| nR , r2 : rem


    N |- r : norm_res -? pred_ipred1 ~> oarg1 and pred_ipred2
    N ; nR |- wf pred_ipred2 ~> bind res_bind2 for res_term2 and oarg2 -| nR2
    N |- r : norm_res +? res_term2 : pred_ipred2 & oarg2 ~> res_term3 and oarg3
    -------------------------------------------------------------------------------------- :: Acc_More
    N ; nR , r : norm_res |- wf pred_ipred1 ~> bind res_bind for res_term3 and oarg3 -| nR2


  defn N ; nR |- pred_ipred ~> bind out_res_bind for out_res_term and out_oarg -| out_nRp :: :: Req_Wf :: Req_Wf_
  {{ com $[[N]] ; [[nR]]$ (check well-formedness of and then) fulfil request $[[pred_ipred]]$ (via $[[out_res_bind]]$) for answer $[[out_res_term]]$ and $[[out_oarg]]$, with $[[out_nRp]]$ leftover }} by

    P ( a ) = </ _i : base_typei // i  /> , _ : _bt |-> res
    indexed </ C ; L |- iargi => base_typei // i />
    N ; nR |- wf a ( </ iargi // i /> ) ~> bind res_bind for res_term and oarg -| nR'
    ----------------------------------------------------------------- :: Pred
    N ; nR |- a ( ptrt , </ iargi // i /> ) ~> bind res_bind for res_term and oarg -| nR'


    P ( a ) = </ _i : base_typei // i  /> , _ : _bt |-> res
    indexed </ C ; L |- iargi => base_typei // i />
    N ; nR |- wf each (integer x; iguard) { a ( </ iargi // i /> ) } ~> bind res_bind for res_term and oarg -| nR'
    ----------------------------------------------------------------- :: IPred
    N ; nR |- each (integer x; iguard) { a ( </ iargi // i /> ) } ~> bind res_bind for res_term and oarg -| nR'


  defn N ; nR |- if term then res1 else res2 ~> out_x -| out_nRp :: :: If :: If_
  {{ com under-determined conditional resource request: $[[N]] ; [[nR]]$ fulfil request for $[[if]]$ $[[term]]$ $[[then]]$ $[[res1]]$ $[[else]]$ $[[res2]]$ with \textbf{synthesising} $[[out_x]]$ and $[[out_nRp]]$ leftover }} by


    N |- norm_res = if term then res1 else res2
    -------------------------------------------------------------- :: Acc
    N ; nR , x : norm_res |- if term then res1 else res2 ~> x -| nR


    N ; nR |- if term then res1 else res2 ~> x -| nR
    ----------------------------------------------------------------------------------- :: Rej
    N ; nR , x : norm_res |- if term then res1 else res2 ~> x -| nR , x : norm_res


  defn N ; nR |- res ~> bind out_res_bind for out_res_term and out_oarg -| out_nRp :: :: Oarg :: Oarg_
  {{ com arbirtrary resource and output-arg request: $[[N]] ; [[nR]]$ fulfil request for output argument of resource $[[res]]$ and output-arg $[[y]]$ (via $[[out_res_bind]]$) with \textbf{checking} $[[out_res_term]]$ and $[[out_oarg]]$, leaving resources $[[out_nRp]]$}} by


    % ------------------------------------------------- :: Empty
    % N ; nR |- emp ~> bind cdot for emp and x -| nR


    ---------------------------------------------------- :: Return
    N ; nR |- term ~> bind cdot for emp and term -| nR


    N ; nR |- pred_term ~> bind res_bind for res_term and oarg -| nR'
    ------------------------------------------------------------------------ :: Pred
    N ; nR |- pred_term ( _t ) ~> bind res_bind for res_term and oarg  -| nR'


    N ; nR |- ipred_term ~> bind res_bind for res_term and oarg -| nR'
    ------------------------------------------------------------------------- :: IPred
    N ; nR |- ipred_term ( _t ) ~> bind res_bind for res_term and oarg  -| nR'
    

    smt ( N => term )
    N ; nR |- res ~> bind res_bind for res_term and oarg -| nR'
    ----------------------------------------------------------------------------- :: Assert
    N ; nR |- term * res ~> bind res_bind for < TERM , res_term > and oarg -| nR'


    smt ( N => term )
    N ; nR |- res1 ~> bind res_bind for res_term and oarg -| nR'
    ----------------------------------------------------------------------------------- :: If_True
    N ; nR |- if term then res1 else res2 ~> bind res_bind for res_term and oarg -| nR'


    smt ( N => neg term )
    N ; nR |- res2 ~> bind res_bind for res_term and oarg -| nR'
    ----------------------------------------------------------------------------------- :: If_False
    N ; nR |- if term then res1 else res2 ~> bind res_bind for res_term and oarg -| nR'


    % % x is a fresh/unconstrained variable
    % --------------------------------------------------------------------- :: If_Undet
    % N ; nR |- if term then res1 else res2 ~> bind cdot for x and x -| nR'


    N ; nR |- res1 ~> bind res_bind1 for res_term1 and oarg1 -| nR1
    N ; nR1 |- oarg1 / y1 ( res2 ) ~> bind res_bind2 for res_term2 and oarg2 -| nR2
    res_term def= pack ( oarg2 , < res_term1 , res_term2 > )
    ---------------------------------------------------------------------------------------------------------- :: Take
    N ; nR |- exists y1 : base_type.  res1 * res2 ~> bind res_bind1 , res_bind2 for res_term and oarg2  -| nR2


defns
  elab_action :: 'Elab_' ::=

  % DEFER out_res
  defn CLNnR |- action ~> bind out_res_bind for out_res_term & out_norm_ret -| out_nRp :: :: Action :: Action_
  {{ com memory action return-type inference: given $[[CLNnR]]$ and $[[action]]$, infer (via $[[out_res_bind]]$) $[[out_res_term]]$ and $[[out_norm_ret]]$, with $[[out_nRp]]$ leftover }} by


    C ; L ; N ; nR |- emp | create < ct > ( pval ) => norm_ret
    norm_ret def= sigma yp : loc . term /\ exists x : to_base ( ct ) . ( yp |- Uninit - ct -> x ) *o I
    term def= representable ( ct * , yp ) /\ alignedI ( inj pval , yp )
    ----------------------------------------------------------------------- :: Create
    C ; L ; N ; nR |- create < ct > ( pval ) ~> bind cdot for emp & norm_ret -| nR


    % DEFER (not implemented)
    % C ; L ; N ; cdot |-> create_readonly ( vp , ct , v ) Symbol_prefix => ??


    % DEFER (not implemented) - memory order
    C |- pval0 => loc
    N ; nR |- Owned < Init , ct > ( inj pval0 ) ~> bind res_bind for res_term and oarg -| nR'
    norm_ret def= sigma y : to_base ( ct ) . y = oarg /\ pt *o I
    -------------------------------------------------------------------------- :: Load
    C ; L ; N ; nR |- load < ct >  ( pval0 ) ~> bind res_bind for res_term & norm_ret -| nR'


    C |- pval0 => loc
    C |- pval1 => to_base ( ct )
    % DEFER (not implemented) - locking boolean
    smt ( N => representable ( ct , inj pval1 ) )
    N ; nR |- Owned < _init , ct > ( inj pval0 ) ~> bind res_bind for res_term and _t -| nR'
    norm_ret def= sigma _ : unit . ( inj pval0 |- Init - ct -> inj pval1 ) *o I
    ------------------------------------------------------------------------------------------- :: Store
    C ; L ; N ; nR |- store < ct > ( pval0 , pval1 ) ~> bind res_bind for res_term & norm_ret -| nR'


    C |- pval0 => loc
    N ; nR |- Owned < _init , ct > ( inj pval ) ~> bind res_bind for res_term and _t -| nR'
    ---------------------------------------------------------------------------------------- :: Kill_Static
    C ; L ; N ; nR |- kill < ct > ( pval ) ~> bind res_bind for res_term & sigma _ : unit . I -| nR'


    % DEFER (not implemented)
    % C ; L ; N ; ?? |- _rest | kill < dyn > ( v ) => ??

defns
  elab_memop :: 'Elab_' ::=

  % DEFER out_memop'
  defn CLNnR |- memop ~> bind out_res_bind for out_res_term & out_norm_ret -| out_nRp :: :: Memop :: Memop_
  {{ com memory operation return-type inference: given $[[CLNnR]]$ and $[[memop]]$, infer (via $[[out_res_bind]]$) $[[out_res_term]]$ and $[[out_norm_ret]]$, with $[[out_nRp]]$ leftover }} by


    % DEFER - how to infer provenances

    % C |- pval1 => loc
    % C |- pval2 => loc
    % C ; L ; N ; R |- res_term => res
    % N |- inj pval1 inEnv res
    % N |- inj pval2 inEnv res
    % -------------------------------- :: Rel_Binop
    % C ; L ; N ; R |- res_term | pval1 rel_binop pval2 => sigma y : bool . y = ( inj pval1 ' rel_binop ' inj pval2 ) /\ res *o I


    % C |- pval1 => loc
    % C |- pval2 => loc
    % C ; L ; N ; R |- res_term => res
    % res def= Arr < ct > ( ptrt , _b , _b ) ( _t )
    % N |- inj pval1 inEnv res
    % N |- inj pval2 inEnv res
    % -------------------------------- :: PtrDiff_Arr
    % C ; L ; N ; R |- res_term | pval1 - array n ct - pval2 => sigma y : bool . y = ( inj pval1 - inj pval2 ) / sizeof ct /\ res *o I


    % C |- pval1 => loc
    % C |- pval2 => loc
    % C ; L ; N ; R |- res_term => res
    % N |- inj pval1 inEnv res
    % N |- inj pval2 inEnv res
    % -------------------------------- :: PtrDiff
    % C ; L ; N ; R |- res_term | pval1 - ct - pval2 => sigma y : bool . y = ( inj pval1 - inj pval2 ) / sizeof ct /\ res *o I


    % C |- pval => loc
    % C ; L ; N ; R |- res_term => res
    % N |- inj pval inEnv res
    % ------------------------------- :: IntFromPtr
    % C ; L ; N ; R |- intFromPtr ( res_term | ct1 , ct2 , pval ) => sigma y : integer . y = cast_ptr_to_int inj pval /\ res *o I


    % C |- pval => integer
    % C ; L ; N ; R |- res_term => res
    % N |- inj pval inEnv res
    % ----------------------------------- :: PtrFromInt
    % C ; L ; N ; R |- ptrFromInt ( res_term | ct1 , ct2 , pval ) => sigma y : loc . y = cast_int_to_ptr inj pval /\ res *o I

    % C |- pval1 => loc
    % C |- pval2 => integer
    % C ; L ; N ; R |- res_term => res
    % res def= Arr < ct > ( ptrt , _b , _b ) ( _t )
    % N |- inj pval1 inEnv res
    % N |- inj pval1 +ptr ( inj pval2 * sizeof ct ) inEnv res
    % ----------------------------------------------------- :: PtrArrayShift
    % C ; L ; N ; R |- ptrArrayShift ( res_term | pval1 ,  ct , pval2 ) => sigma y : loc . y = inj pval1 +ptr ( inj pval2 * sizeof ct ) /\ res *o I


    C ; L ; N ; nR |- _rest | memop => norm_ret
    --------------------------------------------------------------------- :: Rest
    C ; L ; N ; nR |- memop ~> bind cdot for res_term & norm_ret -| nR


    % DEFER (not implemented)
    % memcpy ( pval1 , pval2 , pval3 )
    % memcmp ( pval1 , pval2 , pval3 )
    % realloc ( pval1 , pval2 , pval3 )
    % va_start ( pval1 , pval2 )
    % va_copy ( pval )
    % va_arg ( pval , ct )
    % va_end ( pval )


defns
  elab_spine :: 'Elab_' ::=

  % DEFER out_spine'
  defn CLNnR |- spine :; norm_fun ~> bind out_res_bind for spine' and out_norm_ret -| out_nRp :: :: Spine :: Spine_
  {{ com spine elaboration: given $[[CLNnR]]$, arguments $[[spine]]$ and function type $[[norm_fun]]$ elaborate (via $[[out_res_bind]]$ ) to $[[spine']]$ and result type $[[out_norm_ret]]$ , with $[[out_nRp]]$ leftover }} by

    -------------------------------------------------------------- :: Empty
    C ; L ; N ; nR |- :; norm_ret ~> bind cdot for and norm_ret -| nR


    C |- pval => base_type
    C ; L ; N ; nR |- spine :; pval / x  ( norm_fun ) ~> bind res_bind for spine' and norm_ret -| nR'
    ---------------------------------------------------------------------------------------------------------------- :: Comp
    C ; L ; N ; nR |- pval , spine :; pi x : base_type . norm_fun ~> bind res_bind for pval , spine' and norm_ret -| nR'


    N ; nR |- norm_res ~> bind res_bind for res_term and oarg -| nR'
    C ; L ; N ; nR' |- spine :; norm_fun ~> bind res_bind' for spine' and norm_ret -| nR''
    ------------------------------------------------------------------------------------------- :: Take
    C ; L ; N ; nR |- spine :; forall y : base_type . norm_res --o norm_fun ~> bind res_bind , res_bind' for oarg , res_term , spine' and norm_ret -| nR''


    smt ( N => term )
    C ; L ; N ; nR |- spine :; norm_fun ~> bind res_bind for spine' and norm_ret -| nR'
    ------------------------------------------------------------------------------------------- :: Phi
    C ; L ; N ; nR |- spine :;  term -) norm_fun ~> bind res_bind for spine' and norm_ret -| nR'


defns
  elab_expr :: 'Elab_' ::=

  defn CLNnR |- expr ~> bind out_res_bind for expr' : out_ret -| out_nRp :: :: Expr :: Expr_
  {{ com (effectful) expression elaboration: given $[[CLNnR]]$, $[[expr]]$ elaborates (via $[[out_res_bind]]$) to $[[expr']] [[:]] [[out_ret]]$, with $[[out_nRp]]$ leftover }} by


    C ; L ; N |- pexpr => pure_ret
    ---------------------------------------------------------------------------- :: Pure
    C ; L ; N ; nR |- pure ( pexpr ) ~> bind cdot for pure ( pexpr ) : pure_ret -| nR


    C ; L ; N ; nR |- action ~> bind res_bind for res_term & norm_ret -| nR'
    --------------------------------------------------------------------------- :: Action
    C ; L ; N ; nR |- _rest | action ~> bind res_bind for res_term | action : norm_ret -| nR'


    C ; L ; N ; nR |- memop ~> bind res_bind for res_term & norm_ret -| nR'
    ------------------------------------------------------------------------- :: Memop
    C ; L ; N ; nR |- _rest | memop ~> bind res_bind for res_term | memop : norm_ret -| nR'


    % </ C ; L ; N ; nRi |- stmti <= reti // i />
    % -------------------------------------------------------------------------------------------- :: Unseq
    % C ; L ; N ; </ nRi // i /> |- unseq ( </ stmti : reti // i /> ) => concat </ reti // i />


    P ( id ) = </ xi // i /> |-> stmt : norm_fun
    C ; L ; N ; nR |- spine :; norm_fun ~> bind res_bind for </ spine_elemi // i /> and norm_ret -| nR'
    ---------------------------------------------------------------------------------------------------------------- :: CCall
    C ; L ; N ; nR |- ccall ( ct , id , spine ) ~> bind res_bind for ccall ( ct , id , </ spine_elemi // i /> ) : norm_ret -| nR'


    P ( name ) = </ xi // i /> |-> stmt : norm_fun
    C ; L ; N ; nR |- spine :; norm_fun ~> bind res_bind for </ spine_elemi // i /> and norm_ret -| nR'
    ------------------------------------------------------------------------------------------------------------------ :: Proc
    C ; L ; N ; nR |- pcall ( name , spine ) ~> bind res_bind for pcall ( name , </ spine_elemi // i /> ) : norm_ret -| nR'


    P ( a ) = </ xi : base_typei // i  /> , _ : _bt |-> res
    indexed </ C |- pvali => base_typei // i />
    N ; nR |- [ </ pvali / xi // i /> ] ( res ) ~> bind res_bind for res_term and oarg -| nR'
    pred def= a ( </ inj pvali // i /> ) ( oarg )
    ---------------------------------------------------------------------------------------------------------- :: Fold
    C ; L ; N ; nR |- fold a ( </ pvali // i /> ) ~> bind res_bind for fold res_term : pred : pred *o I -| nR''


    P ( a ) = </ xi : base_typei // i  /> , _ : _bt |-> res
    indexed </ C |- pvali => base_typei // i />
    N ; nR |- a ( </ inj pvali // i /> ) ~> bind res_bind for res_term and oarg -| nR'
    res' def= [ oarg / y , </ iargi / xi // i /> ] ( res )
    ------------------------------------------------------------------------------------------------ :: Unfold
    C ; L ; N ; nR |- unfold a ( </ pvali // i /> ) ~> bind res_bind , fold ( r ) : a ( </ inj pvali // i /> ) ( oarg ) = res_term for r : res' *o I -| nR'


defns
  elab :: 'Elab_' ::=

  defn N |- res ~> out_res_pat :: :: Res_Pat :: Res_Pat_
  {{ com resource type normalisation by pattern-matching: under constraints $[[N]]$ , $[[res]]$ will produce a normalised resourced context if it matches against $[[out_res_pat]]$ }} by


    ---------------- :: Empty
    N |- emp ~> emp

    ----------------- :: Phi
    N |- term ~> TERM


    smt ( N => term )
    N |- res1 ~> res_pat
    ---------------------------------------------- :: If_True
    N |- if term then res1 else res2 ~> res_pat


    smt ( N => neg term )
    N |- res2 ~> res_pat
    ---------------------------------------------- :: If_False
    N |- if term then res1 else res2 ~> res_pat


    ------------- :: Var
    N |- norm_res ~> r


    N |- res1 ~> res_pat1
    N |- res2 ~> res_pat2
    ------------------------------------------------ :: SepConj
    N |- res1 * res2 ~> < res_pat1 , res_pat2 >


    N |- x / y ( res ) ~> res_pat
    ------------------------------------------------------ :: Pack
    N |- exists y : base_type . res ~> pack ( x , res_pat )



  defn N |- ret ~> out_ret_pat :: :: Ret_Pat :: Ret_Pat_
  {{ com return type normalisation by pattern-matching: under constraints $[[N]]$ , $[[ret]]$ will produce a normalised resourced context if it matches against $[[out_ret_pat]]$ }} by

  --------- :: I
  N |- I ~>


  N |- res ~> res_pat
  N |- ret ~> ret_pat
  ------------------------------------------------------------ :: Res
  N |- res *o ret ~> reso res_pat , ret_pat


  N |- ret ~> ret_pat
  ------------------------------------------------------------ :: Log
  N |- exists x : base_type . ret ~> log x , ret_pat


  defn N ; nR ~> out_res_bind :: :: Simp_Ctx :: Simp_Ctx_
  {{ com partial-simplification of resource context: given $[[N]]; [[nR]]$ can partially simplify the resources using $[[out_res_bind]]$ }} by

    ---------------- :: Empty
    N ; cdot ~> cdot

    N |- simp ( norm_res ) ~> res'
    N |- res' ~> res_pat
    N ; nR ~> res_bind
    ----------------------------------------------------------- :: Simp
    N ; nR , x : norm_res ~> res_bind , res_pat : res' = x


    N |- simp ( res ) ~> None
    N ; nR ~> res_bind
    --------------------------------- :: Skip
    N ; nR , _ : norm_res ~> res_bind


  % DEFER out_stmt
  defn CLNnR |- stmt <= norm_ret ~> stmt' :: :: Stmt :: Stmt_
  {{ com (effectful) expression elaboration: given $[[CLNnR]]$, $[[stmt]]$ elaborates to $[[stmt']]$ }} by


    C ; L ; N ; nR |- ret_terms :; to_fun norm_ret ~> bind res_bind for ret_terms' and I -| nR'
    ----------------------------------------------------------------------------------------- :: RetT
    C ; L ; N ; nR |- < ret_terms > <= norm_ret ~> insert_lets ( res_bind , < ret_terms' > )


    ---------------------------------------------------------------- :: Pure
    C ; L ; N ; nR |- pure ( pstmt ) <= pure_ret ~> pure ( pstmt )


    C ; L ; N ; nR |- expr ~> bind res_bind for expr' : ret -| nR'
    N |- ret ~> ret_pat
    N |- ret_pat : sigma y : base_type . ret ~> C1 ; L1 ; N1 ; nR1
    C , C1 ; L , L' , L1 ; N , N' , N1 ; nR' , nR1 |- stmt <= norm_ret2 ~> stmt'
    stmt'' def= insert_lets ( res_bind , let ret_pat = expr' in stmt' )
    ---------------------------------------------------------------------------------------- :: Let
    C ; L ; N ; nR |- let _ret_pat = expr in stmt <= norm_ret2 ~> stmt''


    C ; L ; N ; nR' |- stmt1 <= norm_ret1 ~> stmt1'
    N |- norm_ret1 ~> ret_pat
    N |- ret_pat : norm_ret1 ~> C1 ; L1 ; N1 ; nR1
    C , C1 ; L , L1 ; N , N1 ; nR , nR1 |- stmt2 <= norm_ret2 ~> stmt2'
    stmt'' def= let ret_pat : norm_ret1 = stmt1' in stmt2'
    ---------------------------------------------------------------------- :: Annot
    C ; L ; N ; nR' , nR |- let _ret_pat : norm_ret1 = stmt1 in stmt2 <= norm_ret2 ~> stmt''


    C |- pval => bool
    N , inj pval = true ; nR ~> res_bind1
    C ; L ; N , inj pval = true  ; nR1 |- insert_lets ( res_bind1 , stmt1 ) <= norm_ret ~> stmt1'
    N , inj pval = false ; nR2 ~> res_bind2
    C ; L ; N , inj pval = false ; nR2 |- insert_lets ( res_bind2 , stmt2 ) <= norm_ret ~> stmt2'
    ------------------------------------------------------------------------- :: If
    C ; L ; N ; nR |- if pval then stmt1 else stmt2 <= norm_ret ~> if pval then stmt1' else stmt2'


    C |- pval => base_type1
    indexed pati : base_type1 ~> Ci with termi
    indexed </ N , termi = inj pval ; nR ~> res_bindi // i />
    indexed </ C , Ci ; L ; N , termi = inj pval ; nR |- insert_lets ( res_bindi , stmti ) <= norm_ret ~> stmt'i // i />
    ------------------------------------------------------------------------------------------------------ :: Case
    C ; L ; N ; nR |- case pval of </ | pati => stmti // i /> end <= norm_ret ~> case pval of </ | pati => stmt'i // i /> end


    P ( id ) = </ xi // i /> |-> stmt : norm_fun
    C ; L ; N ; cdot |- </ xi = pvali // i /> :; norm_fun >> subs ; false /\ I
    ----------------------------------------------------------------------------- :: Run
    C ; L ; N ; cdot |- run id </ pvali // i /> <= false /\ I ~> run id </ pvali // i />
