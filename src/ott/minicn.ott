grammar

  declaration, decl :: '' ::= {{ com variable declaration }}
    | ct id ;       ::    :: decl

  declarations, decls :: '' ::= {{ com variable declarations }}
    | decl1 .. decli  ::    :: decls

  lvalue_expression, lve :: 'Lve_' ::= {{ com lvalue expression }}
    | n     ::  :: constant    {{ com constant }}
    | id    ::  :: var         {{ com variable }}
    | * lve ::  :: indirect    {{ com indirection }}

  expression, e :: 'E_' ::=                                      {{ com expression }}
    | n                   ::   :: constant    {{ com constant }}
    | id                  ::   :: var         {{ com variable }}
    | & id                ::   :: address     {{ com address of variable }}
    | * e                 ::   :: unary_star  {{ com unary operator -- deref}}
    | ! e                 ::   :: unary_not   {{ com unary operator -- not}}
    | e1 binop e2         ::   :: binary      {{ com binary operator }}
    | lve = e             ::   :: assign      {{ com assignment }}
    | if ( e ) e1 else e2 ::   :: if          {{ com conditional }}
    | e ; e'              ::   :: seq         {{ com sequencing }}
    | id ( e1 , .. , ek ) ::   :: call        {{ com function call }}
    | block               ::   :: block       {{ com block }}
    | return e            ::   :: return      {{ com function return }}
    | ( e )               :: S :: parens

  block :: 'B_' ::= {{ com block }}
    | { decls e } :: :: block

  function_definition, func :: 'F_' ::= {{ com function definition }}
    | ct id ( ct1 id1 , .. , ctk idk ) function_spec block ::  :: funcD

  program, P :: 'P_' ::= {{ com program }}
    | spec_decls decls func1 .. funcj                    :: :: prog

  function_spec :: 'FSP_' ::= {{ com spec }}
    | /*@ requires spec1 ensures y . spec2 @*/ :: P :: spec

  spec_function_def :: 'SF_' ::= {{ com spec language function definition }}
     | function bty id ( base_type1 x1 , .. , base_typek xk ) { term } :: :: func

  spec_decls :: 'SD_' ::=
     | </ spec_function_defi // i /> </ spec_predicate_defj // j /> :: :: decls

  minicn_extra :: mincn_extra_ ::=
    | P ( id ) = func               ::  :: P_lookup
    | P ( id ) = spec_predicate_def ::  :: P_lookup_pred
    | neg ( minicn_extra )          ::  :: not
    | id inEnv Vc                   ::  :: lookup_var_in_context
    | Rc = Rc'                      ::  :: eq_resources
    | Rc , Phi => term              ::  :: smt_proof {{ com $[[term]]$ is provable by SMT solver with constraints $[[Phi]]$ and disjointness information $[[Rc]]$ }}
    | Phi = Phi'                    ::  :: eq_constraints
    | Vc = Vc'                      ::  :: eq_variable_contexts
    | mres = mres'                  ::  :: eq_mres

  variable_context, Vc {{ tex \Gamma }} :: 'V_' ::= {{ com variable context }}
    | cdot            ::   :: empty {{ com empty variable context }}
    | id              ::   :: var   {{ com singleton context with $[[id]]$ }}
    | Vc1 , ... , Vci ::   :: union {{ com union of variable contexts }}
    | [ Vc ]          :: S :: parens

  constraint_context, Phi {{ tex \Phi }} :: 'Phi_' ::= {{ com constraint context }}
    | cdot                       ::   :: empty {{ com empty constraint context }}
    | term                       ::   :: term  {{ com singleton context with $[[term]]$ }}
    | Phi1 /\ ... /\ Phii        ::   :: union {{ com conjunction of constraint contexts }}
    | cond ( term , Phi , Phi' ) ::   :: cond  {{ com if $[[term]]$ then $[[Phi]]$ else $\cdot$ }}
    | ( Phi )                    :: S :: parens

  conditional_resource , cond_res  :: 'CondRes_' ::= {{ com conditional typing resource }}
    | id = spec  ::   :: id_spec {{ com for specs which return a value }}
    | spec       ::   :: spec    {{ com for specs which don't return a value }}
    | Rc         ::   :: cond    {{ com resource contexts  }}

  typing_resource, mres :: 'Res_' ::= {{ com typing resources }}
    | term |-> term'                        ::   :: owned {{ com ownership of $[[term']]$ mapping to $[[term']]$ }}
    | cond ( term , cond_res1 , cond_res2 ) ::   :: cond {{ com if $[[term]]$ then $[[cond_res1]]$ else $[[cond_res2]]$ }}

  resource_context, Rc {{ tex \mathcal{ R } }} :: 'Rc_' ::= {{ com resource context }}
    | cdot           ::   :: empty
    | mres           ::   :: res
    | Rc1 * .. * Rci ::   :: star  {{ com TODO - we need to simplify before deconstructing }}
    | ( Rc )         :: S :: parens

  done_or_rerun {{ tex ( \cnkw{done} \mid \cnkw{rerun} ) }} :: 'DoR_' ::= {{ com for use resoruce simplification }}
    | done  :: :: done
    | rerun :: :: rerun

defns

  mini :: 'Mini_' ::=

  defn P , Vc , Rc , Phi |- expand ( cond_res ) ~> Vc' , Rc' , Phi' :: :: CondRes_ :: CondRes_
  {{ com given definitions in program $[[P]]$, variables $[[Vc]]$, resources $[[Rc]]$ and constraints $[[Phi]]$, expand conditional resource $[[cond_res]]$ into $[[Vc']] , [[Rc']] , [[Phi']]$ }} by

    ---------------------------------------------------- :: Emp
    P , Vc , Rc , Phi |- expand ( Rc' ) ~> cdot , Rc' , cdot


    P , Vc , Rc , Phi |- cdot , cdot | spec ~> return term , Vc' , Rc' , Phi'
    ------------------------------------------------------------------------------- :: Id_Spec
    P , Vc , Rc , Phi |- expand ( id = spec ) ~> Vc' , Rc' , Phi' /\ ( id = term )


    P , Vc , Rc , Phi |- cdot , cdot | spec ~> cdot , Vc' , Rc' , Phi'
    ---------------------------------------------------------------- :: Spec
    P , Vc , Rc , Phi |- expand ( spec ) ~> Vc' , Rc' , Phi'


  defn  P , Vc , Rc , Phi |- simplify ( Rc' ) ~> done_or_rerun , Vc' , Rc'' , Phi' :: :: Res_ :: Res_
  {{ com given definitions in program $[[P]]$, variables $[[Vc]]$, resources $[[Rc]]$ and constraints $[[Phi]]$, simplify resources $[[Rc']]$ and produce contexts $[[Vc']] , [[Rc'']] , [[Phi']]$ (try expand any conditional resources in the context, re-run if any expanded) }} by


   ------------------------------------------------------------- :: Emp
    P , Vc , Rc , Phi |- simplify ( cdot ) ~>  done , cdot , cdot , cdot


    P , Vc , Rc , Phi |- simplify ( Rc' ) ~> done_or_rerun , Vc' , Rc'' , Phi'
    -------------------------------------------------- :: Owned
    P , Vc , Rc , Phi |- simplify ( ( term |-> term' ) * Rc' ) ~> done_or_rerun , Vc' ,  ( term |-> term' ) * Rc'' , Phi'


    Rc , Phi => term
    P , Vc , Rc , Phi |- expand ( cond_res1 ) ~> Vc' , Rc1 , Phi'
    P , Vc , Rc , Phi |- simplify ( Rc' ) ~> done_or_rerun , Vc'' , Rc'' , Phi''
    -------------------------------------------------- :: Cond_True
    P , Vc , Rc , Phi |- simplify ( cond ( term , cond_res1 , cond_res2 ) *  Rc' ) ~> rerun , [ Vc' , Vc'' ] ,  Rc1 * Rc'' , Phi' /\ Phi''


    Rc , Phi => neg term
    P , Vc , Rc , Phi |- expand ( cond_res2 ) ~> Vc' , Rc2 , Phi'
    P , Vc , Rc , Phi |- simplify ( Rc' ) ~> done_or_rerun , Vc'' , Rc'' , Phi''
    -------------------------------------------------- :: Cond_False
    P , Vc , Rc , Phi |- simplify ( cond ( term , cond_res1 , cond_res2 ) *  Rc' ) ~> rerun , [ Vc' , Vc'' ] ,  Rc2 * Rc'' , Phi' /\ Phi''


    neg ( Rc , Phi => term ) neg ( Rc , Phi => neg term )
    P , Vc , Rc , Phi |- simplify ( Rc' ) ~> done_or_rerun , Vc'' , Rc'' , Phi''
    -------------------------------------------------- :: Cond_Undet
    P , Vc , Rc , Phi |- simplify ( cond ( term , cond_res1 , cond_res2 ) *  Rc' ) ~> done_or_rerun , Vc'' ,  cond ( term , cond_res1 , cond_res2 ) * Rc'' , Phi''


 defn P , Vc , Rc , Phi |- simplify ( Vc' , Rc' , Phi' ) ~> Vc'' , Rc'' , Phi'' :: :: SimpRes_ :: SimpRes_
 {{ com given definitions in program $[[P]]$, variables $[[Vc]]$, resources $[[Rc]]$ and constraints $[[Phi]]$, repeatedly simplify $[[Vc']], [[Rc']], [[Phi']]$ until no change, and produce contexts $[[Vc'']] , [[Rc'']] , [[Phi'']]$ }} by


    P , [ Vc , Vc' ] , Rc * Rc' , Phi /\ Phi' |- simplify ( Rc * Rc' ) ~> done , cdot , Rc * Rc' , cdot
    ---------------------------------------------------------------------- :: Done
    P , Vc , Rc , Phi |- simplify ( Vc' , Rc' , Phi' ) ~> Vc' , Rc' , Phi'


    P , [ Vc , Vc' ] , Rc * Rc' , Phi /\ Phi' |- simplify ( Rc * Rc' ) ~> rerun , Vc1 , Rc1 , Phi1
    P , Vc , Rc , Phi |- simplify ( [ Vc' , Vc1 ] , Rc' * Rc1 , Phi' /\ Phi1 ) ~> Vc'' , Rc'' , Phi''
    ---------------------------------------------------------------------- :: Rerun
    P , Vc , Rc , Phi |- simplify ( Vc' , Rc' , Phi' ) ~> Vc'' , Rc'' , Phi''


  defn  P , Vc , Rc , Phi |- Vc' , Rc' , Phi' | spec -| sval , Vc'' , used ( Rc1 ) * Rc2 , Phi'' :: :: Prove_ :: Prove_
  {{ com given definitions in program $[[P]]$, variables $[[Vc]]$, resources $[[Rc]]$ and constraints $[[Phi]]$ (and accumulating contexts $[[Vc']], [[Rc']], [[Phi']]$) prove $[[spec]]$ and evaluate it to $[[sval]]$, with $[[Rc1]]$ as used, and new contexts $[[Vc']] , [[Rc2]] , [[Phi']]$ }} by

    ------------------------------------------------------ :: Val
    P , Vc , Rc , Phi |- Vc' , Rc' , Phi' | sval -| sval , Vc' , used ( Rc' ) * Rc , Phi'


    P , [ Vc , Vc' ]  , Rc , Phi /\ Phi' |- simplify ( cdot , Rc , cdot ) ~> Vc1 , Rc1 , Phi1
    Rc1 = Rc1' * id1 |-> id2
    Rc1 , Phi /\ Phi1 => term = id1
    ---------------------------------------------------------------------------- :: Owned
    P , Vc , Rc , Phi |- Vc' , Rc' , Phi' | Owned < Init , int > ( term ) -| return id2 , [ Vc1 , Vc' ] , used ( Rc' * ( id1 |-> id2 ) ) * Rc1' , Phi1 /\ Phi'


    P ( yf ) = predicate base_type yf ( base_type1 id1 , .. , base_typek idk ) { spec }
    Vc1 = [ id1 , .. , idk , Vc' ]
    Phi1 = ( Phi' /\ id1 = term1 /\ .. /\ idk = termk )
    P , Vc , Rc , Phi |- Vc1 , Rc' , Phi1 | spec -| return term , Vc2 , used ( Rc1 ) * Rc2 , Phi2
    --------------------------------------------------------------------------- :: Pred
    P , Vc , Rc , Phi |- Vc' , Rc' , Phi' | yf ( term1 , .. , termk ) -| return term , Vc2 , used ( Rc1 ) * Rc2 , Phi2


    P , [ Vc , Vc' ]  , Rc , Phi /\ Phi' |- simplify ( cdot , Rc , cdot ) ~> Vc1 , Rc1 , Phi1
    Rc1 , Phi /\ Phi1  /\ Phi'=> term
    P , Vc , Rc , Phi |- [ Vc1 , Vc' ] , Rc' , Phi' /\ Phi1 | spec -| sval , Vc'' , used ( Rc1 ) * Rc2 , Phi''
    ------------------------------------------------------------ :: Assert
    P , Vc , Rc , Phi |- Vc' , Rc' , Phi' | assert ( term ) ; spec -| sval , Vc'' , used ( Rc1 ) * Rc2 , Phi''


    P , Vc , Rc , Phi |-  [ id , Vc' ] , Rc' , Phi' /\ id = term | spec -| sval , Vc'' , used ( Rc1 ) * Rc2 , Phi''
    ---------------------------------------------------------------------------------- :: Let
    P , Vc , Rc , Phi |- Vc' , Rc', Phi' | let id = term ; spec -| sval , Vc'' , used ( Rc1 ) * Rc2 , Phi''


    P , Vc , Rc , Phi |- Vc1 , Rc1 ,  Phi1 | spec -| return term , Vc2 , used ( Rc21 ) * Rc22 , Phi2
    P , Vc , Rc22 , Phi |- [ id, Vc2 ] , Rc21 , ( Phi2 /\ id = term ) | spec' -| sval , Vc3 , used ( Rc31 ) * Rc32 , Phi3
    --------------------------------------------------------------------------- :: Take
    P , Vc , Rc , Phi |- Vc1 , Rc1 , Phi1 | take id = spec ; spec' -| sval , Vc3 , used ( Rc31 ) * Rc32 , Phi3


    P , [ Vc , Vc' ]  , Rc , Phi /\ Phi' |- simplify ( cdot , Rc , cdot ) ~> Vc1 , Rc1 , Phi1
    Rc1 , Phi /\ Phi' /\ Phi1 => term
    P , Vc , Rc , Phi |- [ Vc1 , Vc' ] , Rc' ,  Phi' /\ Phi1 | spec1 -| sval , Vc'' , used ( Rc''1 ) * Rc''2 , Phi''
    ------------------------------------------------------------------------------ :: If_True
    P , Vc , Rc , Phi |- Vc' , Rc' , Phi' | if ( term ) { spec1 } else { spec2 } -| sval , Vc'' , used ( Rc''1 ) * Rc''2 , Phi''


    P , [ Vc , Vc' ]  , Rc , Phi /\ Phi' |- simplify ( cdot , Rc , cdot ) ~> Vc1 , Rc1 , Phi1
    Rc1 , Phi /\ Phi' /\ Phi1 => term
    P , Vc , Rc , Phi |- [ Vc1 , Vc' ] , Rc' ,  Phi' /\ Phi1 | spec2 -| sval , Vc'' , used ( Rc''1 ) * Rc''2 , Phi''
    ------------------------------------------------------------------------------ :: If_False
    P , Vc , Rc , Phi |- Vc' , Rc' , Phi' | if ( term ) { spec1 } else { spec2 } -| sval , Vc'' , used ( Rc'' ) * Rc''2 , Phi''


    P , [ Vc , Vc' ]  , Rc , Phi /\ Phi' |- simplify ( cdot , Rc , cdot ) ~> Vc1 , Rc1 * mres , Phi1
    mres = cond ( term , id = spec1 , id = spec2 )
    neg ( Rc1 * mres , Phi /\ Phi' /\ Phi1 => term ) neg ( Rc , Phi /\ Phi' /\ Phi1 => neg term )
    ------------------------------------------------------------------------------ :: Ret_If
    P , Vc , Rc , Phi |- Vc' , Rc' , Phi' | if ( term ) { spec1 } else { spec2 } -| return id , [ Vc' , Vc1 ] , used ( Rc' * mres ) * Rc1 , Phi' /\ Phi1


    P , [ Vc , Vc' ]  , Rc , Phi /\ Phi' |- simplify ( cdot , Rc , cdot ) ~> Vc1 , Rc1 * mres , Phi1
    mres = cond ( term , spec1 , spec2 )
    neg ( Rc1 * mres , Phi /\ Phi' /\ Phi1 => term ) neg ( Rc , Phi /\ Phi' /\ Phi1 => neg term )
    ------------------------------------------------------------------------------ :: NoRet_If
    P , Vc , Rc , Phi |- Vc' , Rc' , Phi' | if ( term ) { spec1 } else { spec2 } -| cdot , [ Vc' , Vc1 ] , used ( Rc' * mres ) * Rc1 , Phi' /\ Phi1


  defn  P , Vc , Rc , Phi |- Vc' , Phi' | spec ~> sval , Vc'' , Rc'' , Phi'' :: :: Assume_ :: Assume_
  {{ com given definitions in program $[[P]]$, variables $[[Vc]]$, resources $[[Rc]]$ and constraints $[[Phi]]$, (and accumulating contexts $[[Vc']]$ and $[[Phi']]$) assume $[[spec]]$ and evaluate it to $[[sval]]$, with new context $[[Vc'']], [[Rc'']], [[Phi'']]$ }} by

    ------------------------------------------------------ :: Value
    P , Vc , Rc , Phi |- Vc' , Phi' | sval  ~>  sval  , Vc' , Rc ,  Phi'


    P , Vc , Rc , Phi |- Vc' , Phi' /\ term | spec ~> sval , Vc'' , Rc' , Phi''
    --------------------------------------------------------------- :: Assert
    P , Vc , Rc , Phi |- Vc' , Phi' | assert ( term ) ; spec ~> sval , Vc'' , Rc' , Phi''


    P , Vc , Rc , Phi |- [ id, Vc' ] , Phi' /\ id = term | spec ~> sval ,  Vc'' , Rc' , Phi''
    ------------------------------------------------------- :: Let
    P , Vc , Rc , Phi |- Vc' , Phi' | let id = term; spec ~> sval , Vc'' , Rc' , Phi''


    -------------------------------------------------------------------- :: Owned
    P , Vc , Rc , Phi |- Vc' , Phi' | Owned < Init , int > ( term ) ~> return id , [ id , Vc' ] ,  term |-> id * Rc , Phi'


    P ( yf ) = predicate base_type yf ( base_type1 id1 , .. , base_typek idk ) { spec }
    Vc1 = [ id1 , .. , idk , Vc' ]
    Phi1 = ( id1 = term1 /\ .. /\ idk = termk /\ Phi' )
    P , Vc , Rc , Phi |- Vc1 , Phi1 | spec ~> return term , Vc'' , Rc' , Phi''
    ---------------------------------------------------------------------------------- :: Pred
    P , Vc , Rc , Phi |- Vc' , Phi' | yf ( term1 , .. , termk ) ~> sval , Vc'' , Rc' , Phi''


    P , Vc , Rc  , Phi |- Vc1 , Phi1 | spec ~> return term   , Vc2 , Rc2 , Phi2
    P , Vc , Rc2 , Phi |- Vc2 , Phi2 | spec    ~> sval , Vc3 , Rc3 , Phi3
    ---------------------------------------------------------------------------------- :: Take
    P , Vc , Rc , Phi |- Vc1 , Phi2 | take id = spec ; spec ~> sval , Vc3 , Rc3 , Phi3


    P , [ Vc , Vc' ]  , Rc , Phi /\ Phi' |- simplify ( cdot , Rc , cdot ) ~> Vc1 , Rc1 , Phi1
    Rc1 , Phi /\ Phi' /\ Phi1 => term
    P , Vc , Rc , Phi  |- [ Vc1 , Vc' ] , Phi' /\ Phi1 | spec1 ~> sval1 , Vc'' , Rc' , Phi''
    -------------------------------------------------------------- :: If_True
    P , Vc , Rc , Phi |- Vc' , Phi' | if ( term ) { spec1 } else { spec2 } ~> sval1 , Vc'' , Rc' , Phi''


    P , [ Vc , Vc' ]  , Rc , Phi /\ Phi' |- simplify ( cdot , Rc , cdot ) ~> Vc1 , Rc1 , Phi1
    Rc1 , Phi /\ Phi' /\ Phi1 => neg term
    P , Vc , Rc , Phi  |- [ Vc1 , Vc' ] , Phi' /\ Phi1 | spec2 ~> sval2 , Vc'' , Rc' , Phi''
    -------------------------------------------------------------- :: If_False
    P , Vc , Rc , Phi |- Vc' , Phi' | if ( term ) { spec1 } else { spec2 } ~> sval2 , Vc'' , Rc' , Phi''


    P , [ Vc , Vc' ]  , Rc , Phi /\ Phi' |- simplify ( cdot , Rc , cdot ) ~> Vc1 , Rc1 , Phi1
    neg ( Rc1 , Phi /\ Phi' /\ Phi1 => term ) neg ( Rc1 , Phi /\ Phi' /\ Phi1 => neg term )
    mres = cond ( term , id = spec1 , id = spec2 )
    ------------------------------------------------------------------------------ :: Ret_If
    P , Vc , Rc , Phi |- Vc' , Phi' | if ( term ) { spec1 } else { spec2 } ~> return id , [ id , Vc1 , Vc' ] , Rc1 * mres , Phi1 /\ Phi'


    P , [ Vc , Vc' ]  , Rc , Phi /\ Phi' |- simplify ( cdot , Rc , cdot ) ~> Vc1 , Rc1 , Phi1
    neg ( Rc1 , Phi /\ Phi' /\ Phi1 => term ) neg ( Rc1 , Phi /\ Phi' /\ Phi1 => neg term )
    mres = cond ( term , spec1 , spec2 )
    ------------------------------------------------------------------------------ :: NoRet_If
    P , Vc , Rc , Phi |- Vc' , Phi' | if ( term ) { spec1 } else { spec2 } ~> cdot , [ Vc1 , Vc' ] , Rc1 * mres , Phi1 /\ Phi'


 defn Vc , Rc , Phi |-lv lve -| id inEnv Vc' ,  Rc' , Phi' :: :: Lve_ :: Lve_
 {{ com given variables $[[Vc]]$, resources $[[Rc]]$ and constraints $[[Phi]]$, symbolically evaluate lvalue-expressions $[[lve]]$ to $[[id]]$ and new context $[[Vc']], [[Rc']], [[Phi']]$ }} by

    ---------------------------------------------------- :: Const
    Vc , Rc , Phi |-lv n -| id inEnv [ id ] , Rc , ( id = n )


    id inEnv Vc
    -------------------------------------------------------- :: Var
    Vc , Rc , Phi |-lv id -| id' inEnv [ id' ] , Rc , ( id' = id )


   % assuming the caller has simplified the resource context
    Vc , Rc , Phi |-lv lve -| id1 inEnv Vc' , Rc' , Phi'
    Rc' = Rc'' * id1' |-> id2'
    Rc' , Phi' => id1 = id1'
    ----------------------------------------------------------------- :: Deref
    Vc , Rc , Phi |-lv * lve -| id2 inEnv [ id2 , Vc' ] , Rc' , ( id2 = id2' /\ Phi' )


 defn  P , Vc , Rc , Phi |- y . spec e -| id inEnv Vc' ,  Rc' , Phi' :: :: Expr_ :: Expr_ {{ tex [[P]] [[,]] [[Vc]] [[,]] [[Rc]] [[,]] [[Phi]] [[|-]]_{ [[y]] [[.]] [[spec]] } [[e]] [[-|]] [[id]] [[inEnv]] [[Vc']] [[,]]  [[Rc']] [[,]] [[Phi']] }}
 {{ com given definitions in program $[[P]]$, variables $[[Vc]]$, resources $[[Rc]]$, constraints $[[Phi]]$ and post-condition $[[spec]]$, expression $[[e]]$ symbolically evaluates to $[[id]]$, with new context $[[Vc']], [[Rc']], [[Phi']]$ }} by


    ---------------------------------------------------- :: Const
    P , Vc , Rc , Phi |- y . spec n -| id inEnv [ id ] , Rc , ( id = n )

    id inEnv Vc
    P , Vc , Rc , Phi |- simplify ( cdot , Rc , cdot ) ~> Vc1 , Rc1 * mres , Phi1
    mres = id' |-> id2'
    Rc1 * mres , Phi /\ Phi1 => id = id'
    --------------------------------- :: Var
    P , Vc , Rc , Phi |- y . spec id -| id2 inEnv [ id2 , Vc1 ] , Rc1 * mres , ( id2 = id2' /\ Phi1 )


    id inEnv Vc
    -------- :: Addr
    P , Vc , Rc , Phi |- y . spec &id -| id' inEnv [ id' ] , Rc , ( id' = id )


    P , Vc , Rc , Phi |- y . spec e -| id inEnv Vc' , Rc' , Phi'
    ----------------------------------------------- :: Not
    P , Vc , Rc , Phi |- y . spec ! e -| id' inEnv [ id' , Vc' ] , Rc , ( id' = ( if id = 0 then 1 else 0 ) /\ Phi' )


    P , Vc , Rc , Phi |- y . spec e -| id inEnv Vc' , Rc' , Phi'
    P , [ Vc , Vc' ] , Rc' , Phi /\ Phi' |- simplify ( cdot , Rc' , cdot ) ~> Vc1 , Rc1 * mres , Phi1
    mres = id' |-> id2'
    Rc1 * mres , Phi /\ Phi' /\ Phi1 => id = id'
    ----------------------------------------------- :: Deref
    P , Vc , Rc , Phi |- y . spec * e -| id2 inEnv [ id2 , Vc1 , Vc' ] , Rc1 * mres , ( id2 = id2' /\ Phi1 /\ Phi' )


    P , Vc , Rc , Phi |- y . spec e1 -| id1 inEnv Vc1 , Rc1 , Phi1
    P , [ Vc , Vc1 ] , Rc1 , Phi /\ Phi1 |- y . spec e2 -| id2 inEnv Vc2 , Rc2 , Phi2
    ------------------------------------------------------------------ :: Binop
    P , Vc , Rc , Phi |- y . spec e1 arith_binop e2 -| id inEnv [ id , Vc1 , Vc2 ] , Rc2 , ( id = ( id1 ' arith_binop ' id2 )  /\ Phi1 /\ Phi2 )


    P , Vc , Rc , Phi |- y . spec e -| id1 inEnv Vc1 , Rc1 , Phi1
    P , [ Vc , Vc1 ] , Rc1 , Phi /\ Phi1 |- simplify ( cdot , Rc1 , cdot ) ~> Vc2 , Rc2 , Phi2
    [ Vc , Vc1 , Vc2 ] , Rc2 , Phi /\ Phi1 /\ Phi2 |-lv lve -| id3 inEnv Vc3 , Rc3 * mres , Phi3
    mres = id3' |-> _
    Rc3 * mres , Phi /\ Phi1 /\ Phi2 /\ Phi3 => id3 = id3'
    ------------------------------------------------------------- :: Assign
    P , Vc , Rc , Phi |- y . spec lve = e -| id inEnv [ id , Vc3, Vc2 , Vc1 ] , Rc3 * mres , ( id = id1 /\ Phi3 /\ Phi2 /\ Phi1 )


    P , Vc , Rc , Phi |- y . spec e1 -| id1 inEnv Vc1 , Rc1 , Phi1
    P , [ Vc , Vc1 ] , Rc1 , Phi /\ Phi1 |- y . spec e2 -| id2 inEnv Vc2 , Rc2 , Phi2
    P , [ Vc , Vc1 ] , Rc1 , Phi /\ Phi1 |- y . spec e3 -| id3 inEnv Vc3 , Rc3 , Phi3
    Rc' = cond ( id1 , Rc2 , Rc3 )
    Phi' = Phi1 /\ cond ( id1 , Phi2 , Phi3 ) /\ ( id = if id1 then id2 else id3 )
    ----------------------------------------------------------------------------------------- :: If
    P , Vc , Rc , Phi |- y . spec if ( e1 ) e2 else e3 -| id inEnv [ id , Vc1 , Vc2 , Vc3 ] , Rc' , Phi'


    P , Vc , Rc , Phi |- y . spec e1 -| id1 inEnv Vc1 , Rc1 , Phi1
    P , [ Vc , Vc1 ] , Rc1 , Phi /\ Phi1 |- y . spec e2 -| id2 inEnv Vc2 , Rc2 , Phi2
    ------------------------------------------------------------------ :: Seq
    P , Vc , Rc , Phi |- y . spec e1 ; e2 -| id inEnv [ id , Vc1 , Vc2 ] , Rc2 , ( id = id2  /\ Phi1 /\ Phi2 )


    Vc0' = Vc0 Vcj' = [ Vcj-1' , Vcj  ] Phi0' = Phi0 Phij' = Phij-1' /\ Phij
    P , Vc0' , Rc0 , Phi0' |- y . spec e1 -| id1 inEnv Vc1 , Rc1 , Phi1 ldots P , Vck-1' , Rck-1 , Phik-1' |- y . spec ek -| idk inEnv Vck , Rck , Phik
    P(yf) = ct yf ( ct1 id1 , .. , ctk idk ) /*@ requires spec1 ensures y' . spec2 @*/ block
    P , Vck' , Rck , Phik' |- cdot , cdot , cdot | spec1 -| cdot , Vc' , used ( Rc1' ) * Rc2' , Phi'
    P , [ Vck' , Vc' ]  , Rc2' , Phik' /\ Phi' |- y' , cdot | spec2 ~> cdot  , Vc'' , Rc3' , Phi''
    ------------------------------------------------------------------ :: Call
    P , Vc0 , Rc0 , Phi0 |- y . spec yf ( e1 , .. , ek ) -| y' inEnv [ Vc1 , .. , Vck , Vc' , Vc'' ] , Rc3' , ( Phi1 /\ .. /\ Phik /\ Phi' /\ Phi'' )


    P , [ Vc , id1 , .. , idk ] , Rc , Phi |- y . spec e -| id1 inEnv Vc1 , Rc1 , Phi1
    -------------------------------------------------------------------------------- :: Block
    P , Vc , Rc , Phi |- y . spec { ct1 id1 ; .. ctk idk ; e } -| id1 inEnv [ id1 , .. , idk , Vc1 ] , Rc1 , Phi1


    P , Vc , Rc , Phi |- y . spec e -| id1 inEnv Vc1 , Rc1 , Phi1
    P , [ Vc , Vc1 , y ] , Rc1 , Phi /\ Phi1 /\ y = id1 |- cdot , cdot , cdot | spec -| cdot , Vc' , used ( Rc' ) * cdot , Phi'
    ------------------------------------------------------------------ :: Return
    P , Vc , Rc , Phi |- y . spec return e -| y inEnv [ y ] , cdot , false
