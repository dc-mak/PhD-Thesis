% vim: ft=tex
\chapter{Soundness}\label{chap:soundness}
\section{Commentary}

Since Core is a first-order language, and we require that all functions and
labels are annotated with the correct type, it suffices to only use purely
syntactic techniques to prove soundness. This remains true despite the
addition of linear types, systems with which are normally proved using logical
relations~\cite{ahmed2007l3}. There are three main components to this: a joint
progress-and-type-preservation proof for resource term reduction, a progress
theorem and a type-preservation theorem.

Let a resource be called \emph{normalised} if it is either a $[[ pred ]]$ or
$[[ ipred ]]$. Let a resource context $[[ nR ]]$ be called normalised if it contains
only normalised resources.  Even though the grammar of resources is richer, we
can, in all the proofs relating to well-typed closed resource terms, assume
the resource context to be normalised. This is fine because of the following
lemma: if a well-typed resource term is closed, then the context in which it is
well-typed can be normalised.

Operational semantics for resource terms happens to be defined using big-step
style; this makes its definition concise and modular, at the cost of making the
proof of soundness of resource term reduction more complicated since it requires
joint progress and type preservation. The configuration for the operational
semantics is a pair of a state -- itself, a allocation history and heap --
and an annotated and let-normalised Core program. This state is tracked in
the typing rules via the initial logical variable context
$[[ L0 ]] = [[ allocv : id_map ]]$, the constraint context $[[ N ]]$ and the resource
context $[[ nR ]]$.

\begin{figure}[t]
\vspace{-\baselineskip}
\small%
\centering
\cnusedrule{\cndruleSubsXXPatXXResXXFold{}}
\cnusedrule{\cndruleOpXXResTXXFold{}}
\end{figure}

An allocation history is a map from allocation IDs to a base address and a length.
A heap is a collection of normalised resources. Predicates in heaps are optionally
tagged with their ``definition'' $[[ def ]]$  (a resource value of the type of
the predicate body) and a sub-heap (of the resources used by the definition).
This is to support folding and unfolding predicates in the operational
semantics, and to capture the idea that predicate encapsulate their contents
until opened.

The types of heaps are normalised contexts; the rules for these are
straightforward, except the fact a heap with a folded predicate requires there
exists a context for which the resource value $[[ def ]]$ and $[[ heap ]]$ is
well-typed. This becomes necessary for proving the progress of pattern-matching
for the whole of the annotated and let-normalised Core.

\begin{theorem}[Progress and type preservation for resource terms]
For all resource terms ($[[ res_term ]]$) closed which type check or synthesise
($[[ cdot ; L0 ; N ; nR |- res_term <= res ]]$), and well-typed states
($[[ alloct ; h <= N ; nR ]]$), there exists a resource value ($[[ res_val ]]$),
context ($[[ nR' ]]$) and heap ($[[ h' ]]$), such that: the value is well-typed
($[[ cdot ; L0 ; N ; nR' |- res_val <= res ]]$); the heap is well-typed
($[[ alloct |- h' <= nR' ]]$), and for all frame-heaps ($[[ f ]]$), the resource term
reduces to the resource value without affecting the frame-heap
($[[ alloct | < h + f ; res_term > ||v < h' + f ; res_val > ]]$).
\end{theorem}

The interesting case in the proof of this is folding a predicate; proving this
case requires a notion of \emph{footprint} of a resource value: the subheap
containing the resources referred to by the value.

\begin{theorem}[Progress for the annotated and let-normalised Core]
If a statement ($[[ stmt ]]$) is well-typed
($[[ cdot ; L0 ; N ; nR |- stmt <= ret ]]$) and all computational patterns
in it are exhaustive, then either it is a value ($[[ < ret_terms > ]]$), or it is
unreachable, or for all well-typed states ($[[ s <= N ; nR ]]$)
then there exists another state ($[[ s' ]]$) and expression ($[[ stmt' ]]$)
which is stepped to ($[[ < s ; stmt > --> < s' ; stmt' > ]]$)
in the operational semantics.
\end{theorem}

The assumption that all computational patterns are exhaustive is justified
because they are generated by Cerberus. As one might expect, proving progress
requires well-typed patterns successfully produce substitutions. However, this
complicated by two things, the solution to which requires the introduction of a
relation on SMT terms and resource types, $[[ res ~ res' ]]$ (to be read
``$[[ res ]]$ is syntactically related to $[[ res' ]]$'').

First is that the constraint term generated when typing a computational
pattern (this is required to record, in the constraint context, which branch the
type system is assuming it is in) is not exactly equal to the values it can
match in the operational semantics (nor would we want it to be: the pattern
$[[ Cons ( x1 , x2 ) ]]$ should match the value
$[[ Cons ( pval1 , Cons ( pval2 , Nil base_type ( ) ) ) ]]$). Hence, we
must weaken the notion of equality on types to $[[ ~ ]]$ relatedness, which
links the two, so that during the proof can substitute the constraint term
$[[ x1 cons x2 ]]$ at the type-level, and maintain a link to the corresponding
value.

Second is that the conditions of related conditional resource must
remain SMT-equivalent (with reference to a constraint context), so that
pattern-match typing and resource term typing are consistent.

\begin{theorem}[Type preservation for the annotated and let-normalised Core]
For all closed and well-typed statements
($[[ cdot ; L0 ; N ; nR |- stmt <= ret ]]$),
well typed states ($[[ alloct ; h <= N ; nR ]]$),
frame-heaps ($[[ f ]]$),
new states ($[[ alloct' ; h' ]]$),
and new statements ($[[ stmt' ]]$),
which are connected by a step in the operational semantics
($[[ < alloct ; h + f ; stmt > -->  < alloct' ; heap ; stmt' > ]]$),
if all functions are annotated correctly,
there exists a constraint context ($[[ N' ]]$),
sub-heap ($[[ h' ]]$),
and resource context ($[[ nR' ]]$),
such that the constraint context is extended
($[[ cdot ; L0 ; N ; cdot [= cdot ; L0 ; N' ; cdot ]]$),
the frame is unaffected ($[[ heap ]] = [[ h' + f ]]$),
the sub-state is well-typed ($[[ alloct' ; h' <= N' ; nR' ]]$),
and the statement too
($[[ cdot ; L0 ; N' ; nR' |- stmt' <= ret ]]$).
\end{theorem}

A few things are noteworthy about the proof.

First is that a frame-heap has to be explicitly passed around.  Whilst this is
inconvenient, it becomes necessary in the \StmtLet{} case.
% Don't think this applies any more.
% The next is that proof that well-typed spines produce well-typed substitutions
% require quantifying over the substitutions done \emph{so far}, so that the
% inductive case matches up \emph{and} the substitution so far $[[ psi ]]$ shows
% up in the conclusion, `closing' otherwise `open' substitution and terms.

Second is in the lemma~\nameref{subsec:wt_values_pat_match}.
There are two substitutions at play here. As an example, let
the value being matched be $[[ Cons ( Unit , Nil unit ( ) ) , ret_terms ]]$ and
the pattern be $[[ comp Cons ( x1 , x2 ) , ret_pat ]]$.
For the return type $[[ sigma y : list unit . ret ]]$, the type-level
substitution will be $[[ Cons ( x1 , x2 ) / y ( ret )]]$.  However, at the
term-level, the substitution will be $[[ [ Unit / x1 , Nil unit ( ) / x2 ] ]]$.
\emph{Bridging this difference is the main reason for the $[[ ~ ]]$ relation}
(the other is the use of $[[ to_fun ret ]]$).  \emph{The type-level substitution
is open}, and only makes sense with respect to the variables introduced in the
pattern-match.

Lastly, we gather constraints throughout the proof, since these are accumulated
by the typing rules, during pattern-matching, case and if. Given the constraint
context is always well-formed (w.r.t.~to the initial logical variable context
$[[ L0 ]] = [[ allocv : id_map ]]$), this means that after substituting in the
allocation history, all the constraints involve no variables (hence the
substitutions in \HeapTy{} and \AllocTy), and so will be trivially decidable.

\section{Typing Judgements}\label{sec:type_judge}

In this document, $[[ C ; L ; N ; R ]] [[|-]] J$ stands for all \emph{defined}
judgements, listed in the remainder of this section after this paragraph,
except for $[[ C ; L |- term => out_base_type ]]$. Furthermore, I assume that
\lemmaref{sec:weakening} and \lemmaref{subsec:sub} (proven for the
\emph{defined} judgements in the referenced sections) holds for the
$[[ C ; L |- term => out_base_type ]]$) judgement.\\

\cngrammartabular{
\cnresXXjudge\cninterrule%
\cnretXXjudge\cninterrule%
\cnpatXXjudge\cninterrule%
\cnexplXXpure\cninterrule%
\cnexplXXres\cninterrule %
\cnexplXXspine\cninterrule%
\cnexplXXaction\cninterrule%
\cnexplXXmemop\cninterrule%
\cnexplXXstmt\cnafterlastrule%
}

\section{Operational Semantics Judgements}\label{sec:opsem_judge}

\cngrammartabular{
\cnsubsXXjudge\cninterrule%
\cnpureXXopsem\cninterrule%
\cnopsem\cnafterlastrule%
}

\section{Proof Judgements}\label{sec:proof_judge}

Note that the definition of $[[ term ~ term' ]]$ is omitted/assumed.  It simply
means that $[[ term ]]$ and $[[ term' ]]$ can be unified. Informally,
$[[ term ~ term' ]]$ are defined recursively over the structure of SMT terms,
using the standard definition of unification: variables unify with anything
(modulo an occurs check), atoms unify if they are identical, compound terms
unify if their constructors and arity are
identical, and their arguments unify recursively.\\

\noindent
$[[ ~ ]]$ is additionally assumed to be an equivalence relation and preserved by
substitution: if $[[ term ~ term' ]]$ and $[[ x ~ y ]]$ in $[[ term1 ~ term1' ]]$
then $[[ term / x ( term1 ) ~ term' / y ( term1' ) ]]$.\\

\noindent
\textbf{Note: $[[ ~ ]]$ is \emph{only} used in the \emph{proof} of soundness,
and \emph{not} in the \emph{explicit CN type system}.} There is no unification
required in the type system, but the notion of related terms is required to
argue for the soundness of pattern-matching
(Section~\ref{subsec:wt_values_pat_match}~\nameref{subsec:wt_values_pat_match}).\\

\cngrammartabular{
\cnmiscXXextra\cninterrule%
\cnproofXXdefns\cnafterlastrule%
}

\raggedright%

\section{Groups of Rules}

\subsection{Typing rules with an \texorpdfstring{$[[smt ( N => qterm) ]]$}{smt ( Φ ⇒ qterm )} premise}\label{subsec:smt_premise_rules}

\IGCmpEq, \IGCmpLt, \IGCmpGt, \ICmpIGNeq, \ICmpIArgNeq,
\ICmpComparable, \ReqEqPPIArgNeq, \ReqEqPPEq, \ResEqPhi, \ResEqOrdDisj,
\ResSimpRecIfTrue, \ResSimpRecIfFalse, \RetEqPhi, \PatResMatchIfTrue,
\PatResMatchIfFalse, \PureExprArrayShift, \PureExprMemberShift,
\PureExprAssertUndef, \PureStmtPVal, \PureStmtUB,
\ResSynPredOpsCongeal, \ResSynPredOpsImplode,
\ResSynPredOpsBreak, \ResSynPredOpsGlue, \ResSynPredOpsInj, \ResSynPredOpsChop,
\ResChkPhi, \ResChkIfTrue, \ResChkIfFalse, \ActionLoad,
\ActionStore, \ActionKillStatic, \MemopRelBinop,
\MemopPtrDiffArr, \MemopPtrDiff, \MemopIntFromPtr,
\MemopPtrFromInt, \MemopPtrArrayShift.

\subsection{Typing rules which change the context}\label{subsec:ctx_change_rules}

\subsubsection{Rules which add constraints}
\StmtIf.


\subsubsection{Rules which add constraints and computational or logical variables}

\StmtCase.\\

\subsubsection{Rules which restrict the resource context}

No-resource / ``pure'' rules: \IGCmpEq, \IGCmpLt, \IGCmpGt, \IGCmpNone,
\ICmpNameNeq, \ICmpIGNeq, \ICmpIArgNeq, \ICmpComparable,
\ReqEqPPNameNeq, \ReqEqPPIArgNeq, \ReqEqPPEq, \ReqEqIIEq, \ReqEqIINeq,
\ResEqEmp, \ResEqPhi, \ResEqPred, \ResEqIPred, \ResEqSepConj, \ResEqExists,
\ResEqOrdDisj, \ResSimpRecIfTrue, \ResSimpRecIfFalse, \ResSimpRecSepConj,
\ResSimpRecExists, \ResSimpRecNoChange, \SimpNoSimp, \SimpSimp, \RetEqEnd,
\RetEqComp, \RetEqLog, \RetEqPhi, \RetEqRes, \PatCompWild,
\PatCompSym, \PatCompNil, \PatCompCons, \PatCompTuple, \PatCompArray,
\PatResMatchEmp, \PatResMatchPhi, \PatResMatchIfTrue, \PatResMatchIfFalse, \PatResMatchVar,
\PatResMatchSepConj, \PatResMatchPack, \PatResMatchFold, \PatRetEmpty,
\PatRetComp, \PatRetLog, \PatRetRes, \PatRetPhi, \PatRetAux, \PureValObjInt, \PureValObjPtr,
\PureValObjArr, \PureValObjStruct, \PureValVar, \PureValObj,
\PureValUnit, \PureValTrue, \PureValFalse, \PureValList, \PureValTuple,
\PureValCtorNil, \PureValCtorCons, \PureValCtorTuple, \PureValCtorArray,
\PureValStruct, \PureExprPVal, \PureExprCtorIvXOR, \PureExprArrayShift,
\PureExprMemberShift, \PureExprNot, \PureExprArithBinop, \PureExprRelBinop,
\PureExprBoolBinop, \PureExprCall, \PureExprAssertUndef, \PureExprBoolToInteger,
\PureExprWrapI, \PureStmtUB, \PureStmtPVal, \MemopPtrValidForDeref,
\MemopPtrWellAligned, \ExprPure, \StmtPure.\\[\baselineskip]

Resource-mentioning rules: \ResSynEmp, \ResSynVar, \ResSynVarSimp, \ResSynPred,
\ResSynIPred, \ResSynSepConj, \ResChkPhi, \ResChkSepConj, \SpineRet,
\SpineRes, \ActionCreate, \MemopRelBinop,
\MemopPtrDiffArr, \MemopPtrDiff,
\MemopIntFromPtr, \MemopPtrFromInt, \MemopPtrArrayShift,
\StmtRun, \SubsChkEmpty, \SubsChkRes.

\subsubsection{Rules which add constraints and restrict the resource context}
\PureStmtIf.

\subsubsection{Rules which add constraints and variables, and
restrict the resource context}

\PureStmtPExpr, \PureStmtLet, \PureStmtCase, \StmtExpr, \StmtLet.

\subsection{Value typing rules}\label{subsec:value_typing_rules}

\PureValObjInt, \PureValObjPtr, \PureValObjArr, \PureValObjStruct, \PureValVar,
\PureValObj, \PureValUnit, \PureValTrue, \PureValFalse,
\PureValTuple, \PureValCtorNil, \PureValCtorCons, \PureValCtorTuple,
\PureValCtorArray, \PureValStruct, \PureStmtPVal,
\ResSynEmp, \ResSynVar, \ResSynVarSimp, \ResSynPred, \ResSynIPred,
\ResChkPhi, \StmtRetT.

