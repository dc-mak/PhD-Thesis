% vim: ft=tex
% chktex-file 25
% chktex-file 26
% chktex-file 37

\chapter{Soundness}\label{chap:soundness}
\section{Commentary}

Since Core is a first-order language, and we require that all functions and
labels are annotated with the correct type, it suffices to only use purely
syntactic techniques to prove soundness. This remains true despite the
addition of linear types, systems with which are normally proved using logical
relations~\cite{ahmed2007l3}. There are three main components to this: a joint
progress-and-type-preservation proof for resource term reduction, a progress
theorem and a type-preservation theorem.

Let a resource be called \emph{normalised} if it is either a $[[ pred ]]$ or
$[[ ipred ]]$. Let a resource context $[[ nR ]]$ be called normalised if it contains
only normalised resources.  Even though the grammar of resources is richer, we
can, in all the proofs relating to well-typed closed resource terms, assume
the resource context to be normalised. This is fine because of the following
lemma: if a well-typed resource term is closed, then the context in which it is
well-typed can be normalised.

Operational semantics for resource terms happens to be defined using big-step
style; this makes its definition concise and modular, at the cost of making the
proof of soundness of resource term reduction more complicated since it requires
joint progress and type preservation. The configuration for the operational
semantics is a pair of a state -- itself, a allocation history and heap -- % chktex 8
and an annotated and let-normalised Core program. This state is tracked in
the typing rules via the initial logical variable context
$[[ L0 ]] = [[ allocv : id_map ]]$, the constraint context $[[ N ]]$ and the resource
context $[[ nR ]]$.

\begin{figure}[t]
\vspace{-\baselineskip}
\small%
\centering
\cnusedrule{\cndruleSubsXXPatXXResXXFold{}}
\cnusedrule{\cndruleOpXXResTXXFold{}}
\end{figure}

An allocation history is a map from allocation IDs to a base address and a length.
A heap is a collection of normalised resources. Predicates in heaps are optionally
tagged with their ``definition'' $[[ def ]]$  (a resource value of the type of
the predicate body) and a sub-heap (of the resources used by the definition).
This is to support folding and unfolding predicates in the operational
semantics, and to capture the idea that predicate encapsulate their contents
until opened.

The types of heaps are normalised contexts; the rules for these are
straightforward, except the fact a heap with a folded predicate requires there
exists a context for which the resource value $[[ def ]]$ and $[[ heap ]]$ is
well-typed. This becomes necessary for proving the progress of pattern-matching
for the whole of the annotated and let-normalised Core.

\begin{theorem}[Progress and type preservation for resource terms]
For all resource terms ($[[ res_term ]]$) closed which type check or synthesise
($[[ cdot ; L0 ; N ; nR |- res_term <= res ]]$), and well-typed states
($[[ alloct ; h <= N ; nR ]]$), there exists a resource value ($[[ res_val ]]$),
context ($[[ nR' ]]$) and heap ($[[ h' ]]$), such that: the value is well-typed
($[[ cdot ; L0 ; N ; nR' |- res_val <= res ]]$); the heap is well-typed
($[[ alloct |- h' <= nR' ]]$), and for all frame-heaps ($[[ f ]]$), the resource term
reduces to the resource value without affecting the frame-heap
($[[ alloct | < h + f ; res_term > ||v < h' + f ; res_val > ]]$).
\end{theorem}

The interesting case in the proof of this is folding a predicate; proving this
case requires a notion of \emph{footprint} of a resource value: the subheap
containing the resources referred to by the value.

\begin{theorem}[Progress for the annotated and let-normalised Core]
If a statement ($[[ stmt ]]$) is well-typed
($[[ cdot ; L0 ; N ; nR |- stmt <= ret ]]$) and all computational patterns
in it are exhaustive, then either it is a value ($[[ < ret_terms > ]]$), or it is
unreachable, or for all well-typed states ($[[ s <= N ; nR ]]$)
then there exists another state ($[[ s' ]]$) and expression ($[[ stmt' ]]$)
which is stepped to ($[[ < s ; stmt > --> < s' ; stmt' > ]]$)
in the operational semantics.
\end{theorem}

The assumption that all computational patterns are exhaustive is justified
because they are generated by Cerberus. As one might expect, proving progress
requires well-typed patterns successfully produce substitutions. However, this
complicated by two things, the solution to which requires the introduction of a
relation on SMT terms and resource types, $[[ res ~ res' ]]$ (to be read
``$[[ res ]]$ is syntactically related to $[[ res' ]]$'').

First is that the constraint term generated when typing a computational
pattern (this is required to record, in the constraint context, which branch the
type system is assuming it is in) is not exactly equal to the values it can
match in the operational semantics (nor would we want it to be: the pattern
$[[ Cons ( x1 , x2 ) ]]$ should match the value
$[[ Cons ( pval1 , Cons ( pval2 , Nil base_type ( ) ) ) ]]$). Hence, we
must weaken the notion of equality on types to $[[ ~ ]]$ relatedness, which
links the two, so that during the proof can substitute the constraint term
$[[ x1 :: x2 ]]$ at the type-level, and maintain a link to the corresponding
value.

Second is that the conditions of related conditional resource must
remain SMT-equivalent (with reference to a constraint context), so that
pattern-match typing and resource term typing are consistent.

\begin{theorem}[Type preservation for the annotated and let-normalised Core]
For all closed and well-typed statements
($[[ cdot ; L0 ; N ; nR |- stmt <= ret ]]$),
well typed states ($[[ alloct ; h <= N ; nR ]]$),
frame-heaps ($[[ f ]]$),
new states ($[[ alloct' ; h' ]]$),
and new statements ($[[ stmt' ]]$),
which are connected by a step in the operational semantics
($[[ < alloct ; h + f ; stmt > -->  < alloct' ; heap ; stmt' > ]]$),
if all functions are annotated correctly,
there exists a constraint context ($[[ N' ]]$),
sub-heap ($[[ h' ]]$),
and resource context ($[[ nR' ]]$),
such that the constraint context is extended
($[[ cdot ; L0 ; N ; cdot [= cdot ; L0 ; N' ; cdot ]]$), % chktex 9
the frame is unaffected ($[[ heap ]] = [[ h' + f ]]$),
the sub-state is well-typed ($[[ alloct' ; h' <= N' ; nR' ]]$),
and the statement too
($[[ cdot ; L0 ; N' ; nR' |- stmt' <= ret ]]$).
\end{theorem}

A few things are noteworthy about the proof.

First is that a frame-heap has to be explicitly passed around.  Whilst this is
inconvenient, it becomes necessary in the \StmtLet{} case.
% Don't think this applies any more.
% The next is that proof that well-typed spines produce well-typed substitutions
% require quantifying over the substitutions done \emph{so far}, so that the
% inductive case matches up \emph{and} the substitution so far $[[ psi ]]$ shows
% up in the conclusion, `closing' otherwise `open' substitution and terms.

Second is in the Lemma~\nameref{subsec:wt_values_pat_match}.
There are two substitutions at play here. As an example, consider:
\[
[[ let comp Cons ( x1 , x2 ) , ret_pat : sigma y : list unit .: ret = < Cons ( Unit , Nil unit ( ) ) , ret_terms > in stmt ]].
\]
For the return type $[[ sigma y : list unit .: ret ]]$, the type-level
substitution will be $[[ Cons ( x1 , x2 ) / y ( ret )]]$.  However, at the
term-level, the substitution will be $[[ [ Unit / x1 , Nil unit ( ) / x2 ] ]]$.
\emph{Bridging this difference is the main reason for the $[[ ~ ]]$ relation}
(the other is the use of $[[ to_fun ret ]]$).  \emph{The type-level substitution
is open}, and only makes sense with respect to the variables introduced in the
pattern-match.

Lastly, we gather constraints throughout the proof, since these are accumulated
by the typing rules, during pattern-matching, case and if. Given the constraint
context is always well-formed (w.r.t.~to the initial logical variable context
$[[ L0 ]] = [[ allocv : id_map ]]$), this means that after substituting in the
allocation history, all the constraints involve no variables (hence the
substitutions in \HeapTy{} and \AllocTy), and so will be trivially decidable.

\section{Typing Judgements}\label{sec:type_judge}

In this document, $[[ C ; L ; N ; R ]] [[|-]] J$ stands for all \emph{defined}
judgements, listed in the remainder of this section after this paragraph,
except for $[[ C ; L |- term => out_base_type ]]$. Furthermore, I assume that
\lemmaref{sec:weakening} and \lemmaref{subsec:sub} (proven for the
\emph{defined} judgements in the referenced sections) holds for the
$[[ C ; L |- term => out_base_type ]]$) judgement.\\

\cngrammartabular{
\cnresXXjudge\cninterrule%
\cnretXXjudge\cninterrule%
\cnpatXXjudge\cninterrule%
\cnexplXXpure\cninterrule%
\cnexplXXres\cninterrule%
\cnexplXXspine\cninterrule%
\cnexplXXaction\cninterrule%
\cnexplXXmemop\cninterrule%
\cnexplXXstmt\cnafterlastrule%
}

\section{Operational Semantics Judgements}\label{sec:opsem_judge}

\cngrammartabular{
\cnsubsXXjudge\cninterrule%
\cnpureXXopsem\cninterrule%
\cnopsem\cnafterlastrule%
}

\section{Proof Judgements}\label{sec:proof_judge}

Note that the definition of $[[ term ~ term' ]]$ is omitted/assumed.  It simply
means that $[[ term ]]$ and $[[ term' ]]$ can be unified. Informally,
$[[ term ~ term' ]]$ are defined recursively over the structure of SMT terms,
using the standard definition of unification: variables unify with anything
(modulo an occurs check), atoms unify if they are identical, compound terms
unify if their constructors and arity are
identical, and their arguments unify recursively.\\

\noindent
$[[ ~ ]]$ is additionally assumed to be an equivalence relation and preserved by
substitution: if $[[ term ~ term' ]]$ and $[[ x ~ y ]]$ in $[[ term1 ~ term1' ]]$
then $[[ term / x ( term1 ) ~ term' / y ( term1' ) ]]$.\\

\noindent
\textbf{Note: $[[ ~ ]]$ is \emph{only} used in the \emph{proof} of soundness,
and \emph{not} in the \emph{explicit CN type system}.} There is no unification
required in the type system, but the notion of related terms is required to
argue for the soundness of pattern-matching
(Section~\ref{subsec:wt_values_pat_match}~\nameref{subsec:wt_values_pat_match}).\\

\cngrammartabular{
\cnmiscXXextra\cninterrule%
\cnproofXXdefns\cnafterlastrule%
}

\raggedright%

\section{Groups of Rules}

\subsection{Typing rules with an \texorpdfstring{$[[smt ( N => qterm) ]]$}{smt ( Φ ⇒ qterm )} premise}\label{subsec:smt_premise_rules} % chktex 37

\IGCmpEq, \IGCmpLt, \IGCmpGt, \ICmpIGNeq, \ICmpIArgNeq,
\ICmpComparable, \ReqEqPPIArgNeq, \ReqEqPPEq, \ResEqPhi, \ResEqOrdDisj,
\ResSimpRecIfTrue, \ResSimpRecIfFalse, \RetEqPhi, \PatResMatchIfTrue,
\PatResMatchIfFalse, \PureExprArrayShift, \PureExprMemberShift,
\PureExprAssertUndef, \PureStmtPVal, \PureStmtUB,
\PredOpsCongeal, \PredOpsImplode,
\PredOpsBreak, \PredOpsGlue, \PredOpsInj, \PredOpsChop,
\PredOpsFromBytes, \PredOpsSelect, \PredOpsForget,
\ResChkPhi, \ResChkIfTrue, \ResChkIfFalse, \ActionLoad,
\ActionStore, \ActionKillStatic, \ActionKillDynamic, \LiveOwned,
\LiveAlloc, \BoundsCheck, \MemopIntFromRt, \MemopMemcpy, \MemopMemcmp.

\subsection{Typing rules which change the context}\label{subsec:ctx_change_rules}

\subsubsection{Rules which add constraints}
\StmtIf.


\subsubsection{Rules which add constraints and computational or logical variables}

\StmtCase.\\

\subsubsection{Rules which restrict the resource context}

No-resource / ``pure'' rules: \IGCmpEq, \IGCmpLt, \IGCmpGt, \IGCmpNone,
\ICmpNameNeq, \ICmpIGNeq, \ICmpIArgNeq, \ICmpComparable,
\ReqEqPPNameNeq, \ReqEqPPIArgNeq, \ReqEqPPEq, \ReqEqIIEq, \ReqEqIINeq,
\ResEqEmp, \ResEqPhi, \ResEqPred, \ResEqIPred, \ResEqSepConj, \ResEqExists,
\ResEqOrdDisj, \ResSimpRecIfTrue, \ResSimpRecIfFalse, \ResSimpRecSepConj,
\ResSimpRecExists, \ResSimpRecNoChange, \SimpNoSimp, \SimpSimp, \RetEqEnd,
\RetEqComp, \RetEqLog, \RetEqPhi, \RetEqRes, \PatCompWild,
\PatCompSym, \PatCompNil, \PatCompCons, \PatCompTuple, \PatCompArray,
\PatResMatchEmp, \PatResMatchPhi, \PatResMatchIfTrue, \PatResMatchIfFalse, \PatResMatchVar,
\PatResMatchSepConj, \PatResMatchPack, \PatResMatchFold, \PatRetEmpty,
\PatRetComp, \PatRetLog, \PatRetRes, \PatRetPhi, \PatRetAux, \PureValObjInt, \PureValObjPtr,
\PureValObjArr, \PureValObjStruct, \PureValVar, \PureValObj,
\PureValUnit, \PureValTrue, \PureValFalse, \PureValList, \PureValTuple,
\PureValCtorNil, \PureValCtorCons, \PureValCtorTuple, \PureValCtorArray,
\PureValStruct, \PureExprPVal, \PureExprCtorIvXOR, \PureExprArrayShift,
\PureExprMemberShift, \PureExprNot, \PureExprArithBinop, \PureExprRelBinop,
\PureExprBoolBinop, \PureExprCall, \PureExprAssertUndef, \PureExprBoolToInteger,
\PureExprWrapI, \PureStmtUB, \PureStmtPVal, \MemopPtrEq, \MemopIntFromRt,
\MemopRtFromInt, \MemopRtFromPtr, \MemopPtrFromRt, \MemopPtrValidForDeref,
\MemopPtrWellAligned, \ExprPure, \StmtPure.\\[\baselineskip]

Resource-mentioning rules: \ResSynEmp, \ResSynVar, \ResSynVarSimp, \ResSynPred,
\ResSynIPred, \ResSynSepConj, \ResChkPhi, \ResChkSepConj, \SpineRet,
\SpineRes, \ActionCreate, \MemopRelBinop, \MemopPtrDiffArr, \MemopPtrDiff,
\MemopCopyAllocId, \MemopPtrArrayShift, \MemopMemcpy, \MemopMemcmp,
\StmtRun, \SubsChkEmpty, \SubsChkRes.

\subsubsection{Rules which add constraints and restrict the resource context}
\PureStmtIf.

\subsubsection{Rules which add constraints and variables, and
restrict the resource context}

\PureStmtPExpr, \PureStmtLet, \PureStmtCase, \StmtExpr, \StmtLet.

\subsection{Value typing rules}\label{subsec:value_typing_rules}

\PureValObjInt, \PureValObjPtr, \PureValObjArr, \PureValObjStruct, \PureValVar,
\PureValObj, \PureValUnit, \PureValTrue, \PureValFalse,
\PureValTuple, \PureValCtorNil, \PureValCtorCons, \PureValCtorTuple,
\PureValCtorArray, \PureValStruct, \PureStmtPVal,
\ResSynEmp, \ResSynVar, \ResSynVarSimp, \ResSynPred, \ResSynIPred,
\ResChkPhi, \StmtRetT.

\section{Weakening}\label{sec:weakening}

If $[[ C ; L ; N ; R [= C' ; L' ; N' ; R' ]]$ and $[[ C ; L ; N ; R ]] [[|-]] J$ then
$[[ C' ; L' ; N' ; R' ]] [[|-]] J$.

\begin{pfproof}

\assume{%
\begin{pfenum}
    \item $[[ C ; L ; N ; R [= C' ; L' ; N' ; R' ]]$.
    \item $[[ C ; L ; N ; R ]] [[|-]] J$
\end{pfenum}\leavevmode\\} % chktex 9

\prove{$[[ C' ; L' ; N' ; R' ]] [[|-]] J$.\\[\baselineskip]}

\step{<1>1}{\case{\PureValVar.}{%
    \pf{} By \WeakConsComp{}, if $[[ x : base_type inEnv C]]$
    then $[[ x : base_type inEnv C' ]]$.}}

\step{<1>2}{\case{\nameref{subsec:smt_premise_rules} (see~\ref{subsec:smt_premise_rules}).}{}}

\begin{pfproof}

\assume{$[[smt ( N => qterm )]]$.\\}

\prove{$[[smt ( N' => qterm )]]$.\\[\baselineskip]}

\step{<2>1}{%
    For all $[[term]]$, if $[[ term ]] \in [[ N ]]$
    then $[[ term ]] \in [[ N' ]]$.\\
    \pf{} By \WeakConsPhi.}

\step{<2>2}{%
    Any extra constraints in $[[N']]$ (by \WeakSkipPhi) would either be
    irrelevant, redundant, or inconsistent.}

\step{<2>3}{%
    In all cases, $[[ smt ( N' => qterm ) ]]$ as required.}

\end{pfproof}

\step{<1>3}{\case{All remaining rules.}{}}

    \begin{pfproof}

    \step{<2>1}{%
        $[[R]] = [[R']]$.\\
        \pf{} Only \WeakConsRes{} exists.}

    \step{<2>2}{%
        All remaining rules are functorial in $[[C ; L ; N]]$,
        so one can proceed by straightforward induction.}

    \step{<2>3}{%
        So $[[C' ; L' ; N' ; R']] [[|-]] J$ as required.}

    \end{pfproof}

\end{pfproof}

\section{Substitution}

\subsection{Substitutions preserve SMT results}\label{subsec:sub_smt}

If $[[smt ( N => qterm )]]$
and $[[ C ; L ; subs ( N ) ; R |- subs <= ( C' ; L' ; R' ) ]]$,
then $[[smt ( subs ( N ) => subs < qterm > )]]$.

\pf{} By the first assumption, $[[qterm]]$ holds for all (well-typed, ensured by
the second assumption) instantiations of its free variables.

\subsection{Substitutions can be split up}\label{subsec:sub_split}

If $[[ C ; L ; N ; R |- subs <= ( C' ; L' ; R1' , R2' ) ]]$
then $[[ exists ]] [[ R1 ]], [[ R2 ]], [[ subs1 ]], [[ subs2 ]].\
[[ C ; L ; N ; R1 |- subs1 <= ( C' ; L' ; R1' ) ]] [[ /\ ]]
[[ C ; L ; N ; R2 |- subs2 <= ( C' ; L' ; R2' ) ]]$.

\begin{pfproof}

\pfsketch{ By induction on the substitution. If $[[ subs ]] = [[ [ res_term / r , subs'] ]]$
where $[[ r : res ]]$:\\[\baselineskip]}

\step{<1>1}{%
     Let $[[ R' ]]$ be such that $[[ C ; L ; N ; R' |- res_term <= res ]]$.}

\step{<1>2}{%
     Recursively split $[[ subs' ]]$ into $[[ subs1' ]]$ and $[[ R1'' ]]$;
     $[[ subs2' ]]$ and $[[ R2'' ]]$.}

\step{<1>3}{%
     If $[[ r ]] \in [[ R1' ]]$, let $[[ subs1 ]] = [[ [ res_term / r , subs1' ] ]]$
     and $[[ R1 ]] = [[ R' , R1'' ]]$ .}

\step{<1>4}{%
     If $[[ r ]] \in [[ R2' ]]$, let $[[ subs2 ]] = [[ [ res_term / r , subs2' ] ]]$.}

\step{<1>5}{%
    For other cases, both are treated exactly the same.}

\end{pfproof}

\subsection{Substitution}\label{subsec:sub}

If $[[ C' ; L' ; N ; R' ]] [[|-]] J$,
then $[[forall]]\ [[ C ]], [[ L ]], [[ R ]], [[ subs ]].\
\left( [[ C ; L ; subs ( N ) ; R |- subs <= ( C' ; L' ; R' ) ]] \right) [[=>]]\allowbreak
[[ C ; L ; subs ( N ) ; R ]] [[|-]] [[ subs ]] ( J ) $.\\[\baselineskip]

For types, substitutions are only defined over resource types $[[res]]$, and
return types $[[ret]]$, not base types $[[base_type]]$. Similarly, for terms,
substitutions are only defined over expressions (including SMT terms
$[[term]]$), but not (computational, resource or return) patterns.\\[\baselineskip]

Since $[[ N ]]$ is scoped to $[[ C' ]] ; [[ L' ]]$, we must substitute
over it as well as all the usual suspects on the right.\\[\baselineskip]

Substitution of contexts is defined by substituting over each constraint in
$[[ N ]]$. As a result, $[[ subs ( N1 , N2) ]] = [[ subs ( N1 ) , subs ( N2 ) ]]$,
and if $[[ subs ( N ) ]] = [[ N1' , N2' ]]$ then
$[[ exists ]] [[ N1 ]], [[ N2 ]] [[ .: ]] [[ subs ( N1 , N2 ) ]] = [[ subs ( N1 ) , subs ( N2 ) ]]$.

\begin{pfproof}
\pfsketch{ Induction over the typing judgements.\\
\begin{pfenum*}
\item Variable rules: \PureValVar, \ResSynVarSimp, \ResSynVar.
\item \StmtRetT{}: prove that $\cnkw{to\_fun}$ commutes with substitution.
\item \nameref{subsec:ctx_change_rules} (see~\ref{subsec:ctx_change_rules}).
\item Remaining rules by straightforward induction.
\end{pfenum*}\leavevmode\\[\baselineskip]}

\assume{%
\begin{pfenum}
    \item $[[ C' ; L' ; N ; R' ]] [[|-]] J$.\label{sub_a2}
    \item Arbitrary $[[ C ]], [[ L ]], [[ R ]], [[ subs ]]$.
    \item $[[ C ; L ; subs ( N ) ; R |- subs <= ( C' ; L' ; R' ) ]]$.\label{sub_a1}
\end{pfenum}\leavevmode\\}

\prove{$[[ C ; L ; subs ( N ) ; R ]] [[|-]] [[ subs ]] ( J )$.\\[\baselineskip]}

\step{<1>1}{\case{\PureValVar.}{%
    $[[ C' ; L' |- x => base_type ]]$\\
    $[[ C ; L ; subs ( N ) ; R |- subs <= ( C' ; L' ; cdot ) ]]$.}}

    \begin{pfproof}

    \step{<2>1}{%
        $[[ x : base_type inEnv C' ]]$.\\
        \pf{} By inversion on assumption~\ref{sub_a2}.}

    \step{<2>2}{%
        $[[ R ]]$ is empty.\\
        \pf{} \SubsChkRes{} is the only rule which could require a non-empty
        resource context, and it is never used because $[[R']]$ is empty.}

    \step{<2>3}{%
        $[[ exists ]] [[ subs1 ]], [[ pval ]], [[subs2]], [[ base_type ]],
        [[ C1 , C2 ]], [[ L1 , L2 ]]$.
        \begin{pfenum}
        \item $[[ subs ]] = [[ [ subs1 , pval / x , subs2 ] ]]$
        \item $[[ C ; L ; N ; cdot  |- subs1 <= ( C1 ; L1 ; cdot ) ]]$
        \item $[[ C ; L ; N ; cdot  |- subs1 ( pval / x ) <= ( x : base_type ; cdot ; cdot ) ]]$
        \item $[[ C |- subs1 ( pval ) => base_type ]]$
        \item $[[ C ; L ; N ; cdot  |- subs1 ( pval / x ( subs2 ) ) <= ( C2 ; L2 ; cdot ) ]]$.
        \end{pfenum}
        \pf\ Repeated inversion on assumption~\ref{sub_a1} until the
        \SubsChkComp{} responsible for adding $x$ (by \stepref{<2>1}, there must
        be at least one).}

    \step{<2>4}{%
        Since $[[ subs ( x ) ]] = [[ subs1 ( pval ) ]]$, we are done.\\
        \pf{} By $[[ C ; L |- subs ( x ) => base_type ]]$.}

    \end{pfproof}

\step{<1>2}{\case{\ResSynVarSimp.}{%
    $[[ C' ; L' ; N ; r : res |- r => res' ]]$\\
    $[[ C ; L ; subs ( N ) ; R |- subs <= ( C' ; L' ; r : res' ) ]]$.}}

    \begin{pfproof}

    \step{<2>1}{%
        $[[ exists ]] [[ subs1 ]], [[ res_term ]], [[subs2]],
        [[ C1 , C2 ]], [[ L1 , L2 ]]$.
        \begin{pfenum}
        \item $[[ subs ]] = [[ [ subs1 , res_term / r , subs2 ] ]]$
        \item $[[ C ; L ; subs ( N ) ; cdot  |- subs1 <= ( C1 ; L1 ; cdot ) ]]$
        \item $[[ cdot ; L0 ; subs ( N ) ; R |- subs1 ( res_term / r ) <= ( cdot ; cdot ; r : subs1 ( res' ) ) ]]$
        \item $[[ C ; L ; subs ( N ) ; R |- subs1 ( res_term ) <= subs1 ( res' ) ]]$
        \item $[[ C ; L ; subs ( N ) ; cdot  |- subs1 ( res_term / r ( subs2 ) ) <= ( C2 ; L2 ; cdot ) ]]$.
        \end{pfenum}
        \pf{} Repeated inversion on assumption~\ref{sub_a1} until the
        \SubsChkRes{} responsible for adding $[[ r ]]$ (there must be exactly one).}

    \step{<2>2}{\suffices{%
        \begin{pfenum}
        \item $[[ subs ( r ) ]] = [[ subs1 ( res_term ) ]]$
        \item $[[ subs ( res' ) ]] = [[ [ subs1 , res_term / r , subs2 ] ( res' ) ]] = [[  subs1 ( res' ) ]]$.
        \end{pfenum}}}

    \step{<2>3}{%
        $[[ subs ( r ) ]] = [[ subs1 ( res_term ) ]]$.\\
        \pf{} $[[ subs2 ( r ) = r]]$, because $[[ subs2 ]]$ does not mention any resource variables.}

    \step{<2>4}{%
        $[[ subs ( res' ) ]] = [[ [ subs1 , res_term / r , subs2 ] ( res' ) ]] = [[  subs1 ( res' ) ]]$.}
        \begin{pfproof}

        \step{<3>1}{%
            $[[ [ subs1 , res_term / r , subs2 ] ( res' ) ]] = [[ [ subs1 , subs2] ( res' ) ]]$.\\
            \pf{} Resource types do not refer to resource variables.}

        \step{<3>2}{%
            $[[ [ subs1 , subs2] ( res' ) ]] = [[ subs1 ( res ) ]]$.\\
            \pf{} By $[[ cdot ; L0 ; subs ( N ) ; R |- subs1 ( res_term ) <= subs1 ( res' ) ]]$,
            we know that $[[ res' ]]$ only refers to variables in $[[ C , C1 ]] ; [[ L , L1 ]]$.}

        \end{pfproof}

    \end{pfproof}

\step{<1>3}{\case{\ResSynVar.}{%
    $[[ C' ; L' ; N' ; r : res |- r => res ]]$\\
    \pf{} Similar to \ResSynVarSimp}, but with $[[res']] = [[res]]$.}


\step{<1>4}{\case{\StmtRetT.}{%
\pfsketch{
    $\cnkw{to\_fun}$ recursively maps
    $[[ sigma ]]$ to $[[ pi ]]$,
    $[[ exists ]]$ to $[[ forall ]]$,
    $[[ /\ ]]$ to $[[ -) ]]$ and % chktex 9
    $[[ *o ]]$ to $[[ --o ]]$,
    and otherwise keeps any $[[ term ]]$ and $[[ res ]]$ the same.
    Hence, $[[ subs ( to_fun ret ) ]] = [[ to_fun subs ( ret ) ]]$, and the case
    proceeds by induction straightforwardly.}}}

\step{<1>5}{\case{\nameref{subsec:ctx_change_rules}
        (see~\ref{subsec:ctx_change_rules}), except for
        \PureValVar, \ResSynVar, and \ResSynVarSimp.}{%
    For brevity, I shall only go over \StmtExpr, as it is one of the most
    general rules; one which adds constraints and variables, and restricts the
    resource context.\\[\baselineskip]

    \pfsketch{ The key idea is to apply \lemmaref{subsec:sub_split} as
    required by the restrictions on the resource context. If a rule has a
    $[[ smt ( N => qterm ) ]]$ premise, then apply \lemmaref{subsec:sub_smt}}.\\[\baselineskip]

    $[[ C' ; L' ; N ; R1' , R2' |- let ret_pat = expr in stmt <= ret2 ]]$\\
    $[[ C ; L ; subs ( N ) ; R |- subs <= ( C' ; L' ; R1' , R2' ) ]]$.
    \prove{ $[[ C ; L ; subs ( N ) ; R |- let ret_pat = subs ( expr ) in subs ( stmt) <= subs ( ret2 ) ]]$.}}}

    \begin{pfproof}

    \step{<2>1}{%
        $[[ exists ]] [[ ret1 ]], [[ C3 ]], [[ L3 ]] , [[ N3 ]] , [[ R3 ]]$.
        \begin{pfenum}
        \item $[[ C' ; L' ; N ; R1' |- expr => ret1 ]]$
        \item $[[ N |- ret_pat : ret1 ~> C3 ; L3 ; N3 ; R3 ]]$
        \item $[[ C' , C3 ; L' , L3 ; N , N3 ; R2' , R3 |- stmt <= ret2 ]]$.
        \end{pfenum}
        \pf{} Inversion on assumption~\ref{sub_a2}.}

    \step{<2>2}{%
        \begin{pfenum}
        \item $[[ forall ]] [[ C ]], [[ L ]] , [[ R1 ]] , [[ subs1 ]]$.\\
            $\left( [[ C ; L ; subs1 ( N ) ; R1 |- subs1 <= ( C' ; L' ; R1' ) ]] \right) [[=>]]$\\
            $[[ C ; L ; subs1 ( N ) ; R1 |- subs1 ( expr ) => subs1 ( ret1 ) ]]$.
        \item $[[ forall ]] [[ C ]], [[ L ]] , [[ R4 ]] , [[ subs2 ]]$.\\
            $\left( [[ C ; L ; subs2 ( N ) ; R4 |- subs2 <= ( C' ; L' ; cdot ) ]] \right) [[=>]]$\\
            $[[ subs2 ( N ) |- ret_pat : subs2 ( ret1 ) ~> C3 ; L3 ; subs2 ( N3 ) ; subs2 ( R3 ) ]]$.
        \item $[[ forall ]] [[ C ]], [[ L ]] , [[ R2 ]] , [[ subs3 ]]$.\\
            $\left( [[ C ; L ; subs3 ( N , N3 ) ; R2 |- subs3 <= ( C' , C3 ; L' , L3 ; R2' , R3 ) ]] \right) [[=>]]$\\
            $[[ C ; L ; subs ( N , N3 ) ; R2 |- subs ( stmt )  <= subs ( ret2 ) ]]$.
        \end{pfenum}
        \pf{} By induction on \stepref{<2>1}.}

    \step{<2>3}{%
        $[[ subs ]]$ and $[[ R ]]$ can be split up into $[[ subs1 ]]$
        and $[[ R1 ]]$; $[[ subs2 ]]$; and $[[ subs3 ]]$ and $[[ R2 ]]$ such that:
        \begin{pfenum}
        \item $[[ R ]] = [[ R1 , R2 ]]$
        \item $[[ C ; L ; subs ( N ) ; R1 |- subs1 <= ( C' ; L' ; R1' ) ]]$
        \item $[[ C ; L ; subs ( N ) ; cdot        |- subs2 <= ( C' ; L' ; cdot ) ]]$
        \item $[[ C ; L ; subs ( N ) ; R2 |- subs3 <= ( C' ; L' ; R2' ) ]]$.
        \end{pfenum}
        \pf{} By \lemmaref{subsec:sub_split}.}

    \step{<2>4}{%
        \begin{pfenum}
        \item $[[ subs ( N ) ]] = [[ subs1 ( N ) ]] = [[ subs2 ( N ) ]] = [[ subs3 ( N ) ]]$
        \item $[[ subs ( N3 ) ]] = [[ subs2 ( N3 ) ]] = [[ subs3 ( N3 ) ]]$
        \item $[[ subs ( R3 ) ]] = [[ subs2 ( R3 ) ]] = [[ subs3 ( R3 ) ]]$.
        \end{pfenum}
        \pf{} All the substitutions differ only the resource-variable substitutions, but
        $[[ term ]]$ and $[[ res ]]$ (and so $[[ ret ]]$ and $[[ N ]]$)
        do not mention resource variables.}

    \step{<2>5}{\suffices{%
        $[[ exists ]] [[ R1 ]], [[ R2 ]], [[ ret1 ]], [[ C3 ]], [[ L3 ]] , [[ N3 ]] , [[ R3 ]]$.
        \begin{pfenum}
        \item $[[ R ]] = [[ R1 , R2 ]]$
        \item $[[ C ; L ; subs ( N ) ; R1 |- subs ( expr ) => ret1 ]]$
        \item $[[ subs ( N ) |- ret_pat : subs ( ret1 ) ~> C3 ; L3 ; N3 ; R3 ]]$
        \item $[[ C , C3 ; L , L3 ; subs ( N ) , N3 ; R2 , R3 |- subs ( stmt ) <= subs ( ret2 ) ]]$.
        \end{pfenum}}
        \pf{} By \StmtExpr.}

    \step{<2>6}{%
        \pflet{$[[ R1 ]]; [[ R2 ]]; [[ subs ( ret1 ) ]];
        [[ C3 ]]; [[ L3 ]]; [[ subs ( N3 ) ]]; [[ subs ( R3 ) ]]$
        be the witnesses for \stepref{<2>5}.}
        \suffices{
            \begin{pfenum}
            \item $[[ R ]] = [[ R1 , R2 ]]$
            \item $[[ C ; L ; subs ( N ) ; R1 |- subs ( expr ) => subs ( ret1 ) ]]$
            \item $[[ subs ( N ) |- ret_pat : subs ( ret1 ) ~> C3 ; L3 ; subs ( N3 ) ; subs ( R3 ) ]]$
            \item $[[ C , C3 ; L , L3 ; subs ( N ) , subs ( N3 ) ; R2 , subs ( R3 ) |- subs ( stmt ) <= subs ( ret2 ) ]]$.
            \end{pfenum}}}

    \step{<2>7}{%
        We are done.\\
        \pf{} Apply \stepref{<2>2} with \stepref{<2>3} and \stepref{<2>4}.}

    \end{pfproof}


\step{<1>6}{\case{All remaining rules.}{%
    \pfsketch\ By straightforward induction. If the rule has a
    $[[ smt ( N => qterm ) ]]$ premise, apply \lemmaref{subsec:sub_smt}.}}

\end{pfproof}

\section{Resource Term Lemmas}

\subsection{Definition: Normalised contexts}

A resource context is \emph{normalised} is it contains only predicates and quantified
predicates.

\subsection{Resource contexts typing closed terms can be normalised}\label{subsec:res_ctx_closed_norm}

\begin{pfproof}

\assume{\begin{pfenum}
    \item Arbitrary $[[ res ]]$
    \item Closed (no free-variables) $[[ res_term ]]$
    \item $[[ cdot ; L0 ; N ; R |- res_term <= res ]]$ (or synthesising)
\end{pfenum}\leavevmode\\}

\prove{ $[[ exists ]] [[ nR ]] .\: [[ R ]] = [[ nR ]]$.\\[\baselineskip]}

\pfsketch{ By induction on the typing judgement.\\[\baselineskip]}

\step{<1>1}{\case{\ResSynEmp, \ResSynPred, \ResSynIPred, \ResChkPhi.}{%
    \pf{} $[[ nR ]] = [[ R ]]$ (the context is already normalised).}}

\step{<1>2}{\case{\ResSynVar, \ResSynVarSimp}{%
    \pf{} Impossible cases ($[[ res_term ]]$s are not closed).}}

\step{<1>3}{\case{All remaining cases (\PredOpsIterate,
        \PredOpsCongeal, \PredOpsExplode, \PredOpsImplode,
        \PredOpsBreak, \PredOpsGlue, \PredOpsInj, \PredOpsChop,
        \PredOpsToBytes, \PredOpsFromBytes, \PredOpsSelect,
        \PredOpsForget,
        \ResSynPredOps, \ResSynFold, \ResSynSepConj, \ResChkPack, \ResChkSepConj,
        \ResChkIfTrue, \ResChkIfFalse, \ResChkSwitch).\\}{%
    \pf{} By induction.}}

\end{pfproof}

\subsection{Non-conditional resources determine context and values}\label{subsec:non_cond_res_det_ctx_val}

This is a simple inversion lemma.

\begin{pfproof}

\assume{\begin{pfenum}
    \item Arbitrary $[[ res_val ]]$
    \item $[[ res ]] [[ != ]] [[ if term then res1 else res2 ]]$.
    \item $[[ cdot ; L0 ; N ; nR |- res_val <= res ]]$ (or synthesising)
    \end{pfenum}\leavevmode\\}

\step{<1>1}{The typing assumption cannot be any of: \ResSynVar, \ResSynVarSimp,
    \ResSynFold, \PredOpsIterate, \PredOpsCongeal,
    \PredOpsExplode, \PredOpsImplode, \PredOpsBreak,
    \PredOpsGlue, \PredOpsInj, \PredOpsChop,
    \PredOpsSelect, \PredOpsForget,
    \PredOpsToBytes, \PredOpsFromBytes,
    \ResSynPredOps.\\
    \pf{} $[[ res_term ]]$s in these rules are not values.}

\step{<1>2}{If $[[ res ]] = [[ emp ]]$, then $[[ nR ]] = [[ cdot ]]$
    and $[[ res_val ]] = [[ emp ]]$.\\
    \pf{} By inversion, the assumption must be \ResSynEmp{} (and optionally \ResChkSwitch).}

\step{<1>3}{If $[[ res ]] = [[ term ]]$, then $[[ nR ]] = [[ cdot ]]$
    and $[[ res_val ]] = [[ TERM ]]$.\\
    \pf{} By inversion, the assumption must be \ResChkPhi.}

\step{<1>4}{If $[[ res ]] = [[ pred_term ( oarg ) ]]$, then $[[ nR ]] = [[ _x : pred_term ( oarg ) ]]$
    and $[[ res_val ]] = [[ pred_term ]]$.\\
    \pf{} By inversion, the assumption must be \ResSynPred{} (and optionally \ResChkSwitch).}

\step{<1>5}{If $[[ res ]] = [[ ipred_term ( oarg ) ]]$, then $[[ nR ]] = [[ _x : ipred_term ( oarg ) ]]$
    and $[[ res_val ]] = [[ ipred_term ]]$.\\
    \pf{} By inversion, the assumption must be \ResSynIPred{} (and optionally \ResChkSwitch).}

\step{<1>6}{If $[[ res ]] = [[ res1 * res2 ]]$, then $[[ nR ]] = [[ nR1 , nR2 ]]$
    and $[[ res_val ]] = [[ < res_val1 , res_val2 > ]]$.\\
    \pf{} By inversion, the assumption must be \ResSynSepConj{} (and optionally \ResChkSwitch),
    or \ResChkSepConj.}

\step{<1>7}{If $[[ res ]] = [[ exists y : base_type .: res ]]$,
    then $[[ res_val ]] = [[ pack ( oarg , res_val' )]]$.\\
    \pf{} By inversion, the assumption must be \ResChkPack.}

\end{pfproof}

\subsection{Normalised resource context determines structure of heap}\label{subsec:norm_ctx_det_heap}

This is as simple inversion lemma.

\begin{pfproof}

\assume{$[[ alloct |- h <= nR ]]$, $[[ subs0 ]] = [[ alloct / allocv ]]$.\\}

\step{<1>1}{If $[[ nR ]] = [[ cdot ]]$, then $[[ h ]] = [[ cdot ]]$.\\
    \pf{} By inversion, the assumption must be \HeapEmpty.}

\step{<1>2}{If $[[ pred ]] = [[ ptrt |- init - ct -> oarg ]]$, $[[ nR ]] = [[ _x : pred ]]$,
    then $[[ h ]] = [[ { pred' & None } ]]$ for $[[ cdot |- subs0 ( pred ) = subs0 ( pred' ) ]]$.\\
    \pf{} By inversion, the assumption must be \HeapPredOwned{}.}

\step{<1>2a}{If $[[ pred ]] = [[ Alloc ( term ) ( oarg ) ]]$, $[[ nR ]] = [[ _x : pred ]]$,
    then $[[ h ]] = [[ { pred' & None } ]]$ for $[[ cdot |- subs0 ( pred ) = subs0 ( pred' ) ]]$.\\
    \pf{} By inversion, the assumption must be \HeapPredAlloc{}.}

\step{<1>2b}{If $[[ pred ]] = [[ Padding < union tag , member > ( ptrt ) ( oarg ) ]]$, $[[ nR ]] = [[ _x : pred ]]$,
    then $[[ h ]] = [[ { pred' & None } ]]$ for $[[ cdot |- subs0 ( pred ) = subs0 ( pred' ) ]]$.\\
    \pf{} By inversion, the assumption must be \HeapPredPadding{}.}

\step{<1>3}{If $[[ nR ]] = [[ _x : pred ]]$, then $[[ h ]] = [[ { pred' & def & h' } ]]$.\\
    for $[[ cdot |- subs0 ( pred ) = subs0 ( pred' ) ]]$.\\
    \pf{} By inversion, the assumption must be \HeapPredOther.}

\step{<1>4}{If $[[ ipred ]] = [[ *S x .: iguard => ptrt |- _init - ct -> oarg ]]$, $[[ nR ]] = [[ _x : ipred ]]$,
    then $[[ h ]] = [[ { ipred' & cdot } ]]$ for $[[ cdot |- subs0 ( ipred ) = subs0 ( ipred' ) ]]$.\\
    \pf{} By inversion, the assumption must be \HeapIPredOwned.}

\step{<1>5}{If $[[ nR ]] = [[ _x : ipred ]]$, then $[[ h ]] = [[ { ipred' & arr_heap } ]]$
    for $[[ cdot |- subs0 ( ipred ) = subs0 ( ipred' ) ]]$.\\
    \pf{} By inversion, the assumption must be \HeapIPredOther.}

\step{<1>6}{If $[[ nR ]] = [[ nR1 , nR2 ]]$, then $[[ h ]] = [[ h1 + h2 ]]$,
    where $[[ alloct |- h1 <= nR1 ]]$ and $[[ alloct |- h2 <= nR2 ]]$.\\
    \pf{} By inversion, the assumption must be \HeapConcat.}

\end{pfproof}

\subsection{Well-typed resource value determines its footprint}\label{subsec:wt_res_val_det_footprint}

\begin{pfproof}

\assume{%
    $[[ cdot ; L0 ; N ; nR |- res_val <= res ]]$ (or synthesising)\\
    $[[ alloct |- h <= nR ]]$.\\}

\prove{%
    $[[ forall ]] [[ f ]] .\: [[ footprint_of res_val in h + f ~> h REM f ]]$.\\[\baselineskip]}

\pfsketch{ By induction on the typing judgement.\\[\baselineskip]}

\step{<1>1}{\case{\ResSynEmp{} or \ResChkPhi}{%
    $[[ nR ]] = [[ cdot]]$ and so $[[ h ]] = [[ cdot ]]$ by Lemma~\ref{subsec:norm_ctx_det_heap}.\\
    \pf{} \OpFootprintEmp{} or \OpFootprintTerm{} respectively.}}

\step{<1>2}{\case{\ResSynPred{} or \ResSynIPred}{%
    $[[ nR ]] = [[ _x : pred_term ( oarg ) ]] \textrm{ or } [[ _x : ipred_term ( oarg ) ]]$, and so
    $[[ h ]] = [[ { pred_term ( oarg ) & def_heap } ]] \textrm{ or }
    [[ { ipred_term ( oarg ) & arr_heap } ]]$ by Lemma~\ref{subsec:norm_ctx_det_heap}.\\
    \pf{} \OpFootprintPred{} or \OpFootprintIPred{} respectively.}}

\step{<1>3}{\case{$[[ pack ( oarg , res_val' ) ]]$.}{%
    \pf{} By induction.}}

\step{<1>4}{\case{\OpFootprintSepPair.}{%
    $[[ res_val ]] = [[ < res_val1 , res_val2 >]]$,\\
    $[[ nR ]] = [[ nR1 , nR2 ]]$, and so\\
    $[[ h ]] = [[ h1 + h2 ]]$ where $[[ alloct |- h1 <= nR1 ]]$ and $[[ alloct |- h2 <= nR2 ]]$
    by Lemma~\ref{subsec:norm_ctx_det_heap}.}}

    \begin{pfproof}

    \step{<2>1}{%
        $[[ footprint_of res_val1 in h1 + h2 + f ~> h1 REM h2 + f ]]$.\\
        \pf{} Instantiate inductive hypothesis with $[[ h2 + f]]$.}

    \step{<2>2}{%
        $[[ footprint_of res_val1 in h2 + f ~> h2 REM f ]]$.\\
        \pf{} Instantiate inductive hypothesis with $[[ f  ]]$.}

    \end{pfproof}

\end{pfproof}

\subsection{Progress and type preservation for resource terms}\label{subsec:res_term_progress}

\begin{pfproof}

\assume{\begin{pfenum}
    \item Closed (no free-variables) $[[ res_term ]]$
    \item $[[ cdot ; L0 ; N ; nR |- res_term <= res ]]$ (or synthesising)
    \item $[[ alloct ; h <= N ; nR ]]$
    \end{pfenum}\leavevmode\\}

\prove{%
    $[[ exists ]] [[ res_val ]] , [[ nR']] , [[ h' ]] .\: $
    \begin{pfenum}
    \item $[[ cdot ; L0 ; N ; nR'  |- res_val <= res ]]$ (or synthesising respectively)
    \item $[[ alloct |- h' <= nR' ]]$
    \item $[[ forall ]] [[ f ]] .\: [[ alloct | < h + f ; res_term > ||v < h' + f ; res_val > ]]$.
    \end{pfenum}\leavevmode\\[\baselineskip]}

\pfsketch{ Induction on the resource term typing assumption. The type
    dictates the value and context, the latter of which dictates
    the shape of the heap.\\[\baselineskip]}

Because of this direction of information, you cannot prove that
$[[ forall ]] [[ nR' ]] .\: ( [[ alloct |- h' <= nR' ]] )
[[ => ]] ( [[ cdot ; L0 ; N ; R'' |- res_val' <= res ]] )$.
The converse is already true by the composition of
lemmas~\ref{subsec:non_cond_res_det_ctx_val} and~\ref{subsec:norm_ctx_det_heap}.
You need the existential, so that you can provide it as a witness when proving
heap typing for folded predicates, which you need to use in proving unfolding
predicates in pattern-matching.\\[\baselineskip]

\step{<1>1}{\case{\PredOpsIterate}{%
    \pflet{%
        $[[ res_term ]]  = [[ iterate ( res_term' , n ) ]]$\\
        $[[ ipred_term ]] = [[ each (integer x;  0 =< x =< n - 1) { Owned < init , ct > ( array_shift < ct > ( ptrt , x ) ) } ]]$\\
        $[[ res ]]       = [[ ipred_term ( oarg ) ]]$\\
        $[[ pred_term ]] = [[ Owned < init , array n ct > ( ptrt ) ]]$\\
        $[[ res' ]]      = [[ pred_term ( oarg' ) ]]$.}}}

    \begin{pfproof}

    \step{<2>1}{%
        $[[ cdot ; L0 ; N ; nR |- res_term' => res' ]]$.\\
        \pf{} By inversion on the typing assumption.}

    \step{<2>2}{%
        $[[ exists ]] [[ h'' ]] , [[ nR'' ]] , [[ res_val' ]] .\: $
        \begin{pfenum}
        \item $[[ cdot ; L0 ; N ; R'' |- res_val' => res' ]]$
        \item $[[ alloct |- h' <= nR' ]]$
        \item $[[ forall ]] [[ f ]] .\: [[ alloct | < h + f ; res_term' > ||v < h'' + f ; res_val' > ]]$.
        \end{pfenum}
        \pf{} By the induction hypothesis.}

    \step{<2>3}{$[[ res_val' ]] = [[ pred_term ]]$ and $[[ nR'' ]] = [[ _x : res' ]]$.\\
        \pf{} By \stepref{<2>2} and \lemmaref{subsec:non_cond_res_det_ctx_val}.}

    \step{<2>4}{%
        $[[ h'' ]] = [[ { pred_term ( oarg' ) & None } ]]$.\\
        \pf{} By \stepref{<2>3} and \lemmaref{subsec:norm_ctx_det_heap}.}

    \step{<2>5}{\pflet{%
        $[[ res_val ]] = [[ each (integer x;  0 =< x =< n - 1) { Owned < init , ct > ( array_shift < ct > ( ptrt , x ) ) } ]]$\\
        $[[ nR' ]] = [[ _x : ipred_term ( oarg ) ]]$ and $[[ h' ]] = [[ { ipred_term ( oarg ) & cdot } ]]$.}
        \pf{} Prove value typing using \ResSynIPred; heaping typing using \HeapIPredOwned; reduction using \OpPredOpsIterate.}

    \end{pfproof}

\step{<1>2}{\case{\PredOpsCongeal}{%
    \pf{} Like \PredOpsIterate, but with:\\
    $[[ res_term ]]= [[ congeal ( res_term' , n ) ]]$\\
    $[[ res ]]     = [[ pred_term ( oarg ) ]]$
    where $[[ pred_term ]] = [[ Owned < init , array n ct > ( ptrt ) ]]$\\[\baselineskip]

    $[[ res' ]]    = [[ ipred_term ( oarg' ) ]]$
    where $[[ ipred_term ]] = [[ each (integer x;  iguard ) { Owned < init , ct > ( array_shift < ct > ( ptrt , x ) ) } ]]$\\
    $[[ res_val' ]] = [[ ipred_term ]]$
    and $[[ nR'' ]] = [[ _x : res' ]]$,
    by Lemma~\ref{subsec:non_cond_res_det_ctx_val}\\[\baselineskip]

    Let $[[ res_val ]] = [[ pred_term ]]$,
    $[[ nR' ]] = [[ _x : pred_term ( oarg ) ]]$ and
    $[[ h' ]] = [[ { pred_term ( oarg ) & None } ]]$
    to prove:
    value typing using \ResSynPred;
    heap typing using \HeapPredOwned;
    reduction using \OpPredOpsCongeal.}}

\step{<1>3}{\case{\PredOpsExplode}{%
    \pf{} Like \PredOpsIterate, but with:\\
    $[[ res_term ]]= [[ explode ( res_term' ) ]]$\\
    $[[ res ]]     = [[ *S ( </ pred_termi ( oargi ) // i /> ) ]]$
    where $[[ pred_termi ]] = [[ Owned < init , cti > ( member_shift < struct tag > ( ptrt ,  memberi ) ) ]]$\\[\baselineskip]

    $[[ res' ]]    = [[ pred_term ( oarg ) ]]$
    where $[[ pred_term ]] = [[ Owned < init , struct tag > ( ptrt ) ]]$\\
    $[[ res_val' ]] = [[ pred_term ]]$
    and $[[ nR'' ]] = [[ _x : pred_term ( oarg ) ]]$,
    by Lemma~\ref{subsec:non_cond_res_det_ctx_val}\\[\baselineskip]

    Let $[[ res_val ]] = [[ < </ pred_termi // i /> > ]]$,
    $[[ nR' ]] = [[ </ _x : pred_termi ( oargi ) // i /> ]]$
    and $[[ h' ]] = [[ </ { pred_termi ( oargi ) & None } // i /> ]]$, to prove:
    value typing using \ResSynPred{} and \ResSynSepConj;
    heap typing using \HeapConcat{} and \HeapPredOwned;
    reduction using \OpPredOpsExplode.}}

\step{<1>4}{\case{\PredOpsImplode}{%
    \pf{} Like \PredOpsIterate, but with:\\
    $[[ res_term ]] = [[ implode ( res_term' , tag ) ]]$\\
    $[[ res ]] = [[ pred_term ( oarg ) ]]$
    where $[[ pred_term ]] = [[ Owned < init , struct tag > ( ptrt ) ]]$\\[\baselineskip]

    $[[ res' ]] = [[ *S ( </ pred_termi ( oargi ) // i /> ) ]]$
    where $[[ pred_termi ]] = [[ Owned < init , cti > ( member_shift < struct tag > ( ptrt , memberi ) ) ]]$\\
    $[[ res_val' ]] = [[ </ pred_termi // i /> ]]$
    and $[[ nR'' ]] = [[ </ _x : pred_termi ( oargi ) // i /> ]]$,
    by Lemma~\ref{subsec:non_cond_res_det_ctx_val}\\[\baselineskip]

    Let $[[ res_val ]] = [[ Owned < init , struct tag > ( ptrt ) ]]$,
    $[[ nR' ]] = [[ _x : pred_term ( oarg ) ]]$,
    and $[[ h' ]] = [[ { pred_term ( oarg ) & None } ]]$, to prove:
    value typing using \ResSynPred;
    heap typing using \HeapPredOwned;
    reduction using \OpPredOpsImplode.}}

\step{<1>5}{\case{\PredOpsBreak}{%
    \pf{} Like \PredOpsIterate, but with:\\
    $[[ res_term ]]= [[ break ( res_term' , term ) ]]$\\
    $[[ res ]] = [[ ipred_term ( oarg ) * pred_term ( oarg [ term ] ) ]]$
    where $[[ ipred_term ]] = [[ each (integer x;  iguard /\ ( x != term ) ) { a ( array_shift < ct > ( ptrt , x ) , iargs ) } ]]$
    and $[[ pred_term ]] = [[ a ( array_shift < ct > ( ptrt , term ) , term / x ( iargs ) ) ]]$\\[\baselineskip]

    $[[ res' ]] = [[ ipred_term' ( oarg ) ]]$
    where $[[ ipred_term' ]] = [[ each (integer x;  iguard ) { a ( array_shift<ct>(ptrt, x) , iargs ) } ]]$\\
    $[[ res_val' ]] = [[ ipred_term' ]]$,
    and $[[ nR'' ]] = [[ _x : ipred_term' ( oarg ) ]]$,
    by Lemma~\ref{subsec:non_cond_res_det_ctx_val}.\\[\baselineskip]

    If predicate is $[[ Owned < _init , ct > ]]$, $[[ h'' ]] = [[ { ipred_term' ( oarg ) & cdot } ]]$
    (by Lemma~\ref{subsec:norm_ctx_det_heap}),
    so let $[[ h' ]] = [[ { ipred_term ( oarg ) & cdot } + { pred_term ( oarg [ term ] ) & None } ]]$
    (by $[[ cdot [ term ] ]] = [[ None ]]$).\\
    Otherwise, $[[ h'' ]] = [[ { ipred_term' ( oarg ) & arr_heap } ]]$,
    (again by Lemma~\ref{subsec:norm_ctx_det_heap}),
    so let $[[ h' ]] = [[ { ipred_term ( oarg ) & arr_heap } + { pred_term ( oarg [ term ] ) & arr_heap [ term ] } ]]$.\\[\baselineskip]

    Let $[[ res_val ]] = [[ < ipred_term , pred_term > ]]$ and
    $[[ nR' ]] = [[ _x : ipred_term ( oarg ) , _x : pred_term ( oarg [term ] ) ]]$ to prove:
    value typing using \ResSynIPred, \ResSynPred, \ResSynSepConj;
    heap typing using \HeapConcat, \HeapIPredOwned{} / \HeapIPredOther, and
    \HeapPredOwned{} / \HeapPredOther{} (with witness $[[ _x : pred_term ( oarg [ term ] ) ]]$);
    reduction using \OpPredOpsBreak.}}

\step{<1>6}{\case{\PredOpsGlue}{%
    \pf{} Like \PredOpsIterate, but with:\\
    $[[ res_term ]]= [[ glue ( res_term' ) ]]$\\
    $[[ res ]] = [[  ipred_term ( oarg1 [ term ] := oarg2 ) ]]$
    where $[[ ipred_term ]] = [[ each (integer x;  iguard \/ x = term ) { a ( array_shift <ct> (ptrt1, x) , iargs1 ) } ]]$\\[\baselineskip] % chktex 4

    $[[ res' ]] = [[ ipred_term1 ( oarg1 ) * pred_term ( oarg2 ) ]]$
    where $[[ ipred_term1 ]] = [[ each (integer x;  iguard ) { a ( array_shift<ct>(ptrt1,x) , iargs1 ) } ]]$
    and $[[ pred_term ]] = [[ a ( ptrt2 , iargs2 ) ]]$.\\
    $[[ res_val' ]] = [[ < ipred_term1 , pred_term > ]]$,
    and $[[ nR'' ]] = [[ _x : ipred_term1 ( oarg1 ) , _x : pred_term ( oarg2 ) ]]$,
    by Lemma~\ref{subsec:non_cond_res_det_ctx_val}.\\[\baselineskip]

    If predicate is $[[ Owned < _init , ct > ]]$, $[[ h'' ]] = [[ { ipred_term1 ( oarg1 ) & cdot } + { pred_term ( oarg2 ) & None } ]]$
    (by Lemma~\ref{subsec:norm_ctx_det_heap}),
    so let $[[ h' ]] = [[ { ipred_term ( oarg ) & cdot } ]]$ (by $[[ cdot [ term ] := None ]] = [[ cdot ]]$).
    Otherwise, $[[ h'' ]] = [[ { ipred_term1 ( oarg1 ) & arr_heap } + { pred_term ( oarg2 ) & def & heap } ]]$
    (again by Lemma~\ref{subsec:norm_ctx_det_heap}),
    so let $[[ h' ]] = [[ { ipred_term ( oarg ) & arr_heap [ term ] := def & heap } ]]$.\\[\baselineskip]

    Let $[[ res_val ]] = [[ ipred_term ]]$ and
    $[[ nR ]] = [[ _x : ipred_term ( oarg1 [ term ] := oarg2 ) ]]$, to prove:
    value typing using \ResSynIPred;
    heap typing using \HeapIPredOwned{} / \HeapIPredOther;
    reduction using \OpPredOpsGlue.}}

\step{<1>7}{\case{\PredOpsInj}{%
    \pf{} Like \PredOpsIterate, but with:\\
    $[[ res_term ]]= [[ inj ( res_term' , ptrt1 , ct , x .: iargs1 ) ]]$\\
    $[[ res ]]     = [[ ipred_term ( const oarg ) ]]$
    where $[[ ipred_term ]] = [[each (integer x;  x = term ) { a ( array_shift<ct> (ptrt1, x) , iargs1 ) } ]]$\\[\baselineskip]

    $[[ res' ]]    = [[ pred_term ( oarg ) ]]$
    where $[[ pred_term ]] = [[ a ( ptrt2 , iargs2 ) ]]$\\
    $[[ res_val' ]] = [[ pred_term ]]$,
    and $[[ nR'' ]] = [[ _x : pred_term ( oarg ) ]]$,
    by Lemma~\ref{subsec:non_cond_res_det_ctx_val}.\\[\baselineskip]

    If predicate is $[[ Owned < _init, ct > ]]$, $[[ h'' ]] = [[ { pred_term ( oarg ) & None } ]]$
    (by Lemma~\ref{subsec:norm_ctx_det_heap}),
    so let $[[ h' ]] = [[ { ipred_term ( const oarg ) & cdot } ]]$
    (by $ ( [[ cdot [ term ] := None ]] ) = [[ cdot ]]$).\\
    Otherwise, $[[ h'' ]] = [[ { pred_term ( oarg ) & def & heap } ]]$
    (again by Lemma~\ref{subsec:norm_ctx_det_heap}),
    so let $[[ h' ]] = [[ { ipred_term ( const oarg ) & cdot [ term ] := def & heap } ]]$.\\[\baselineskip]

    Let $[[ res_val ]] = [[ ipred_term ]]$,
    and $[[ nR ]]  = [[ _x : ipred_term ( const oarg ) ]]$,
    to prove typing using \HeapIPredOwned{} / \HeapIPredOther,
    and reduction using \OpPredOpsInj.}}

\step{<1>8}{\case{\PredOpsChop}{%
    \pf{} Like \PredOpsIterate, but with:\\
    $[[ res_term ]]= [[ chop ( res_term' , iguard ) ]]$\\
    $[[ res ]]     = [[  ipred_term1 ( oarg ) * ipred_term2 ( oarg ) ]]$
    where $[[ ipred_term1 ]] = [[ each (integer x;  iguard ) { a ( array_shift<ct>(ptrt, x) , iargs ) } ]]$
    and $[[ ipred_term2 ]] = [[ each (integer x;  iguard2 ) { a ( array_shift<ct>(ptrt, x) , iargs ) } ]]$\\[\baselineskip]

    $[[ res' ]]    = [[  ipred_term ( oarg ) ]]$
    where $[[ ipred_term ]] = [[ each (integer x;  iguard' ) { a ( array_shift<ct>(ptrt,x) , iargs ) } ]]$,\\
    $[[ res_val' ]] = [[ ipred_term ]]$,
    and $[[ nR'' ]] = [[ _x : ipred_term ( oarg ) ]]$,
    by Lemma~\ref{subsec:non_cond_res_det_ctx_val}.\\[\baselineskip]

    If predicate is $[[ Owned < _init , ct > ]]$, $[[ h'' ]] = [[ { ipred_term ( oarg ) & cdot } ]]$
    (by Lemma~\ref{subsec:norm_ctx_det_heap}),
    so let $[[ h' ]] = [[ { ipred_term1 ( oarg ) & cdot } + { ipred_term2 ( oarg ) & cdot } ]]$.
    Otherwise, $[[ h'' ]] = [[ { ipred_term ( oarg ) & arr_heap } ]]$
    (again by Lemma~\ref{subsec:norm_ctx_det_heap}),
    so let $[[ h' ]] = [[ { ipred_term1 ( oarg ) & arr_heap } + { ipred_term2 ( oarg ) & arr_heap } ]]$.\\[\baselineskip]

    Let $[[ res_val ]] = [[ < ipred_term1 , ipred_term2 > ]]$,
    and $[[ nR ]] = [[ _x : ipred_term1 ( oarg ) , _x : ipred_term2 ( oarg ) ]]$, to prove:
    value typing using \ResSynIPred{} and \ResSynSepConj;
    heap typing using \HeapConcat{} and \HeapIPredOwned{} / \HeapIPredOther;
    reduction using \OpPredOpsChop.}}

\step{<1>8a}{\case{\PredOpsToBytes}{%
    \pf{} Like \PredOpsIterate, but with:\\
    $[[ res_term ]]= [[ to_bytes ( res_term' ) ]]$\\
    $[[ res ]]  = [[ ipred_term ( oarg' ) ]]$,
    where $[[ ipred_term ]] = [[ each (integer x; 0 =< x =< sizeof ct - 1) { Owned < init , byte > ( array_shift < byte > ( ptrt , x ) ) } ]]$.\\[\baselineskip]

    $[[ res' ]] = [[  pred_term ( oarg ) ]]$,
    where $[[ pred_term ]] = [[ Owned < init , ct > ( ptrt ) ]]$,
    $[[ res_val' ]] = [[ pred_term ]]$,
    and $[[ nR'' ]] = [[ _x : pred_term ( oarg ) ]]$,
    by Lemma~\ref{subsec:non_cond_res_det_ctx_val}.\\[\baselineskip]

    Hence $[[ h'' ]] = [[ { pred_term ( oarg ) & None } ]]$
    (by Lemma~\ref{subsec:norm_ctx_det_heap}),
    so let $[[ h' ]] = [[ { ipred_term ( oarg' ) & cdot } ]]$.\\[\baselineskip]

    Let $[[ res_val ]] = [[ ipred_term ]]$,
    and $[[ nR ]] = [[ _x : ipred_term ( oarg ) ]]$, to prove:
    value typing using \ResSynIPred{};
    heap typing using \HeapIPredOwned{};
    reduction using \OpPredOpsToBytes.}}

\step{<1>8b}{\case{\PredOpsFromBytes}{%
    \pf{} Like \PredOpsIterate, but with:\\
    $[[ res_term ]]= [[ from_bytes < init , ct > ( res_term' ) ]]$\\
    $[[ res ]]     = [[  pred_term ( oarg ) ]]$
    where $[[ pred_term ]] = [[ Owned < init , ct > ( ptrt ) ]]$.\\[\baselineskip]

    $[[ res' ]]    = [[  ipred_term ( oarg ) ]]$
    where $[[ ipred_term ]] = [[ each (integer x; iguard) { Owned < init , byte > ( array_shift < byte > ( ptrt , x ) ) } ]]$\\
    $[[ res_val' ]] = [[ ipred_term ]]$,
    and $[[ nR'' ]] = [[ _x : ipred_term ( oarg ) ]]$,
    by Lemma~\ref{subsec:non_cond_res_det_ctx_val}.\\[\baselineskip]

    Hence $[[ h'' ]] = [[ { ipred_term ( oarg ) & cdot } ]]$
    (by Lemma~\ref{subsec:norm_ctx_det_heap}),
    so let $[[ h' ]] = [[ { pred_term ( oarg' ) & None } ]]$.\\[\baselineskip]

    Let $[[ res_val ]] = [[ pred_term ]]$,
    and $[[ nR ]] = [[ _x : pred_term1 ( oarg ) ]]$, to prove:
    value typing using \ResSynIPred{};
    heap typing using \HeapPredOwned{};
    reduction using \OpPredOpsFromBytes.}}

\step{<1>8c}{\case{\PredOpsSelect}{%
    \pf{} Like \PredOpsIterate, but with:\\
    $[[ res_term ]]= [[ select < init1 , member > ( res_term' ) ]]$\\
    $[[ res ]] = [[ pred_term1 ( oarg1 ) * pred_term2 ( oarg' )  ]]$,
    where $[[ pred_term1 ]] = [[ Owned < init1 , ct1 > ( ptrt1 ) ]]$,
    % $[[ oarg1 ]] = [[ oarg' [ term ldots term + sizeof ct - 1 ] ]]$,
    % $[[ term ]] = [[ offsetof tag member ]]$,
    % $[[ P ( tag ) = member : ct1 , _member : _ct ]]$,
    $[[ pred_term2 ]] = [[ Padding < union tag , member > ( ptrt' ) ]]$.\\[\baselineskip]

    $[[ res' ]] = [[  pred_term' ( oarg' ) ]]$
    where $[[ pred_term' ]] = [[ Owned < init , union tag > ( ptrt' ) ]]$,
    $[[ res_val' ]] = [[ pred_term' ]]$,
    and $[[ nR'' ]] = [[ _x : pred_term' ( oarg' ) ]]$,
    by Lemma~\ref{subsec:non_cond_res_det_ctx_val}.\\[\baselineskip]

    Hence $[[ h'' ]] = [[ { pred_term' ( oarg' ) & None } ]]$
    (by Lemma~\ref{subsec:norm_ctx_det_heap}),
    so let $[[ h' ]] = [[ { pred_term1 ( oarg1 ) & None } + { pred_term2 ( oarg' ) & None } ]]$.\\[\baselineskip]

    Let $[[ res_val ]] = [[ < pred_term1 , pred_term2 > ]]$,
    and $[[ nR ]] = [[ _x : pred_term1 ( oarg1 ) , _x : pred_term2 ( oarg' ) ]]$, to prove:
    value typing using \ResSynPred{} and \ResSynPredOps{} twice followed by \ResSynSepConj{};
    heap typing using \HeapPredOwned{} and \HeapPredPadding{} followed by \HeapConcat{};
    reduction using \OpPredOpsSelect.}}

\step{<1>8d}{\case{\PredOpsForget}{%
    \pf{} Like \PredOpsIterate, but with:\\
    $[[ res_term ]]= [[ forget < union tag > ( res_term' ) ]]$\\
    $[[ res ]]     = [[  pred_term ( oarg ) ]]$
    where $[[ pred_term ]] = [[ Owned < init , union tag > ( ptrt ) ]]$.\\[\baselineskip]

    $[[ res' ]] = [[ pred_term1 ( oarg1 ) * pred_term2 ( oarg2 ) ]]$,
    where $[[ pred_term1 ]] = [[ Owned < init1 , ct1 > ( ptrt1 ) ]]$ and
    $[[ pred_term2 ]] = [[ Padding < union tag , member > ( ptrt ) ]]$,\\
    $[[ res_val' ]] = [[ < pred_term1 , pred_term2 >  ]]$,
    and $[[ nR'' ]] = [[ _x : pred_term1 ( oarg1 ) , _x : pred_term2 ( oarg2 ) ]]$,
    by Lemma~\ref{subsec:non_cond_res_det_ctx_val}.\\[\baselineskip]

    Hence $[[ h'' ]] = [[ { pred_term1 ( oarg1 ) & None } + { pred_term2 ( oarg2 ) & None } ]]$
    (by Lemma~\ref{subsec:norm_ctx_det_heap}),
    so let $[[ h' ]] = [[ { pred_term ( oarg ) & None } ]]$.\\[\baselineskip]

    Let $[[ res_val ]] = [[ pred_term ]]$,
    and $[[ nR ]] = [[ _x : pred_term1 ( oarg ) ]]$, to prove:
    value typing using \ResSynPred{};
    heap typing using \HeapPredOwned{};
    reduction using \OpPredOpsForget.}}

\step{<1>9}{\case{\ResSynEmp, \ResSynPred, \ResSynIPred, \ResChkPhi.}{%
    \pf{} In these cases, $[[ h ]] = [[ h' ]]$, $[[ nR ]] = [[ nR' ]]$ and $[[ res_term ]] = [[ res_val ]]$.\\
    Typing holds by assumption; prove reduction using \OpResTVal{}.}}

\step{<1>10}{\case{\ResSynPredOps}{%
    \pf{} Both typing and reduction (using \OpResTPredOps{}) hold by
    induction.}}

\step{<1>11}{\case{\ResSynSepConj, \ResChkSepConj.}{%
    $[[ res ]] = [[ res1 * res2 ]]$,\\
    $[[ res_term ]] = [[ < res_term1 , res_term2 > ]]$,\\
    $[[ h ]] = [[ h1 + h2 ]]$, so $[[ nR ]] = [[ nR1 , nR2 ]]$,\\
    $[[ alloct |- h1 <= nR1 ]]$ and $[[ alloct |- h2 <= nR2 ]]$.}}

    \begin{pfproof}

    \step{<2>1}{%
        $ [[ exists ]] [[ h1' ]] , [[ nR1' ]] , [[ res_val1 ]] \ldots [[ /\ ]] ( [[ forall ]] [[ f1 ]] \ldots )$\\
        $ [[ exists ]] [[ h2' ]] , [[ nR2' ]] , [[ res_val2 ]] \ldots [[ /\ ]] ( [[ forall ]] [[ f2 ]] \ldots )$\\
        \pf{} By induction.}

    \step{<2>2}{%
        $[[ alloct | < h1 + h2 + f ; res_term1 > ||v < h1' + h2 + f ; res_val1 > ]]$.\\
        $[[ term' | < h1' + h2 + f ; res_term > ||v < h1' + h2' + f ; res_val2 > ]]$.\\
        \pf{} Instantiate $[[ f1 ]]$ with $[[ h2 + f ]]$, and $[[ f2 ]]$ with, $[[ h1' + f ]]$.}

    \step{<2>3}{\pflet{%
        $[[ res_val ]] = [[ < res_val1 , res_val2 > ]]$,
        $[[ nR' ]] = [[ nR1' , nR2' ]]$,
        and $[[ h' ]] = [[ h1' + h2' ]]$.}
        Prove value typing using \ResSynSepConj{} / \ResChkSepConj; heap typing
        using \HeapConcat; reduction using \stepref{<2>2} and \OpResTSepPair.}

    \end{pfproof}

\step{<1>12}{\case{\ResChkPack}{%
    \pf{} Like \PredOpsIterate, but with:\\
    $[[ res_term ]] = [[ pack ( oarg , res_term' ) ]]$,
    $[[ res ]]      = [[ exists y : base_type .: res'' ]]$,
    $[[ res' ]]     = [[ oarg / y ( res'' ) ]]$\\
    $[[ res_val ]]  = [[ pack ( oarg , res_val' ) ]]$.
    Value and heap typing hold by induction; prove reduction using \OpResTPack.}}

\step{<1>13}{\case{\ResSynFold}{%
    \pf{} Like \PredOpsIterate, but with:\\
    $[[ P ( a ) = </ xi : _bti // i /> , y : _bt  |-> res'' ]]$\\
    $[[ res_term ]]= [[ fold res_term' : a ( </ iargi // i /> ) ( oarg ) ]]$\\
    $[[ res ]]     = [[ a ( </ iargi // i /> ) ( oarg ) ]]$\\
    $[[ res' ]]    = [[ [ oarg / y , [ </ iargi / xi // i /> ] ] ( res'' ) ]]$.\\[\baselineskip]

    $[[ exists ]] [[ h1 ]] , [[ nR' ]] , [[ res_val' ]] .\:$\\
    \begin{enumerate}
    \item $[[ cdot ; L0 ; N ; nR' |- res_val' <= res' ]]$
    \item $[[ alloct |- h1 <= nR' ]]$
    \item $[[ forall ]] [[ f ]] .\: [[ alloct | < h + f ; res_term > ||v < h1 + f ; res_val' > ]]$
    \end{enumerate}
    (by induction).\\[\baselineskip]

    Let $[[ res_val ]] = [[ a ( iargs ) ]]$,
    $[[ nR' ]] = [[ _x : a ( iargs ) ( oarg ) ]]$
    and $[[ h' ]] = [[ { a ( iargs ) ( oarg ) & res_val' & h1 } ]]$,
    to prove: value typing using \ResSynPred; heap typing using \HeapPredOther.\\
    Since $[[ footprint_of res_val' in h1 + f ~> h1 REM f ]]$ by
    \lemmaref{subsec:wt_res_val_det_footprint}, prove reduction using \OpResTFold.}}

\step{<1>14}{\case{\ResChkIfTrue, \ResChkIfFalse}{%
    \pf{} By induction with $[[ res' ]]$ as $[[ res1 ]]$ or $[[ res2]]$ respectively.
    This is exhaustive because only variables can synthesise under-determined conditional
    resources and those are excluded by assumption of $[[ res_term ]]$ being closed.}}

\step{<1>15}{\case{\ResChkSwitch}{%
    \pf{} By induction on the synthesising judgement.}}

\end{pfproof}

\subsection{Resource term reduction is deterministic}\label{subsec:res_term_red_det}

\pfsketch{ Induction over the definition: it is syntax directed.}

\subsection{Resource term reduction is isolated}\label{subsec:res_term_red_isolated}

If $[[ res_term ]]$ is closed, $[[ cdot ; L0 ; N ; nR |- res_term <= res ]]$,
$[[ alloct |- h <= nR ]]$ and $[[ alloct | < h + f ; res_term > ||v < heap ; res_val > ]]$
then $[[ exists ]] [[ h' ]] , [[ nR' ]] [[ .: ]]
[[ heap ]] = [[ h' + f ]]
[[ /\ ]] ( [[ alloct |- h' <=  nR' ]] )
[[ /\ ]] ( [[ cdot ; L0 ; N ; nR' |- res_val <= res ]] )$.

\pf{} This simply the composition of \lemmaref{subsec:res_term_red_det} and \lemmaref{subsec:res_term_progress}.

\section{Progress}

\subsection{\texorpdfstring{$[[ res ~ res' ]]$}{ res ∼ res' } is an equivalence relation}\label{subsec:rel_res_eqrel}

\pfsketch{ By induction and $[[ term ~ term' ]]$ assumed to be an equivalence relation
(see Section~\ref{sec:proof_judge} \nameref{sec:proof_judge}).}

\subsection{\texorpdfstring{$[[ res ~ res' ]]$}{ res ∼ res' } is preserved by substitution}\label{subsec:rel_res_pres_sub}

If $[[ x ~ y ]]$ in $[[ res ~ res' ]]$ and $[[ term ~ term' ]]$ then
$[[ term / x ( res ) ~ term / y ( res' ) ]]$.

\pfsketch{ By induction and $[[ term ~ term' ]]$ assumed to be preserved by substitution
(see Section~\ref{sec:proof_judge} \nameref{sec:proof_judge}).}

\subsection{Well-typed spines produce substitutions and the same return type}\label{subsec:wt_spine_sub}

\begin{pfproof}

\assume{%
    $[[ cdot ; L0 ; N ; nR |- </ xi = spine_elemi // i /> :: fon >> subs1 ; ret1 ]]$\\
    $[[ alloct ; h <= N ; nR ]]$\\
    $[[ alloct | </ xi = spine_elemi // i /> :: fon >> < subs2 ; ret2 > ]]$.\\[\baselineskip]}

\prove{%
    $[[ subs1 ]] = [[ subs2 ]]$, $[[ ret1 ]] = [[ ret2 ]]$.\\[\baselineskip]}

\pfsketch{ Induction over the typing judgement.\\[\baselineskip]}

\end{pfproof}

\subsection{Well-typed values pattern-match successfully}\label{subsec:wt_values_pat_match}

Note that the definition of $[[ term ~ term' ]]$ is not explicitly stated;
see Section~\ref{sec:proof_judge} (\nameref{sec:proof_judge}) for more details.

$[[C]]; [[L]]$ need to be arbitrary for induction: because the pattern-matching
rules are monadic in them because types can be dependent on computational and
logical variables. If we had type-dependencies on resources, this too would be 
arbitrary (not normalised).

\begin{pfproof}

\assume{\begin{pfenum}
    \item $[[ C ; L ; N |- </ ret_pati // i /> : ret ~> C' ; L' ; N' ; R' ]]$
    \item $[[ </ ret_pati // i /> ]]$ is exhaustive
    \item $[[ fon ~ ret ]]$
    % res_terms have to be closed for progress/type-pres
    \item $[[ cdot ; L0 ; N ; nR |- to_param </ ret_termi // i /> :: fon >> psi ; I ]]$
    \item $[[ alloct ; h <= N ; nR ]]$
    \end{pfenum}\leavevmode\\}

\prove{$[[ exists ]] [[ h' ]] , [[ subs ]] .\:$\\
    $\quad [[ forall ]] [[ f ]] [[ .: ]] [[ < h + f ; </ ret_pati = ret_termi // i /> > ~> < h' + f ; subs > ]]$\\
    $\quad [[ exists ]] [[ nR' ]] [[ .: ]]$\\
    $\qquad [[ alloct |- h' <= nR' ]] [[ /\ ]] [[ cdot ; L0 ; N ; nR' |- subs <= ( C' ; L' ; R' )  ]]$.\\[\baselineskip]}

\pfsketch{ Induction over the pattern-matching judgement.\\[\baselineskip]}

% C ; L ; N |- </ ret_pati // i /> : ret ~> C' ; L' ; N' ; R'        | exists h' , subs .
% </ ret_pati // i /> is exhaustive                                  |   forall f .: < h + f ; </ ret_pati = ret_termi // i /> > ~> < h' + f ; subs >
% fon ~ ret                                                          |   exists nR' .
% cdot ; L0 ; N ; nR |- </ ret_termi // i /> :: fon >> I             |     alloct |- h' <= nR'
% alloct |- h <= nR                                                  |     C ; L ; N ; nR' |- subs <= ( C' ; L' ; R' )


\step{<1>1}{\case{\PatRetEmpty}{%
    $[[ C ; L ; N |- : I ~> cdot ; cdot ; cdot ; cdot ]]$\\
    which means $[[ fon ]] = [[ I ]]$ (by inversion, \RelRetI)\\
    and so $[[ cdot ; L0 ; N ; cdot |- :: I >> cdot ; I ]]$ (by inversion, \SpineRet),\\
    and $[[ h ]] = [[ cdot ]]$ (by Lemma~\ref{subsec:norm_ctx_det_heap}).\\
    Let $[[ h' ]] = [[ cdot ]]$, to step with \SubsPatRetEmpty.\\
    Let $[[ nR' ]] = [[ cdot ]]$, to type $[[ h' ]]$ with
    \HeapEmpty{} and $[[ subs ]]$ with \SubsChkEmpty.}}

\step{<1>2}{\case{\PatRetComp}{%
    $[[ C ; L ; N |- comp pat , </ ret_patj // j /> : sigma y : base_type .: ret ~> C1 , C2 ; L2 ; N2 ; R2 ]]$\\
    which means $[[ fon ]] = [[ pi x : base_type .: fon' ]]$ (by inversion, \RelRetComp),\\
    and so $[[ cdot ; L0 ; N ; nR |- to_param pval , </ ret_termj // j /> :: pi x : base_type .: fon' >> psi ; I ]]$
    (by inversion, \SpineComp).\\[\baselineskip]

    $[[ pat : base_type ~> C1 with term1 ]]$ (from the pattern-matching assumption),\\
    $[[ pat ]]$ is exhaustive (from the exhaustive asumption),\\
    and $[[ cdot |- pval => base_type ]]$ (from the spine typing assumption),\\
    imply $[[ term1 ~ inj pval ]]$, $[[ pat = pval ~> subs1 ]]$\\
    and $[[ cdot ; cdot ; cdot ; cdot |- subs1 <= ( C1 ; cdot ; cdot ) ]]$
    (by the nested proof below).\\[\baselineskip]

    $[[ C1 ; L0 ; N |- </ ret_patj // j /> : term1 / y ( ret' ) ~> C2 ; L2 ; N2 ; R2 ]]$
    (from the pattern-matching assumption),\\
    $[[ forall term1 ~ inj pval .: pval / x ( fon' ) ~ term1 / y ( ret' ) ]]$
    (from the related assumption),\\
    $[[ cdot ; L0 ; N ; nR |- to_param </ ret_termj // j /> :: pval / x ( fon' ) >> psi ; I ]]$
    (from the spine typing assumption),\\
    and $[[ alloct |- h <= nR ]]$,
    imply $[[ exists ]] [[h'']], [[subs2]] .\: [[ < h + f ; </ ret_patj = ret_termj // j /> > ~> < h'' + f ; subs2 > ]]$\\
    and that $[[ exists ]] [[ nR' ]]$ such that
    $[[ alloct |- h' <= nR' ]]$ and $[[ C1 ; L0 ; N ; nR' |- subs2 <= ( C2 ; L2 ; R2 ) ]]$
    (by induction, then~\lemmaref{sec:weakening}).\\[\baselineskip]

    Since $[[ cdot ; L0 ; [ id , subs1 ] ( N ) ; nR' |- [ id , subs1 ] <= ( C1 ; L0 ; nR' ) ]]$
    (by \SubsChkConcat{}
    and $[[ [ id , subs1 ] ( N ) ]] = [[ N ]]$,
    because $[[ N ]]$ is well-scoped / does
    not contain any variables from $[[ C1 ]]$)
    we have $[[ cdot ; L0 ; N ; nR' |- subs1 ( subs2 ) <= ( C2 ; L2 ; subs1 ( R2 ) ) ]]$
    (by \lemmaref{subsec:sub}).\\[\baselineskip]

    \pflet{$[[ subs ]] = [[ [ subs1 , subs2 ] ]]$ to step with \SubsPatRetComp.}
    Since $[[ nR' ]] = [[ subs1 ( nR' ) ]]$ (for same reason as $[[N]]$)
    we have $[[ cdot ; L0 ; N ; nR' |- subs <= ( C1 , C2 ; L2 ; R2 ) ]]$
    by~\lemmaref{sec:weakening} and \SubsChkConcat.}}

    \begin{pfproof}

    \assume{\begin{pfenum}
        \item $[[ pat : base_type ~> C1 with term1 ]]$
        \item $[[ pat ]]$ is exhaustive
        \item $[[ cdot |- pval => base_type ]]$
    \end{pfenum}\leavevmode\\}

    \prove{\begin{pfenum}
        \item $[[ term1 ~ inj pval ]]$
        \item $[[ exists ]] [[ subs ]] [[ .: ]] [[ pat = pval ~> subs ]]$
        and $[[ cdot ; cdot ; cdot ; cdot |- subs <= ( C1 ; cdot ; cdot ) ]]$.
    \end{pfenum}\leavevmode\\[\baselineskip]}

    \step{<2>1}{\case{\PatCompWild}{%
        \pf{} $[[ term1 ]]$ is a wildcard (fresh variable) which would unfiy with
        $[[ pval ]]$; let $[[ subs ]] = [[ cdot ]]$ for \SubsPatValueWild{}
        / \SubsChkEmpty.}}

    \step{<2>2}{\case{\PatCompSym}{%
        \pf{} $[[ term1 ]] = [[ x ]]$, a fresh pattern variable, so would unify with $[[ pval ]]$;\\
        let $[[ subs ]] = [[ pval / x ]]$ for \SubsPatValueSym{} /
        \SubsChkComp{} (using $[[ cdot |- pval => base_type ]]$).}}

    \step{<2>3}{\case{\PatCompNil}{%
        \pf{} $[[ term1 ]] = [[ nil ]]$, and by inversion on the typing
        assumption, and then by exhaustiveness,
        $[[ pval ]] = [[ Nil base_type () ]]$, so would unify;
        let $[[ subs ]] = [[ cdot ]]$ for \SubsPatValueNil{}
        / \SubsChkEmpty.}}

    \step{<2>4}{\case{\PatCompCons}{%
        \pf{} $[[ term1 ]] = [[ term11 :: term12 ]]$, and by inversion on the
        typing assumption, and then by exhaustiveness,
        $[[ pval ]] = [[ Cons ( pval1 , pval2 ) ]]$.
        By induction (1) they would unify and (2)
        let $[[ subs ]] = [[ [ subs1 , subs2 ] ]]$ for \SubsPatValueCons{}
        / \SubsChkComp{} and \SubsChkConcat{} (both are independent).}}

    \step{<2>5}{\case{\PatCompTuple}{%
        \pf{} $[[ term1 ]] = [[ ( </ termi // i /> ) ]]$, and by inversion
        on the typing assumption, $[[ pval ]] = [[ Tuple ( </ pvali // i /> ) ]]$.
        By induction (1) they would unify\\
        (2) let $[[ subs ]] = [[ [ </ subsi // i /> ] ]]$
        for \SubsPatValueTuple{} / \\SubsChkComp{} and \SubsChkConcat.}}

    \step{<2>6}{\case{\PatCompArray}{%
        \pf{} Similar to \PatCompTuple, but with \SubsPatValueArray.}}

    \end{pfproof}

\step{<1>3}{\case{\PatRetLog}{%
    $[[ C ; L ; N |- log y' , </ ret_patj // j /> : exists y : base_type .: ret ~> C2 ; y' : base_type , L2 ; N2 ; R2 ]]$\\ % chktex 35
    which means $[[ fon ]] = [[ forall x : base_type .: fon' ]]$ (by inversion, \RelRetLog)\\
    and so $[[ cdot ; L0 ; N ; nR |- to_param oarg , </ ret_termj // j /> :: forall x : base_type .: fon' >> psi ; I ]]$
    (by inversion, \SpineLog).\\[\baselineskip]

    $[[ C ; L , y : base_type ; N |- </ ret_patj // j /> : ret' ~> C2 ; L2 ; N2 ; R2 ]]$
    (from the pattern-matching assumption),\\
    $[[ forall oarg ~ oarg' .: oarg / x ( fon' ) ~ oarg' / y' ( ret' ) ]]$
    (from the related assumption),\\
    $[[ cdot ; L0 ; N ; nR |- to_param </ ret_termj // j /> :: oarg / x ( fon' ) >> psi ; I ]]$
    (from the spine typing assumption)\\
    and $[[ alloct |- h <= nR ]]$,
    imply $[[ < h + f ; </ ret_patj = ret_termj // j /> > ~> < h' + f ; subs > ]]$\\
    and $[[ exists]] [[ nR' ]]$ such that
    $[[ alloct |- h' <= nR' ]]$
    and $[[ cdot ; L0 , y' : base_type ; N ; nR' |- subs2 <= ( C2 ; L2 ; R2 ) ]]$
    (by induction, then~\lemmaref{sec:weakening}).\\[\baselineskip]

    Since $[[ cdot ; L0 |- oarg => base_type ]]$, and $[[ [ id , oarg / y' ] ( N ) ]] = [[ N ]]$
    (by \SubsChkConcat{} and because it is well-scoped / doesn't refer to $[[ y' ]]$)
    we have $[[ cdot ; L0 ; [ id , oarg / y' ] ( N ) ; nR' |- [ id , oarg / y' ] <= ( cdot ; L0 , y' : base_type ; nR' ) ]]$
    (by~\SubsChkLog, \SubsChkRes, \SubsChkConcat)
    and so $[[ cdot ; L0 ; N ; nR' |- oarg / y' ( subs2 ) <= ( C2 ; L2 ; oarg / y' ( R2 ) ) ]]$
    (by~\lemmaref{subsec:sub}).\\[\baselineskip]

    \pflet{$[[ subs ]] = [[ [ oarg / y' , subs2 ] ]]$ to step with \SubsPatRetLog.}
    Since $[[ nR' ]] = [[ subs1 ( nR' ) ]]$ (for same reason as $[[N]]$)
    $[[ cdot ; L0 ; N ; nR' |- subs <= ( C2 ; y' : base_type , L2 ; R2 ) ]]$
    by \SubsChkConcat.}}

\step{<1>4}{\case{\PatRetPhi}{%
    $[[ C ; L ; N |- </ ret_pati // i /> : term' /\ ret' ~> C' ; L' ; N' , term' ; R' ]]$\\
    which means $[[ fon ]] = [[ term -) fon' ]]$ (by inversion, \RelRetPhi),\\ % chktex 9
    and so $[[ cdot ; L0 ; N ; nR |- to_param </ ret_termj // j /> ::  term --o fon' >> psi ; I ]]$
    (by inversion, \SpineRes).\\[\baselineskip]

    $[[ C ; L ; N |- </ ret_pati // i /> : ret' ~> C' ; L' ; N' , term' ; R' ]]$ % chktex 39
    (from the pattern-matching assumption)\\
    $[[ fon' ~ ret' ]]$ (from the related assumption),\\ % chktex 39
    $[[ cdot ; L0 ; N ; nR |- to_param </ ret_termj // j /> :: fon' >> psi ; I ]]$
    (from the spine typing assumption)\\
    imply $[[ < h + f ; </ ret_pati = ret_termi // i /> > ~> < h' + f ; subs > ]]$ % chktex 39
    and the heap and substitution typings (by induction).}} % chktex 9

\step{<1>5}{\case{\PatRetRes}{%
    $[[ C ; L ; N |- reso res_pat , ret_pat : res' *o ret' ~> C4 ; L3, L4 ; N3, N4 ; R3 , R4 ]]$\\
    which means $[[ fon ]] = [[ res --o fon' ]]$ (by inversion, \RelRetRes),\\
    and so $[[ cdot ; L0 ; N ; nR1 , nR2 |- to_param res_term , spine ::  res --o fon >> psi ; I ]]$
    (by inversion, \SpineRes),
    and $[[ h ]] = [[ h1 + h2 ]]$ where $[[ alloct |- h1 <= nR1 ]]$ and $[[ alloct |- h2 <= nR2 ]]$
    (by Lemma~\ref{subsec:norm_ctx_det_heap}).\\[\baselineskip]

    $[[ cdot ; L0 ; N ; nR1 |- res_term <= res ]]$ (from the spine typing assumption)\\
    and $[[ alloct |- h1 <= nR1 ]]$, imply
    $[[ exists ]] [[ res_val ]] , [[ nR1' ]] , [[ h1'  ]]$ such that
    $[[ alloct |- h1' <= nR1' ]]$,  $[[ cdot ; L0 ; N ; nR1' |- res_val <= res ]]$
    and $[[ alloct | < h1 + h2 + f ; res_term > ||v < h1' + h2 + f ; res_val >  ]]$
    (by \lemmaref{subsec:res_term_progress}).\\[\baselineskip]

    $[[ L ; N |- res_pat : res' ~> L3 ; N3 ; R3 ]]$ (from the pattern matching assumption),\\
    $[[ res ~ res' ]]$ (from the related assumption),\\
    $[[ cdot ; L0 ; N ; nR1' |- res_val <= res ]]$
    and $[[ alloct |- h1' <= nR1' ]]$, imply\\
    $[[ exists ]] [[ h1'' ]], [[subs1]], [[ nR1'' ]]$ such that
    $[[ < h1' + h2 + f ; res_pat = res_val > ~> < h1'' + h2 + f ; subs1 > ]]$,
    $[[ alloct |- h1' <= nR1'' ]]$,
    and $[[ cdot ; L0 ; N ; nR1'' |- subs1 <= ( cdot ; L3 ; R3 ) ]]$
    (by the nested proof below).\\[\baselineskip]

    $[[ C ; L ; N |- </ ret_patj // j /> : ret' ~> C4 ; L4 ; N4 ; R4 ]]$
    (from the pattern matching assumption),\\
    $[[ fon' ~ ret' ]]$ (from the related assumption),\\
    $[[ cdot ; L0 ; N ; nR2 |- to_param </ ret_termj // j /> :: fon' >> psi ; I ]]$
    (from the spine typing assumption),\\
    and $[[ alloct |- h2 <= nR2 ]]$,
    imply $[[ < h2 + h1'' + f ; </ ret_patj = ret_termj // j /> > ~> < h2' + h1'' + f ; subs2 > ]]$
    and $[[ exists ]] [[ nR2' ]]$ such that
    $[[ alloct |- h2' <= nR2' ]]$,
    and $[[ cdot ; L0 , L3 ; N ; nR2' |-  subs2 <= ( C4 ; L4 ; R4 ) ]]$
    (by induction and \lemmaref{sec:weakening}).\\[\baselineskip]

    \pflet{$[[ subs11]]$ where $[[ cdot ; L0 ; N ; cdot |- subs11 <= ( cdot ; L3 ; cdot ) ]]$
    (by \lemmaref{subsec:sub_split}).\\
        $[[ psi ]] = [[ [ allocv / allocv , subs11 , id ] ]]$ where
        $[[ cdot ; L0 ; psi ( N ) ; nR2' |- psi <= ( cdot ; L0 , L3 ; nR2' ) ]]$ so
        $[[ psi ( term ) = subs1 ( term ) ]]$ for any $[[term]]$ $[[ cdot ; L0 , L3 |- term => base_type ]]$
        (because $[[ psi ( N ) ]] = [[N]]$ since $[[N]]$ does not refer to any variables from $[[L3]]$).}
    Hence, $[[ cdot ; L0 ; psi ( N ) ; nR2' |- psi ( subs2 ) <= ( C4 ; L4 ; psi ( R4 ) ) ]]$
    (by~\lemmaref{subsec:sub}).\\
    Which implies $[[ cdot ; L0 ; N ; nR2' |- subs1 ( subs2 ) <= ( C4 ; L4 ; subs1 ( R4 ) ) ]]$
    (since resources and constraints cannot depend oh resource variables).\\[\baselineskip]

    \pflet{$[[ h' ]] = [[ h1'' + h2' ]]$\\
        $[[ subs ]] = [[ [ subs1 , subs2 ] ]]$ to step with \SubsPatRetRes.\\
        $[[ nR' ]] = [[ nR1'' , nR2' ]]$.}
    So $[[ alloct |- h' <= nR' ]]$ by \HeapConcat\\
    and $[[ cdot ; L0 ; N ; nR' |- subs <= ( C4 ; L3 , L4 ; R3 , R4 ) ]]$ by \SubsChkConcat{}.\\}}

    \begin{pfproof}

    % exists h', nR' such that
    %   < h + f ; res_pat = res_val > ~> < h' + f ; subs >
    %   C ; L ; N |- h' <= nR',
    %   C ; L ; N ; nR' |- subs <= ( cdot ; L3 ; R3 )

    \assume{\begin{pfenum}
        \item $[[ L ; N |- res_pat : res' ~> L' ; N' ; R' ]]$
        \item $[[ res ~ res' ]]$
        \item $[[ exists ]] [[ nR ]] .: ( [[ cdot ; L0 ; N ; nR |- res_val <= res ]] )
            [[ /\ ]] ( [[ alloct ; h <= N ; nR ]] )$
    \end{pfenum}\leavevmode\\}

    \prove{$[[ exists ]] [[ h' ]] , [[ subs ]] [[ .: ]]$\\
        $\quad [[ forall ]] [[ f ]] [[ .: ]] [[ < h + f ; res_pat = res_val > ~> < h' + f ; subs > ]]$\\
        $\quad [[ exists ]] [[ nR' ]] [[ .: ]]
            [[ alloct |- h' <= nR' ]]
            [[ /\ ]] [[ cdot ; L0 ; N ; nR' |- subs <= ( cdot ; L' ; R' ) ]]$.\\[\baselineskip]}

    \step{<2>1}{\case{\PatResMatchFold}{%
        $[[ L0 ; N |- fold ( res_pat' ) : a ( </ iarg'i // i /> ) ( oarg' ) ~> L' ; N' ; R' ]]$\\
        which means $[[ res ]] = [[ a ( </ iargi // i /> ) ( oarg ) ]]$
        (by inversion, \RelResPred)\\
        and so $[[ nR ]] = [[ _x : a ( </ iargi // i /> ) ( oarg ) ]]$ and
        $[[ res_val ]] = [[ a ( </ iarg2i // i /> ) ]]$
        (by Lemma~\ref{subsec:non_cond_res_det_ctx_val}).}}

        \begin{pfproof}

        \step{<3>1}{$[[ h ]] = [[ { a ( </ iargi // i /> ) ( oarg ) & def & heap } ]]$\\
            \pf{} $[[ a != Owned < _init , ct > ]]$ (from the pattern-matching assumption),
            and \lemmaref{subsec:norm_ctx_det_heap}.}

        \step{<3>2}{$[[ exists ]] [[ nR1' ]] [[ .: ]]$
        \begin{pfenum}
            \item $[[ P ( a ) = </ xi : base_typei // i  /> , y : base_type |-> res'' ]]$
            \item $[[ cdot ; cdot ; cdot ; nR1' |- def <= [ oarg / y , [ </ iarg / xi // i /> ] ] ( res'' ) ]]$
            \item $[[ alloct |- heap <= nR1' ]]$
        \end{pfenum}
        \pf{} By inversion, $[[ alloct |- h <= nR ]]$ is \HeapPredOther.}

        \step{<3>3}{$[[ L0 ; N |- res_pat' : [ oarg' / y , [ </ iarg'i / xi // i /> ] ] ( res'' ) ~> L ; N ; R ]]$\\
            \pf{} By inversion on the pattern-matching assumption.}

        \step{<3>4}{$[[ [ oarg / y , [ </ iarg / xi // i /> ] ] ( res'' ) ~ [ oarg' / y , [ </ iarg'i / xi // i /> ] ] ( res'' ) ]]$\\
            \pf{} By Lemma~\ref{subsec:rel_res_pres_sub}, using $[[ res'' ~ res'' ]]$
            (by Lemma~\ref{subsec:rel_res_eqrel})
            and $[[ ptrt ~ ptrt' ]]$, $[[ ( </ iargi // i /> ) ~ ( </ iarg'i // i /> ) ]]$
            and $[[ oarg ~ oarg' ]]$.}

        \step{<3>5}{$[[ < heap + f ; res_pat = res_val > ~> < h' + f ; subs > ]]$\\
            \pf{} By induction, using \stepref{<3>2}, \stepref{<3>3} and \stepref{<3>4}.}

        \step{<3>6}{Step with \SubsPatResFold.}

        \step{<3>7}{$[[ h' ]], [[ nR' ]]$ as given by induction.}

        \end{pfproof}

    \step{<2>2}{\case{\PatResMatchEmp{} / \PatResMatchPhi}{
        $[[ res ]] = [[ emp ]] \textrm{ or } [[ term ]]$ (by inversion, \RelResEmp{} / \RelResPhi)
        and so $[[ res_val ]] = [[ emp ]] \textrm{ or } [[ TERM ]]$ and $[[ nR ]] = [[ cdot ]]$
        (by Lemma~\ref{subsec:non_cond_res_det_ctx_val}),
        meaning $[[ h ]] = [[ cdot ]]$ (by Lemma~\ref{subsec:norm_ctx_det_heap}).\\

        \pf{} Let $[[ h' ]] = [[ cdot ]]$ to step with \SubsPatResEmp{} / \SubsPatResPhi{}.\\
        $[[ nR' ]] = [[ cdot ]]$, so \HeapEmpty{} and \SubsChkEmpty{} suffice.}}

    \step{<2>3}{\case{\PatResMatchIfTrue{} / \PatResMatchIfFalse}{%
        Only showing true case, false case is symmetric.\\[\baselineskip]

        $[[ res' ]] = [[ if term' then res'1 else res'2 ]]$ so\\
        $[[ res ]] = [[ if term then res1 else res2 ]]$ (by inversion, \RelResIf).\\[\baselineskip]

        Since $[[ smt ( N => term' ) ]]$ (from the pattern-matching assumption)
        and $[[ term' ~ term ]]$, we can conclude the typing
        assumption must be \ResChkIfTrue.\\[\baselineskip]

        From there, we proceed by induction.}}

    \step{<2>4}{\case{\PatResMatchVar}{%
        \pf{} Let $[[ h' ]] = [[ h ]]$ to step with \SubsPatResVar.\\
        $[[ nR' ]] = [[ nR ]]$ so \SubsChkRes.}}

    \step{<2>5}{\case{\PatResMatchSepConj}{%
        $[[ L ; N |- < res_pat1 , res_pat2 > : res'1 * res'2 ~> L1, L2 ; N1 , N2 ; R1 , R2 ]]$\\[\baselineskip]
        $[[ res ]] = [[ res1 * res2 ]]$ (by inversion, \RelResSepConj)
        and $[[ cdot ; L0 ; N ; nR1 , nR1 |- < res_val1 , res_val2 > <= res1 * res2 ]]$
        (by Lemma~\ref{subsec:non_cond_res_det_ctx_val}),\\
        so $[[ h ]] = [[ h1 + h2 ]]$ where $[[ alloct |- h1 <= nR1 ]]$ and $[[ alloct |- h2 <= nR2 ]]$.\\[\baselineskip]

        By induction, obtain $[[ h1' ]]$ and $[[ h2' ]]$, and then let $[[ h' ]] = [[ h1' + h2' ]]$.
        Instantiate the frame, from the inductive hypothesis with $[[ h2 + f ]]$ and then $[[ h1' + f ]]$
        to conclude $[[ < h1 + h2 + f ; res_pat1 = res_val1 > ~> < h1' + h2 + f ; subs1 > ]]$ and
        $[[ < h2 + h1' + f ; res_pat2 = res_val2 > ~> < h2' + h1' + f ; subs2 > ]]$
        to step with \SubsPatResPair.\\

        \pflet{$[[ nR' ]] = [[ nR1' , nR2' ]]$ (obtained from induction).}
        We then have and $[[ alloct |- h1' + h2' <= nR' ]]$
        and (since $[[ subs1 ( R2 ) ]] = [[ R2 ]]$ because it can not refer to $[[ L1 ]]$)
        $[[ cdot ; L0 ; N ; nR' |- [ subs1 , subs2 ] <= ( cdot ; L1 , L2 ; R1 , R2 ) ]]$.}}

    \step{<2>6}{\case{\PatResMatchPack}{%
        $[[ L ; N |- pack ( x , res_pat' ) : exists y' : base_type .: res1' ~> x : base_type ,  L' ; N' ; R' ]]$\\[\baselineskip]

        $[[ res ]] = [[ exists y : base_type .: res1 ]]$ (by inversion, \RelResExists)
        and $[[ cdot ; L0 ; N ; nR |- pack ( oarg , res_val' ) <= exists y : base_type .: res1 ]]$
        (by Lemma~\ref{subsec:non_cond_res_det_ctx_val}).\\

        $[[ L , x : base_type ; N |- res_pat' : x / y' ( res1' ) ~> L' ; N' ; R' ]]$
        (from the pattern-matching assumption),
        $[[ cdot ; L0 ; N ; nR |-  res_val' <= oarg / y ( res1 ) ]]$
        (from the typing assumption),
        $[[ forall term ~ term' .: term / y ( res1 ) ~ term' / y' ( res1' ) ]]$
        (from the related assumption),
        $[[ oarg ~ x ]]$
        imply $[[ exists ]] [[ h' ]] , [[ subs' ]] .\: [[ forall ]] [[ f ]] \ldots$
        $[[ exists ]] [[ nR' ]] [[ .: ]] [[ alloct |- h' <= nR' ]]$ and
        $[[ cdot ; L0 , x : base_type ; N ; nR'' |- subs' <= ( cdot ; L' ; R' )]]$
        (by induction, then \lemmaref{sec:weakening}).\\[\baselineskip]

        Since $[[ cdot ; L0 |- oarg => base_type ]]$, and $[[ oarg / x ( N ) ]] = [[ N ]]$
        (because it is well-scoped / doesn't refer to $[[ x ]]$)
        and $[[ cdot ; L0 ; [ id , oarg / x ] ( N ) ; nR' |- [ id , oarg / x  ] <= ( cdot ; L0 , x : base_type ; nR' ) ]]$
        (by \SubsChkLog, \SubsChkRes, \SubsChkConcat),\\
        and $[[ cdot ; L0 ; N ; nR'' |- oarg / x ( subs' ) <= ( cdot ;  L' ; oarg / x ( R' ) ) ]]$
        (by \lemmaref{subsec:sub}).\\[\baselineskip]

        \pflet{$[[ subs ]] = [[ [ oarg / x , subs' ] ]]$ to step with \SubsPatResPack,\\
        and $[[ cdot ; L0 ; N ; nR''|- [ oarg / x , subs' ] <= ( cdot ; L' ;  R2 )  ]]$ by \SubsChkConcat.}}}

    \end{pfproof}

\end{pfproof}

\subsection{\texorpdfstring{$[[ to_fun ret ~ ret ]]$}{ to\_fun ret ∼ ret }}\label{subsec:tofun_ret_rel_ret}

\pfsketch{ Induction over $[[ ret ]]$.}

\subsection{Statement and proof}

\begin{pfproof}

\assume{%
    \begin{pfenum}
    \item $[[ cdot ; L0 ; N ; nR |- stmt <= ret ]]$
    \item All patterns in $[[ stmt ]]$ are exhaustive.
    \item All allocations succeed.
    \end{pfenum}\leavevmode\\}

\prove{%
    Either $[[ stmt ]]$ is a value $[[ < ret_terms > ]]$, or it is unreachable,
    or $[[ forall ]] [[ s ]] .\: ( [[ s <= N ; nR ]] ) [[ => ]]
    [[ exists ]] [[ s' ]] , [[ stmt' ]] [[ .: ]]
        [[ < s ; stmt > --> < s' ; stmt' > ]]$.\\[\baselineskip]}

\pfsketch{ Induction over the typing rules.\\[\baselineskip]}

\step{<1>1}{\case{%
    \nameref{subsec:value_typing_rules} (see~\ref{subsec:value_typing_rules}).
}{%
    \pf{} All these judgements/rules give types to syntactic values; and there
    are no operational rules corresponding to them (see Section~\ref{sec:opsem_judge}).}}

\step{<1>2}{\case{%
    \PureStmtUB\@.
}{%
    \pf{} This rule requires an inconsistent constraint context, and so would
    be unreachable.}}

\step{<1>3}{\case{%
    \PureExprPVal.
}{%
    \pf{} By assumption $[[ cdot |- pval1 => base_type]]$,
    so step with \OpPExprPVal.}}

\step{<1>4}{\case{%
    \PureExprCtorIvXOR\@.
}{%
    \pf{} By inversion on $[[ cdot |- pval1 => integer]]$,
    $[[pval1]]$ must be a $[[int1]]$ (\PureValObjInt).
    Similarly $[[pval2]]$ must be a $[[int2]]$,
    so step with \OpPExprCtorIvXOR.}}

\step{<1>5}{\case{\PureExprArrayShift.}{}}

    \begin{pfproof}

    \step{<2>1}{%
        $[[pval1]]$ must be a $[[ptr]]$; $[[pval2]]$ must be a $[[int]]$.\\
        \pf{} By inversion on the typing assumption and \PureValObjPtr{} and \PureValObjInt.}

    \step{<2>2}{%
        $[[ alloct |- smt ( x . base =< inj ptr' =< x . base + x . len ) ]]$ for $[[x def= alloct [ inj ptr . alloc_id ] ]]$.\\
        \pf{} By inversion on the typing assumption and $[[ alloct <= N ]]$.}

    \step{<2>3}{%
        Step with \OpPExprArrayShift.}

    \end{pfproof}

\step{<1>6}{\case{%
    \PureExprMemberShift.
}{%
    \pf{} $[[ pval ]]$ must be a $[[ ptr ]]$ so step with
    \OpPExprMemberShift.}}

\step{<1>7}{\case{%
    \PureExprPtrEq.
}{%
    \pf{} $[[ pval1 ]]$ must be a $[[ ptr1 ]]$,
    $[[ pval2 ]]$ must be a $[[ ptr2 ]]$, so step with
    \OpPExprPtrEq.}}

\step{<1>8}{\case{%
    \PureExprNot.
}{%
    \pf{} $[[ pval ]]$ must be a $[[ bool_value ]]$ so step with
    \OpPExprNotTrue{} or \OpPExprNotFalse.}}

\step{<1>9}{\case{%
    \PureExprArithBinop, \PureExprRelBinop.
}{%
    \pf{} $[[ pval1 ]]$ and $[[ pval2 ]]$ must be $[[ int ]]$s,
    so step with \OpPExprArithBinop{} or \OpPExprRelBinop{} respectively.}}

\step{<1>10}{\case{%
    \PureExprBoolBinop.
}{%
    \pf{} $[[pval1]]$ and $[[pval2]]$ must be $[[bool_value]]$s,
    so step with \OpPExprBoolBinop.}}

\step{<1>11}{\case{\PureExprCall.}{}}

    \begin{pfproof}

    \step{<2>1}{%
        \begin{pfenum}
        \item $[[ P ( name ) = </ xi // i /> |-> pstmt : pure_fun ]]$.
        \item $[[ cdot ; L0 ; N ; cdot |- </ xi = pvali // i /> :: pure_fun >> subs ; sigma y : base_type .: term /\ I ]]$.
        \end{pfenum}
    \pf{} By inversion on the assumption.}

    \step{<2>2}{%
        $[[ alloct | </ xi = pvali // i /> :: pure_fun >> < subs ; sigma y : base_type .: term /\ I > ]]$.\\
        \pf{} By Lemma~\ref{subsec:wt_spine_sub}.}

    \step{<2>3}{%
        Thus it can step with \OpPExprCall.}

    \end{pfproof}

\step{<1>12}{\case{\PureExprAssertUndef.}{}}

    \begin{pfproof}

    \step{<2>1}{%
        $[[ pval ]]$ must be a $[[ bool_value ]]$
        \pf{} By \PureValTrue, \PureValFalse.}

    \step{<2>2}{%
        $[[ smt ( N => inj pval ) ]]$.
        \pf{} By inversion on the assumption.}

    \step{<2>3}{%
        If it is $[[False]]$, then by the latter, we have an inconsistent
        constraints context, meaning the code is unreachable.}

    \step{<2>4}{%
        If it is $[[True]]$, we may step with \OpPExprAssertUndef.}

    \end{pfproof}

\step{<1>13}{\case{%
    \PureExprBoolToInteger.
}{%
    \pf{} $[[ pval ]]$ must be a $[[ bool_value ]]$ (\PureValTrue, \PureValFalse)
    and so step with \OpPExprBoolToIntegerTrue, \OpPExprBoolToIntegerFalse{} respectively.}}

\step{<1>14}{\case{%
    \PureExprWrapI.
}{%
    \pf{} $[[ pval ]]$ must be a $[[ int ]]$ (\PureValObjPtr) and so
    step with \OpPExprWrapI.}}

\step{<1>15}{\case{%
     \PureStmtPExpr, \PureStmtLet, \PureStmtIf, \PureStmtCase.
}{%
    \pf{} See  \StmtExpr, \StmtLet, \StmtIf, \StmtCase,
    case for more general proofs.}}

\step{<1>16}{\case{\ExprPure.}{%
}{%
    \pf{} By induction.}}

\step{<1>17}{\case{\ActionCreate.}{}}

    \begin{pfproof}

    \step{<2>1}{%
        $[[ pval ]]$ must be a $[[ int ]]$.\\
        \pf{} By \PureValObjInt.}

    \step{<2>2}{%
        $[[ h ]]$ must be $[[ cdot ]]$ (empty).\\
        \pf{} By \HeapEmpty.}

    \step{<2>3}{%
        Step with \OpActionCreate.\\
        \pf{} Since we assume all allocations succeed, $[[ addr ]]$ is
        constructible.  $[[ alloc_id ]]$ is simply a fresh allocation ID, and so
        $[[ ptr ]]$ can be constructed to satisfy the requirements.}

    \end{pfproof}

\step{<1>17a}{\case{\ActionAlloc.}{}}

    \begin{pfproof}

    \step{<2>1}{%
        $[[ pval1 ]]$ and $[[ pval2 ]]$ must both be $[[ int ]]$.\\
        \pf{} By \PureValObjInt.}

    \step{<2>2}{%
        $[[ h ]]$ must be $[[ cdot ]]$ (empty).\\
        \pf{} By \HeapEmpty.}

    \step{<2>3}{%
        Step with \OpActionAlloc.\\
        \pf{} Since we assume all allocations succeed, $[[ addr ]]$ is
        constructible.  $[[ alloc_id ]]$ is simply a fresh allocation ID, and so
        $[[ ptr ]]$ can be constructed to satisfy the requirements.}

    \end{pfproof}

\step{<1>18}{\case{\ActionLoad.}{}}

    \begin{pfproof}

    \step{<2>1}{%
        $[[ pval0 ]]$ must be a $[[ ptr ]]$.\\
        \pf{} By \PureValObjPtr.}

    \step{<2>2}{%
        $[[ cdot ; L0 ; N ; nR' |- res_term => term |- Init - ct -> inj pval1 ]] $.\\
        $[[ alloct |- smt ( ptrt = inj ptr ) ]]$.\\
        \pf{} By inversion on the typing assumption, $[[ alloct <= N ]]$ and \stepref{<2>1}.}

    \step{<2>3}{%
        $[[ exists ]] [[ h' ]], [[ nR' ]], [[ res_val ]] .\:$
        \begin{pfenum}
        \item $[[ alloct |- h' <= nR' ]]$
        \item $[[ alloct | < h ; res_term > ||v < h' ; res_val > ]]$
        \item $[[ cdot ; L0 ; N ; nR' |- res_val => term |- Init - ct -> inj pval1 ]]$
        \end{pfenum}
        \pf{} By \stepref{<2>2} and \lemmaref{subsec:res_term_progress}.}

    \step{<2>4}{%
        $[[ res_val ]] = [[ Owned < Init , ct > ( term ) ]]$.\\
        \pf{} By \lemmaref{subsec:non_cond_res_det_ctx_val}.}

    \step{<2>5}{%
        $[[ h' ]] = [[ { term |- Init - ct -> inj pval1 & None } ]]$.\\
        \pf{} By inversion on the term typing assumption in \stepref{<2>3} using
        \stepref{<2>4}, $[[ alloct |- h' <= nR' ]]$ and \lemmaref{subsec:norm_ctx_det_heap}.}

    \step{<2>6}{Step with \OpActionLoad.}

    \end{pfproof}


\step{<1>19}{\case{\ActionStore.}{%
}}

    \begin{pfproof}

    \step{<2>1}{%
        $[[ pval0 ]]$ must both be a $[[ ptr ]]$.\\
        \pf{} By \PureValObjPtr.}

    \step{<2>2}{%
        $[[ alloct |- smt ( representable ( ct , inj pval ) ) ]]$\\
        $[[ cdot ; L0 ; N ; nR |- res_term => term |- _init - ct -> _t ]]$\\
        $[[ alloct |- smt ( ptrt = inj ptr ) ]]$.\\
        \pf{} By inversion on the typing assumption, $[[ alloct <= N ]]$ and \stepref{<2>1}.}

    \step{<2>3}{%
        $[[ exists ]] [[ h' ]], [[ nR' ]], [[ res_val ]] .\:$
        \begin{pfenum}
        \item $[[ alloct |- h' <= nR' ]]$
        \item $[[ alloct | < h ; res_term > ||v < h' ; res_val > ]]$
        \item $[[ cdot ; L0 ; N ; nR' |- res_val => term |- _init - ct -> _t ]] $.
        \end{pfenum}
        \pf{} By \stepref{<2>2} and \lemmaref{subsec:res_term_progress}.}

    \step{<2>4}{%
        $[[ res_val ]] = [[ Owned < _init , ct > ( term ) ]]$.\\
        \pf{} By \lemmaref{subsec:non_cond_res_det_ctx_val}.}

    \step{<2>5}{%
        $[[ h' ]] = [[ { term |- _init - ct -> _t & None } ]]$.\\
        \pf{} By inversion on the term typing assumption in \stepref{<2>3},
        $[[ alloct |- h' <= nR' ]]$ and \lemmaref{subsec:norm_ctx_det_heap}.}

    \step{<2>6}{Step with \OpActionStore.}

    \end{pfproof}

\step{<1>20}{\case{\ActionKillStatic}{}}

    \begin{pfproof}

    \step{<2>1}{%
        $[[pval]]$ must be a $[[ ptr ]]$.\\
        \pf{} By \PureValObjPtr.}

    \step{<2>2}{%
        $[[ cdot ; L0 ; N ; nR |- res_term => ptrt1 |- _init - ct -> _t * Alloc ( term ) ( oarg ) ]]$\\
        $[[ term' def= ptrt . addr = oarg . base /\ sizeof ct = oarg . len ]]$ \\
        $[[ alloct |- smt ( ptrt = inj ptr /\ ptrt . alloc_id = term /\ term' ) ]]$.\\
        \pf{} By inversion on the typing assumption, $[[ alloct <= N ]]$ and \stepref{<2>1}.}

    \step{<2>3}{%
        $[[ exists ]] [[ h' ]], [[ nR' ]], [[ res_val ]] .\:$\\
        \begin{pfenum}
        \item $[[ alloct |- h' <= nR' ]]$
        \item $[[ alloct | < h ; res_term > ||v < h' ; res_val > ]]$
        \item $[[ cdot ; L0 ; N ; nR' |- res_val => ptrt |- _init - ct -> _t * Alloc ( term ) ( oarg ) ]]$.
        \end{pfenum}
        \pf{} By \stepref{<2>2} and \lemmaref{subsec:res_term_progress}.}

    \step{<2>4}{%
        $[[ res_val ]] = [[ < Owned < _init , ct > ( ptrt )  , Alloc ( term ) > ]]$.\\
        \pf{} By \lemmaref{subsec:non_cond_res_det_ctx_val}.}

    \step{<2>5}{%
        $[[ h' ]] = [[ { ptrt |- _init - ct -> _t  & None } + { Alloc ( term ) ( oarg ) & None } ]]$.\\
        \pf{} By inversion on the typing assumption in \stepref{<2>3},
        $[[ alloct |- h' <= nR' ]]$ and \lemmaref{subsec:norm_ctx_det_heap}.}

    \step{<2>6}{Step with \OpActionKillStatic.}

    \end{pfproof}

\step{<1>20a}{\case{\ActionKillDynamic}{}}

    \begin{pfproof}

    \step{<2>1}{%
        $[[pval]]$ must be a $[[ ptr ]]$.\\
        \pf{} By \PureValObjPtr.}

    \step{<2>2}{%
        $[[ cdot ; L0 ; N ; nR |- res_term => ipred_term ( _t ) * pred_term ( oarg ) ]]$\\
        $[[ ipred_term def= each ( integer x ; iguard ) { Owned < _init , byte > ( array_shift < byte > ( ptrt , x ) ) } ]]$\\
        $[[ pred_term def= Alloc ( term ) ]]$\\
        $[[ alloct |- smt ( each ( integer x ; _t ) { iguard <-> ( 0 =< x =< oarg . len - 1 ) } ) ]]$\\
        $[[ alloct |- smt ( ptrt = inj ptr /\ ptrt . addr = oarg . base /\ ptrt . alloc_id = term ) ]]$.\\
        \pf{} By inversion on the typing assumption, $[[ alloct <= N ]]$ and \stepref{<2>1}.}

    \step{<2>3}{%
        $[[ exists ]] [[ h' ]], [[ nR' ]], [[ res_val ]] .\:$\\
        \begin{pfenum}
        \item $[[ alloct |- h' <= nR' ]]$
        \item $[[ alloct | < h ; res_term > ||v < h' ; res_val > ]]$
        \item $[[ cdot ; L0 ; N ; nR' |- res_val => ipred_term ( _t ) * pred_term ( oarg ) ]]$.
        \end{pfenum}
        \pf{} By \stepref{<2>2} and \lemmaref{subsec:res_term_progress}.}

    \step{<2>4}{%
        $[[ res_val ]] = [[ < ipred_term  , pred_term > ]]$.\\
        \pf{} By \lemmaref{subsec:non_cond_res_det_ctx_val}.}

    \step{<2>5}{%
        $[[ h' ]] = [[ { ipred_term ( _t ) & cdot } + { pred_term ( oarg ) & None } ]]$.\\
        \pf{} By inversion on the typing assumption in \stepref{<2>3},
        $[[ alloct |- h' <= nR' ]]$ and \lemmaref{subsec:norm_ctx_det_heap}.}

    \step{<2>6}{Step with \OpActionKillDynamic.}

    \end{pfproof}

\step{<1>13a}{\case{\MemopPtrEq.}{}}

    \begin{pfproof}

    \step{<2>1}{%
        $[[pval1]]$ must be a $[[ ptr1 ]]$.\\
        $[[pval2]]$ must be a $[[ ptr2 ]]$.\\
        \pf{} By on the typing assumption and \PureValObjPtr.}

    \step{<2>2}{Step with \OpMemopPtrEq.}
    
    \end{pfproof}

\step{<1>21}{\case{\MemopRelBinop.}{}}

    \begin{pfproof}

    \step{<2>1}{%
        $[[pval1]]$ must be a $[[ ptr1 ]]$.\\
        $[[pval2]]$ must be a $[[ ptr2 ]]$.\\
        \pf{} By on the typing assumption and \PureValObjPtr.}

    \step{<2>2}{%
        $[[ cdot ; L0 ; N ; nR |- res_term => res ]]$.\\
        \pf{} By inversion on the typing assumption.}

    \step{<2>3}{%
        $[[ res ]] = [[ pred_term ( oarg ) ]]$\\
        $[[alloct | is_live pred_term ( oarg ) & ptr1 ,  ptr2]]$\\
        $[[alloct | in_bounds ptr1 , ptr2]]$\\
        \pf{} By inversion on the typing assumption and $[[ alloct <= N ]]$.}

    \step{<2>4}{%
        $[[ exists ]] [[ h' ]], [[ nR' ]], [[ res_val ]] .\:$\\
        \begin{pfenum}
        \item $[[ alloct |- h' <= nR' ]]$
        \item $[[ alloct | < h ; res_term > ||v < h' ; res_val > ]]$
        \item $[[ cdot ; L0 ; N ; nR' |- res_val => res ]]$.
        \end{pfenum}
        \pf{} By \stepref{<2>2} and \lemmaref{subsec:res_term_progress}.}

    \step{<2>5}{%
        $[[ res_val ]] = [[ pred_term ]]$.\\
        \pf{} By \lemmaref{subsec:non_cond_res_det_ctx_val} and \stepref{<2>3}.}

    \step{<2>6}{%
        $[[ h' ]] = [[ { pred_term ( oarg ) & None } ]]$.\\
        \pf{} By inversion on the typing assumption in \stepref{<2>4},
        $[[ alloct |- h' <= nR' ]]$ and \lemmaref{subsec:norm_ctx_det_heap}.}

    \step{<2>7}{Step with \OpMemopRelBinop.}

    \end{pfproof}

\step{<1>22}{\case{%
    \MemopPtrDiff, \MemopPtrDiffArr.
}{%
    \pf{} Similar to \MemopRelBinop, so step with
    \OpMemopPtrDiff/\OpMemopPtrDiffArr{} respectively.}}

\step{<1>23}{\case{%
    \MemopIntFromRt, \MemopRtFromInt.
}{%
    \pf{} Similar to \MemopPtrEq, but $[[pval]]$ is an $[[addr]]$ for \MemopRtFromInt.
    Step with \OpMemopIntFromRt/\OpMemopRtFromInt{} respectively.}}

\step{<1>23}{\case{%
    \MemopRtFromPtr, \MemopPtrFromRt.
}{%
    \pf{} Similar to \MemopPtrEq, but $[[pval]]$ is a $[[ptr]]$.
    Step with \OpMemopRtFromPtr/\OpMemopPtrFromRt{} respectively.}}

\step{<1>22}{\case{%
    \MemopCopyAllocId.
}{%
    \pf{} Similar to \MemopRelBinop, but where $[[pval1]]$ is $[[addr]]$.
    So step with \OpMemopCopyAllocId.}}

\step{<1>25}{\case{%
    \MemopPtrValidForDeref, \MemopPtrWellAligned.
}{%
    \pf{} Similar to \MemopPtrEq, excepct with only one $[[pval]]$.
    Step with \OpMemopPtrValidForDeref/\OpMemopPtrWellAligned{} respectively.}}


\step{<1>27}{\case{%
    \MemopPtrArrayShift.
}{%
    \pf{} Similar to \MemopRelBinop, so step with \OpMemopPtrArrayShift.}}

\step{<1>27a}{\case{\MemopMemcpy.}{}}

    \begin{pfproof}

    \step{<2>1}{%
        $[[pval1]]$ must be a $[[ ptr1 ]]$.\\
        $[[pval2]]$ must be a $[[ ptr2 ]]$.\\
        $[[pval3]]$ must be an $[[ int ]]$.\\
        \pf{} By inversion on the typing assumption \PureValObjPtr{} for the
        first two, and \PureValObjInt{} for the last.}

    \step{<2>2}{%
        $[[ cdot ; L0 ; N ; nR |- res_term => ipred_term1 ( _t ) * ipred_term2 ( oarg ) ]]$,\\
        where $[[ipred_term1 def= each (integer x; iguard1 ) { Owned < Uninit , byte > ( array_shift < byte > ( ptrt1' , x ) ) } ]]$\\
        and   $[[ipred_term2 def= each (integer x; iguard2 ) { Owned <   Init , byte > ( array_shift < byte > ( ptrt2' , x ) ) }]]$.\\
        \pf{} By inversion on the typing assumption.}

    \step{<2>3}{%
        $[[alloct |- smt ( each (integer x; _t) { iguard1 <-> iguard2 <-> 0 =< x =< int - 1 } )]]$\\
        and $[[alloct |- smt ( ptrt1' = inj ptr1 /\ ptrt2' = inj ptr2 /\ 0 =< int )]]$.\\
        \pf{} By inversion on the typing assumption and $[[ alloct <= N ]]$.}

    \step{<2>4}{%
        $[[ exists ]] [[ h' ]], [[ nR' ]], [[ res_val ]] .\:$\\
        \begin{pfenum}
        \item $[[ alloct |- h' <= nR' ]]$
        \item $[[ alloct | < h ; res_term > ||v < h' ; res_val > ]]$
        \item $[[ cdot ; L0 ; N ; nR' |- res_val => ipred_term1 ( _t ) * ipred_term2 ( oarg ) ]]$.
        \end{pfenum}
        \pf{} By \stepref{<2>2} and \lemmaref{subsec:res_term_progress}.}

    \step{<2>5}{%
        $[[ res_val ]] = [[ < ipred_term1 , ipred_term2 > ]]$.\\
        \pf{} By \lemmaref{subsec:non_cond_res_det_ctx_val}.}

    \step{<2>6}{%
        $[[ h' ]] = [[ { ipred_term1 ( _t ) & cdot } + { ipred_term2 ( oarg ) & cdot } ]]$.\\
        \pf{} By inversion on the typing assumption in \stepref{<2>4},
        $[[ alloct |- h' <= nR' ]]$ and \lemmaref{subsec:norm_ctx_det_heap}.}

    \step{<2>7}{Step with \OpMemopMemcpy.}

    \end{pfproof}

\step{<1>27b}{\case{\MemopMemcmp.}{}}

    \begin{pfproof}

    \step{<2>1}{%
        $[[pval1]]$ must be a $[[ ptr1 ]]$.\\
        $[[pval2]]$ must be a $[[ ptr2 ]]$.\\
        $[[pval3]]$ must be an $[[ int ]]$.\\
        \pf{} By inversion on the typing assumption \PureValObjPtr{} for the
        first two, and \PureValObjInt{} for the last.}

    \step{<2>2}{%
        $[[ cdot ; L0 ; N ; nR |- res_term => ipred_term1 ( oarg1 ) * ipred_term2 ( oarg2 ) ]]$,\\
        where $[[ ipred_term1 def= each (integer x; iguard1 ) { Owned < Init , byte > ( array_shift < byte > ( ptrt1' , x ) ) } ]]$,\\
        and $[[ ipred_term2 def= each (integer x; iguard2 ) { Owned < Init , byte > ( array_shift < byte > ( ptrt2' , x ) ) }]]$.\\
        \pf{} By inversion on the typing assumption.}

    \step{<2>3}{%
        $[[ alloct |- smt ( each (integer x; _t) { iguard1 <-> iguard2 <-> 0 =< x =< int - 1 } ) ]]$\\
        and $[[ alloct |- smt ( each (integer x; iguard1 ) { oarg1 [ x ] != inj Unspecified () } ) ]]$\\
        and $[[ alloct |- smt ( each (integer x; iguard2 ) { oarg2 [ x ] != inj Unspecified () } ) ]]$\\
        and $[[ alloct |- smt ( ptrt1' = inj ptr1 /\ ptrt2' = inj ptr2 /\ 0 =< int ) ]]$.\\
        \pf{} By inversion on the typing assumption and $[[ alloct <= N ]]$.}

    \step{<2>4}{%
        $[[ exists ]] [[ h' ]], [[ nR' ]], [[ res_val ]] .\:$\\
        \begin{pfenum}
        \item $[[ alloct |- h' <= nR' ]]$
        \item $[[ alloct | < h ; res_term > ||v < h' ; res_val > ]]$
        \item $[[ cdot ; L0 ; N ; nR' |- res_val => ipred_term1 ( oarg1 ) * ipred_term2 ( oarg2 ) ]]$.
        \end{pfenum}
        \pf{} By \stepref{<2>2} and \lemmaref{subsec:res_term_progress}.}

    \step{<2>5}{%
        $[[ res_val ]] = [[ < ipred_term1 , ipred_term2 > ]]$.\\
        \pf{} By \lemmaref{subsec:non_cond_res_det_ctx_val}.}

    \step{<2>6}{%
        $[[ h' ]] = [[ { ipred_term1 ( oarg1 ) & cdot } + { ipred_term2 ( oarg ) & cdot } ]]$.\\
        \pf{} By inversion on the typing assumption in \stepref{<2>4},
        $[[ alloct |- h' <= nR' ]]$ and \lemmaref{subsec:norm_ctx_det_heap}.}

    \step{<2>7}{Step with \OpMemopMemcmp.}

    \end{pfproof}

\step{<1>28}{\case{\ExprCCall.}{}}

    \begin{pfproof}

    \step{<2>1}{%
        $[[ P ( id ) = </ xi // i /> |-> stmt : fon ]]$\\
        $[[ cdot ; L0 ; N ; nR |- </ xi = spine_elemi // i /> :: fon >> subs ; ret ]]$.\\
        \pf{} By inversion.}

    \step{<2>2}{%
        $[[ alloct | </ xi = spine_elemi // i /> :: fon >> < subs ; ret > ]]$.\\
        \pf{} By \stepref{<2>1} and \lemmaref{subsec:wt_spine_sub}.}

    \step{<2>3}{Step with \OpExprCCall.}

    \end{pfproof}

\step{<1>29}{\case{\ExprProc, \StmtRun.}{%
    \pf{} Similar to \ExprCCall, but step with \OpExprProc{} / \OpStmtRun.}}

\step{<1>30}{\case{\ExprMemop.}{%
    \pf{} By induction, if $[[memop]]$ is unreachable, then the whole expression
    is so. $[[memop]]$s are not values. Only stepping cases applies, so
    step with \OpExprMemop.}}

\step{<1>31}{\case{\ExprAction.}{%
    \pf{} By induction, if $[[action]]$ is unreachable, then the whole
    expression is so. $[[action]]$s are not values. Only stepping case applies, so
    step with \OpExprAction{}.}}

\step{<1>32}{\case{\StmtPure.}{%
    \pf{} By induction.}}

\step{<1>33}{\case{\StmtExpr.}{%
    \pf{} By induction, since $[[expr]]$ is not value, if it is unreachable,
    the whole expression is so. If $[[expr]]$ takes a step, the whole
    expression steps with \OpStmtExpr.}}

\step{<1>34}{\case{\StmtLet.}{%
    \pf{} By induction, if $[[stmt]]$ is unreachable, so is the whole
    expression.\\[\baselineskip]

    If it is $[[< ret_terms >]]$, use \lemmaref{subsec:wt_values_pat_match}, with
    \lemmaref{subsec:tofun_ret_rel_ret} and the assumption that all
    patterns are exhaustive, so the whole expression steps with
    \OpStmtRetT.\\[\baselineskip]

    If $[[stmt]]$ takes a step, the whole expression steps with
    \OpStmtLet.}}

\step{<1>35}{\case{\StmtCase.}{%
    \pf{} By assumption that all patterns are exhaustive, and
    \lemmaref{subsec:wt_values_pat_match}, there is at least one pattern against
    which $[[pval]]$ will match, so \OpStmtCase.}}

\step{<1>36}{\case{\StmtIf.}{%
    \pf{} $[[pval]]$ must be a $[[bool_value]]$ and so
    \OpStmtIfTrue/\OpStmtIfFalse.}}

\end{pfproof}

\section{Type Preservation}

% cdot ; L0 ; N ; nR |- stmt <= ret
% alloc ; h <= N ; nR
% < alloct ; h + f ; stmt > -->  < alloct' ; heap ; stmt' >
% -------------------------------------------------------------------
% exists h' , N' , nR'.
%    cdot ; L0 ; N ; cdot [= cdot ; L0 ; N' ; cdot
%    heap  =  h' + f
%    N |- h' <= nR'
%    cdot ; L0 ; N ; nR' |- stmt' <= ret .


\subsection{\texorpdfstring{$[[ Owned < _init , ct > ]]$}{Owned⟨\textunderscore, τ⟩} resource output values have type \texorpdfstring{$[[to_base ( ct ) ]]$}{βτ}}\label{subsec:owned_val_type}

If $[[ C ; L ; N ; R |- Owned < _init , ct > ( ptrt ) <= ptrt' |- _init - ct -> inj pval ]]$ then
$[[ C |- pval => to_base ( ct ) ]]$.

\pfsketch{ Induction over the typing judgements. Only \ActionStore{}
    constrains $[[ oarg ]]$ of $[[ Owned < _init , ct > ]]$ resources, and its
    premises ensure it has type $[[ to_base ( ct ) ]]$; \ActionLoad{} and
    \MemopPtrValidForDeref{} simply propagate the value.}

\subsection{Type Preservation Statement and Proof}

% chktex-file 15

If $[[ cdot ; L0 ; N ; nR |- stmt <= ret ]]$ and
$[[ alloct ; h <= N ; nR ]]$, and all functions are well-typed
then $[[ forall ]] [[ f ]] [[ .: ]] [[ < alloct ; h + f ; stmt > -->  < alloct' ; heap ; stmt' > ]] [[ => ]]
[[ exists ]] [[ N' ]] , [[ h' ]] , [[ nR' ]] [[ .: ]]
( [[ cdot ; L0 ; N ; cdot [= cdot ; L0 ; N' ; cdot ]] ) % chktex 9
[[ /\ ]] [[ heap ]] = [[ h' + f ]]
[[ /\ ]] ( [[ alloct' ; h' <= N' ; nR' ]] )
[[ /\ ]] ( [[ cdot ; L0 ; N' ; nR' |- stmt' <= ret ]] )$.\\[\baselineskip]

You can equally well prove $[[ forall ]] [[ nR' ]] [[ .: ]] [[ alloct ; h' <= N' ; nR' ]]
[[ => ]] [[ cdot ; L0 ; N ; nR' |- stmt' <= ret ]]$ instead. Instead of
supplying $[[ nR' ]]$ and proving heap typing, you instead invert heap typing
to deduce that $[[ nR' ]]$ can only be what you would have supplied anyways.

\begin{pfproof}

\pfsketch{ Induction over the typing rules, which don't refer to values or
    unreachable program points.\\[\baselineskip]}

\assume{\begin{pfenum}
    \item $[[ cdot ; L0 ; N ; nR |- stmt <= ret ]]$,
    \item $[[ alloct ; h <= N ; nR ]]$
    \item for all $[[ P ( id ) = </ xi // i /> |-> stmt : fon ]]$,
            if $[[ C ; L ; N ; R |- param_spine :: fon >> subs ; ret ]]$
            then $[[ C ; L ; N ; R |- subs ( stmt ) <= ret ]]$
    \item $[[ forall ]] [[ f ]] [[ .: ]] [[ < alloct ;  h + f ; stmt > -->  < alloct' ; heap ; stmt' > ]]$.
\end{pfenum}\leavevmode\\}

\prove{$[[ exists ]] [[ N' ]] , [[ h' ]], [[ nR' ]] [[ .: ]]$
    \begin{pfenum}
        \item $[[ cdot ; L0 ; N ; cdot [= cdot ; L0 ; N' ; cdot ]]$
        \item $[[ heap ]] = [[ h' + f ]]$
        \item $[[ alloct ; h' <= N' ; nR' ]]$
        \item $[[ cdot ; L0 ; N' ; nR' |- stmt' <= ret ]]$.
    \end{pfenum}\leavevmode\\[\baselineskip]} % chktex 9

\step{<1>1}{\case{%
    \PureExprPVal.
}{%
    For all pure expressions, $[[ nR ]] = [[ cdot ]]$, $[[ h ]] = [[ cdot ]]$,
    and $[[ heap ]] = [[ f ]]$.
    \pflet{$[[ h' ]] = [[ cdot ]]$ and $[[ nR' ]] = [[ cdot ]]$,
        so $[[ heap ]] = [[ h' + f ]]$ trivially and $[[ alloct |- cdot <= cdot ]]$ (by \HeapEmpty).}

    $[[ ret ]] = [[ pure_ret ]]= [[ sigma y : base_type .: y = inj pval /\ I ]]$\\[\baselineskip]
    \pf{} By \PureStmtPExpr{} and \PureStmtPVal, suffices to show $[[ cdot ; L0 ; N |- pval <= pure_ret ]]$
    which requires proving the trivial constraint $[[ inj pval = inj pval ]]$.}}

\step{<1>2}{\case{%
    \PureExprCtorIvXOR\@.
}{%
    As before, $[[ nR ]] = [[ cdot ]]$, $[[ h ]] = [[ cdot ]]$, and
    $[[ heap ]] = [[ f ]]$.

    $[[ ret ]] = [[ sigma y : integer .: y = xor_uf ( int1 , int2 ) /\ I ]]$\\[\baselineskip]
    \pf{} By \PureStmtPVal, suffices to show $[[ cdot |- int => integer ]]$
    (true by \PureValObjInt).}}

\step{<1>3}{\case{%
    \PureExprArrayShift.
}{%
    As before, $[[ nR ]] = [[ cdot ]]$, $[[ h ]] = [[ cdot ]]$, and
    $[[ heap ]] = [[ f ]]$.
    \pflet{$[[ h' ]] = [[ cdot ]]$ and $[[ nR' ]] = [[ cdot ]]$,
        so $[[ heap ]] = [[ h' + f ]]$ trivially and $[[ alloct |- cdot <= cdot ]]$ (by \HeapEmpty).}

    $[[ ret ]] = [[ sigma y : loc .: y = inj ptr' /\ I ]]$\\[\baselineskip]
    \pf{} By \PureStmtPVal, suffices to show $[[ cdot |- ptr' => loc ]]$
    (true by \PureValObjPtr) and
    $[[ smt ( N => inj ptr' = array_shift < ct > ( inj ptr , int ) ) ]]$
    (true by definition of \OpPExprArrayShift).}}

\step{<1>4}{\case{%
    \PureExprMemberShift, \PureExprPtrEq, \PureExprNot, \PureExprArithBinop,
    \PureExprBoolBinop, \PureExprRelBinop, \PureExprAssertUndef,
    \PureExprBoolToInteger, \PureExprWrapI.
}{%
    \pf{} Similar to \PureExprArrayShift.}}

\step{<1>5}{\case{%
    \PureExprCall.
}{%
    \pf{} See \ExprCCall{} for a more general case and proof.}}

\step{<1>6}{\case{%
    \PureStmtIf.
}{%
    \pf{} See \StmtIf{} for a more general case and proof.}}

\step{<1>7}{\case{%
    \PureStmtPExpr.
}{%
    \pf{} See \StmtExpr{} for a more general case and proof.}}

\step{<1>8}{\case{%
    \PureStmtLet.
}{%
    \pf{} See \StmtLet{} for a more general case and proof.}}

\step{<1>9}{\case{%
    \PureStmtCase.
}{%
    \pf{} See \StmtCase{} for a more general case and proof.}}

\step{<1>10}{\case{%
    \ActionCreate.
}{%
    \pflet{%
        $[[ ret ]] = [[ sigma yp : loc .: term /\ exists x : to_base ( ct ) .: pred_term1 ( x ) *o pred_term2 ( ( yp . addr , sizeof ct ) ) *o I  ]]$\\
        where $[[ term ]] = [[ representable ( ct * , yp ) /\ aligned ( int , yp )  /\ allocv [ @ aid ] = ( yp . addr , sizeof ct ) ]]$,\\
        $[[ pred_term1 ]] = [[ Owned < Uninit, ct > ( inj ptr ) ]]$ and $[[ pred_term2 ]] = [[ Alloc ( @ aid ) ]]$.}

    \assume{%
        $[[ cdot ; L0 ; N ; cdot |- emp | create < ct > ( int ) => ret ]]$ \\
        and so $[[ h ]] = [[ cdot ]]$ (by inversion, \HeapEmpty) \\
        and $[[ heap ]] = [[ f + { pred_term1 ( default to_base ( ct ) ) & None } + { pred_term2 ( ( addr , sizeof ct) ) & None } ]]$.\\}

    \pflet{%
        $[[ h' ]] = [[ { pred_term1 ( default to_base ( ct ) ) & None } + { pred_term2 ( ( addr , sizeof ct ) ) & None } ]]$,
        $[[ nR' ]] = [[ _x : pred_term1 ( default to_base ( ct ) ) , _x : pred_term2 ( ( addr , sizeof ct) ) ]]$,
        $[[ alloct' ]] = ( [[ alloct [ @ aid ] := ( addr , sizeof ct ) ]])$,
        $[[ N' ]] = [[ N , allocv [ @ aid ] = ( addr , sizeof ct )  ]]$.}}
    This means $[[ heap ]] = [[ h' + f ]]$ (trivially).
    Also, $[[ alloct' <= N' ]]$ from since $[[ alloct <= N ]]$ (by expanding definitions).
    Hence $[[ alloct' ; h' <= N' ; nR' ]]$
    (by \HeapPredOwned, \AllocTy, \StateTy).\\[\baselineskip]

    \prove{%
        $[[ cdot ; L0 ; N' ; nR' |- < ptr , default to_base ( ct ) , pred_term1 , pred_term2 > <= ret ]]$.\\[\baselineskip]}}

    \begin{pfproof}

    \step{<2>1}{$[[ cdot |- ptr => loc ]]$ by \PureValObjPtr{} and \PureValObj.}

    \step{<2>2}{$[[ smt ( N' => term ) ]]$ by construction of $[[ ptr ]]$ and $[[ N' ]]$.}

    \step{<2>3}{$[[ cdot ; L0 |- default to_base ( ct ) => to_base ( ct ) ]]$ by construction.}

    \step{<2>4}{$[[ cdot ; L0 ; N ; nR'  |- pred_term1 <= pred_term1 ( default to_base ( ct ) ) ]]$ by
        \ResSynPred.}

    \step{<2>5}{$[[ cdot ; L0 ; N ; nR'  |- pred_term2 <= pred_term2 ( ( addr , sizeof ct ) ) ]]$ by
        \ResSynPred.}

    \step{<2>6}{Prove typing with \SpineRet; \stepref{<2>5} -- \stepref{<2>1} with % chktex 8
        \SpineRes, \SpineRes, \SpineLog, \SpinePhi, \SpineComp{}
        respectively; \StmtRetT{}.}

    \end{pfproof}

\step{<1>10a}{\case{%
    \ActionAlloc.
}{%
    \pflet{%
        $[[ ret ]] = [[ sigma yp : loc .: term /\ exists x : array byte .: ipred_term ( x ) *o pred_term ( ( yp . addr , int2 ) ) *o I  ]]$\\
        where $[[ term ]] = [[ aligned ( int1 , yp )  /\ allocv [ @ aid ] = ( yp . addr , int2 ) ]]$,\\
        $[[ ipred_term ]] = [[ each ( integer x ; 0 =< x =< int2 - 1 ) { Owned < Uninit, ct > ( array_shift < byte > ( inj ptr , x ) )  } ]]$ \\
        and $[[ pred_term ]] = [[ Alloc ( @ aid ) ]]$.}

    \assume{%
        $[[ cdot ; L0 ; N ; cdot |- emp | alloc ( int1 , int2 ) => ret ]]$\\
        and so $[[ h ]] = [[ cdot ]]$ (by inversion, \HeapEmpty)\\
        and $[[ heap ]] = [[ f + { ipred_term ( default array byte ) & cdot } + { pred_term ( ( addr , int2 ) ) & None } ]]$.\\}

    \pflet{%
        $[[ h' ]] = [[ { ipred_term ( default array byte ) & cdot } + { pred_term ( ( addr , int2 ) ) & None } ]]$,
        $[[ nR' ]] = [[ _x : ipred_term ( default array byte ) , _x : pred_term ( ( addr , int2 ) ) ]]$,
        $[[ alloct' ]] = ( [[ alloct [ @ aid ] := ( addr , int2 ) ]])$,
        $[[ N' ]] = [[ N , allocv [ @ aid ] = ( addr , int2 )  ]]$.}}
    This means $[[ heap ]] = [[ h' + f ]]$ (trivially).
    Also, $[[ alloct' <= N' ]]$ from since $[[ alloct <= N ]]$ (by expanding definitions).
    Hence $[[ alloct' ; h' <= N' ; nR' ]]$
    (by \HeapPredOwned, \AllocTy, \StateTy).\\[\baselineskip]

    \prove{%
        $[[ cdot ; L0 ; N' ; nR' |- < ptr , default array byte , ipred_term , pred_term > <= ret ]]$.\\[\baselineskip]}}

    \begin{pfproof}

    \step{<2>1}{$[[ cdot |- ptr => loc ]]$ by \PureValObjPtr{} and \PureValObj.}

    \step{<2>2}{$[[ smt ( N' => term ) ]]$ by construction of $[[ ptr ]]$ and $[[ N' ]]$.}

    \step{<2>3}{$[[ cdot ; L0 |- default to_base ( ct ) => to_base ( ct ) ]]$ by construction.}

    \step{<2>4}{$[[ cdot ; L0 ; N ; nR'  |- ipred_term <= ipred_term ( default array byte ) ]]$ by
        \ResSynIPred.}

    \step{<2>5}{$[[ cdot ; L0 ; N ; nR'  |- pred_term <= pred_term ( ( addr , int2 ) ) ]]$ by
        \ResSynPred.}

    \step{<2>6}{Prove typing with \SpineRet; \stepref{<2>5} -- \stepref{<2>1} with % chktex 8
        \SpineRes, \SpineRes, \SpineLog, \SpinePhi, \SpineComp{}
        respectively; \StmtRetT{}.}

    \end{pfproof}

\step{<1>11}{\case{%
    \ActionLoad.
}{%
    \pflet{%
        $[[ ret ]] = [[ sigma y : to_base ( ct ) .: y = inj pval /\ ( inj ptr |- Init - ct -> inj pval ) *o I ]]$\\
        $[[ pt ]] = [[ Owned < Init , ct > ( inj ptr ) ( inj pval ) ]]$.\\[\baselineskip]}

    \assume{%
        $[[ cdot ; L0 ; N ; nR |- res_term | load <ct> ( ptr ) => ret ]]$\\
        and $[[ heap ]] = [[ heap' + { pt & None } ]]$
        so $[[ alloct | < h + f ; res_term > ||v < heap' + { pt & None } ; Owned < Init , ct > ( inj ptr ) > ]]$.\\[\baselineskip]}

    \pflet{$[[ h' ]]$ and $[[ nR' ]]$ be as per \lemmaref{subsec:res_term_red_isolated}.}
    $[[ nR' ]] = [[ _x : pt ]]$ by Lemma~\ref{subsec:non_cond_res_det_ctx_val}
    and $[[ h' ]] = [[ { pt & None } ]]$ by Lemma~\ref{subsec:norm_ctx_det_heap},
    hence $[[ heap' ]] = [[ f ]]$.\\
    This means $[[ heap ]] = [[ h' + f ]]$, $[[ alloct |- h' <= nR' ]]$
    and $[[ cdot ; L0 ; N ; nR' |- Owned < Init , ct > ( inj ptr ) => pt ]]$.\\[\baselineskip]

    \prove{$[[ cdot ; L0 ; N ; nR' |- < pval , Owned < Init , ct > (  inj ptr ) > <= ret ]]$.\\}}}

    \begin{pfproof}

    \step{<2>1}{$[[ cdot |- pval => to_base ( ct ) ]]$
        by~\lemmaref{subsec:owned_val_type}.}

    \step{<2>2}{$[[ smt ( N => inj pval = inj pval ) ]]$ trivially.}

    \step{<2>3}{$[[ cdot ; L0 ; N ; nR' |- Owned < Init , ct > ( inj ptr ) => pt ]]$, already established.}

    \step{<2>4}{Prove typing with \SpineRet; \stepref{<2>3} -- \stepref{<2>1} with % chktex 8
        \SpineRes, \SpineLog, \SpineComp{} respectively; \StmtRetT{}.}

    \end{pfproof}

\step{<1>12}{\case{%
    \ActionStore.
}{%
    \pflet{%
        $[[ ret ]] = [[ sigma _x : unit .: ( inj ptr |- Init - ct -> inj pval ) *o I ]]$.\\
        $[[ pt ]] = [[ Owned < _init , ct > ( inj ptr ) ( _t )]]$,\\
        $[[ pt' ]] = [[ Owned < Init , ct > ( inj ptr ) ( inj pval ) ]]$.\\[\baselineskip]}

    \assume{%
        $[[ cdot ; L0 ; N ; nR |- res_term | store < ct > ( ptr , pval ) => ret ]]$
        and $[[ heap ]] = [[ heap' + { pt' & None } ]]$ so $[[ alloct | < h + f ; res_term > ||v < heap' + { pt & None } ; Owned < _init , ct > ( inj ptr ) > ]]$.\\[\baselineskip]}

    $[[ exists ]] [[ h'' ]] , [[ nR'' ]]$ such that
    $[[ heap' + { pt & None } ]] = [[ h'' + f ]]$,
    $[[ alloct |- h'' <= nR'' ]]$
    and $[[ cdot ; L0 ; N ; nR'' |- Owned < _init , ct > ( inj ptr ) => pt ]]$,
    by \lemmaref{subsec:res_term_red_isolated}.\\[\baselineskip]

    $[[ nR'' ]] = [[ _x : pt ]]$ by Lemma~\ref{subsec:non_cond_res_det_ctx_val}
    and $[[ h'' ]] = [[ { pt & None } ]]$ by Lemma~\ref{subsec:norm_ctx_det_heap},
    hence $[[ heap' ]] = [[ f ]]$.\\
    \pflet{$[[ h' ]] = [[ { pt' & None } ]]$ and $[[ nR' ]] = [[ _x : pt' ]]$.}
    This means $[[ heap ]] = [[ h' + f ]]$ and $[[ alloct |- h' <= nR' ]]$ (by \HeapPredOwned).\\[\baselineskip]

    \prove{%
        $[[ cdot ; L0 ; N ; nR' |- < Unit , Owned < Init , ct > ( inj ptr )  > <= ret ]]$.\\[\baselineskip]}}}

    \begin{pfproof}

    \step{<2>1}{$[[ cdot |- Unit => unit ]]$ by \PureValUnit.}

    \step{<2>2}{$[[ cdot ; L0 ; N ; _x : pt' |- Owned < Init , ct > ( inj ptr ) <= pt' ]]$
        by \ResSynPred.}

    \step{<2>3}{Prove typing with \SpineRet; \stepref{<2>2} -- \stepref{<2>1} with % chktex 8
        \SpineRes, \SpineComp{} respectively; \StmtRetT{}.}

    \end{pfproof}

\step{<1>13}{\case{%
    \ActionKillStatic.
}{%

    \assume{%
        $[[ cdot ; L0 ; N ; nR |- res_term | kill < ct > ( ptr ) => sigma _x : unit .: I ]]$\\
        and $[[ alloct | < h + f ; res_term > ||v < heap + { pred_term1 ( _t ) & None } + { pred_term2 ( oarg ) & None } ; < pred_term1 , pred_term2 > > ]]$\\
        where $[[pred_term1 def= Owned < _init , ct > ( inj ptr )]]$ and $[[ pred_term2 def= Alloc ( @ aid )]]$.\\[\baselineskip]}


    $[[ exists ]] [[ h'' ]] , [[ nR'' ]]$ such that
    $[[ heap + { pred_term1 ( _t ) & None } + { pred_term2 ( oarg ) & None } ]] = [[ h'' + f ]]$,
    $[[ alloct |- h'' <= nR'' ]]$
    and $[[ cdot ; L0 ; N ; nR'' |- < pred_term1 , pred_term2 > => pt ]]$,
    by \lemmaref{subsec:res_term_red_isolated}.\\[\baselineskip]

    $[[ nR'' ]] = [[ _x : pred_term1 ( _t ) , _x : pred_term2 ( oarg ) ]]$ by Lemma~\ref{subsec:non_cond_res_det_ctx_val}
    and $[[ h'' ]] = [[ { pred_term1 ( _t ) & None } + { pred_term2 ( oarg ) & None } ]]$ by Lemma~\ref{subsec:norm_ctx_det_heap},
    hence $[[ heap ]] = [[ f ]]$.\\
    \pflet{$[[ h' ]] = [[ cdot ]]$ and $[[ nR' ]] = [[ cdot ]]$.\\}
    This means $[[ heap ]] = [[ h' + f ]]$ and $[[ alloct |- h' <= nR' ]]$ (by \HeapEmpty).\\[\baselineskip]

    \prove{%
        $[[ cdot ; L0 ; N ; cdot |- < Unit > <= sigma _x : unit .: I ]]$}

    \pf{} By \SpineRet, \PureValUnit, \SpineComp, \StmtRetT.}}

\step{<1>13a}{\case{%
    \ActionKillDynamic.
}{%

    \assume{%
        $[[ cdot ; L0 ; N ; nR |- res_term | kill < ct > ( ptr ) => sigma _x : unit .: I ]]$\\
        and $[[ alloct | < h + f ; res_term > ||v < heap + { ipred_term ( _t ) & cdot } + { pred_term ( oarg ) & None } ; < ipred_term , pred_term > > ]]$\\
        where $[[ ipred_term def= each (integer x; iguard) { Owned < _init , byte > ( array_shift < byte > ( inj ptr , x ) ) } ]]$ \\
        and $[[ pred_term def= Alloc ( @ aid )]]$.\\[\baselineskip]}


    $[[ exists ]] [[ h'' ]] , [[ nR'' ]]$ such that
    $[[ heap + { ipred_term ( _t ) & cdot } + { pred_term ( oarg ) & None } ]] = [[ h'' + f ]]$,
    $[[ alloct |- h'' <= nR'' ]]$
    and $[[ cdot ; L0 ; N ; nR'' |- < ipred_term , pred_term > => pt ]]$,
    by \lemmaref{subsec:res_term_red_isolated}.\\[\baselineskip]

    $[[ nR'' ]] = [[ _x : ipred_term ( _t ) , _x : pred_term ( oarg ) ]]$ by Lemma~\ref{subsec:non_cond_res_det_ctx_val}
    and $[[ h'' ]] = [[ { ipred_term ( _t ) & cdot } + { pred_term ( oarg ) & None } ]]$ by Lemma~\ref{subsec:norm_ctx_det_heap},
    hence $[[ heap ]] = [[ f ]]$.\\
    \pflet{$[[ h' ]] = [[ cdot ]]$ and $[[ nR' ]] = [[ cdot ]]$.\\}
    This means $[[ heap ]] = [[ h' + f ]]$ and $[[ alloct |- h' <= nR' ]]$ (by \HeapEmpty).\\[\baselineskip]


    \prove{%
        $[[ cdot ; L0 ; N ; cdot |- < Unit > <= sigma _x : unit .: I ]]$}

    \pf{} By \SpineRet, \PureValUnit, \SpineComp, \StmtRetT.}}

\step{<1>13a}{\case{%
    \MemopPtrEq.
}{%

    \assume{%
      $[[ret def= sigma y : bool .: term1 /\ term3 *o I]]$\\
      where $[[term1 def= inj pval1 = inj pval2 -> y]]$,\\
      $[[term2 def= inj pval1 . alloc_id != inj pval2 . alloc_id /\ inj pval1 . addr = inj pval2 . addr]]$,\\
      $[[term3 def= neg term1 /\ neg term2 -> neg y]]$.\\[\baselineskip]}

    \prove{%
        $[[ cdot ; L0 ; N ; nR' |- < bool_value > <= ret ]]$}

    \pf{} By \SpineRet, \PureValTrue/\PureValFalse, \SpineComp, \SpinePhi{} (by construction of $[[ bool_value ]]$), \StmtRetT.}}


\step{<1>14}{\case{%
    \MemopRelBinop.
}{%

    \assume{%
      $[[ret def= sigma y : bool .: y = inj ptr1 . addr ' rel_binop ' inj ptr2 . addr /\ pred_term ( oarg ) *o I]]$\\
      $[[ cdot ; L0 ; N ; nR |- res_term | ptr1 rel_binop ptr2 => ret ]]$\\
      and $[[ alloct | < h + f ; res_term > ||v < heap + { pred_term ( oarg ) & None } ; pred_term > ]]$.\\[\baselineskip]}

    $[[ exists ]] [[ h' ]] , [[ nR' ]]$ such that
    $[[ heap + { pred_term ( oarg ) & None } ]] = [[ h' + f ]]$,
    $[[ alloct |- h' <= nR' ]]$
    and $[[ cdot ; L0 ; N ; nR' |- pred_term => pred_term ( oarg ) ]]$,
    by \lemmaref{subsec:res_term_red_isolated}.\\[\baselineskip]

    $[[ nR' ]] = [[ _x : pred_term ( oarg ) ]]$ by Lemma~\ref{subsec:non_cond_res_det_ctx_val}
    and $[[ h' ]] = [[ { pred_term ( oarg ) & None } ]]$ by Lemma~\ref{subsec:norm_ctx_det_heap}.\\
    This means $[[ heap ]] = [[ f ]]$ and $[[ alloct |- h' <= nR' ]]$ (by \HeapPredAlloc{} twice, \HeapConcat).\\[\baselineskip]

    \prove{%
        $[[ cdot ; L0 ; N ; nR' |- < bool_value , pred_term > <= ret ]]$}

    \pf{} By \SpineRet, \PureValTrue/\PureValFalse, \SpineComp, \SpinePhi{} (by construction of $[[ bool_value ]]$), \SpineRes, \StmtRetT.}}

\step{<1>15}{\case{%
    \MemopPtrDiffArr, \MemopPtrDiff.
}{%
    \pf{} Similar to \MemopRelBinop, but with \PureValObjInt.}}

\step{<1>16}{\case{%
    \MemopIntFromRt, \MemopRtFromInt, \MemopRtFromPtr, \MemopPtrFromRt.
}{%
    \pf{} Similar to \MemopPtrEq, but with an extra \SpineLog{} for \MemopRtFromInt.}}

\step{<1>17}{\case{%
    \MemopCopyAllocId.
}{%
    \pf{} Similar to \MemopRelBinop, but with \PureValObjPtr.}}

\step{<1>18}{\case{%
    \MemopPtrValidForDeref, \MemopPtrWellAligned.
}{%
    \pf{} Similar to \MemopPtrEq.}}

\step{<1>19}{\case{%
    \MemopPtrArrayShift.
}{%
    \pf{} Similar to \MemopRelBinop, but with \PureValObjPtr.}}

\step{<1>19a}{\case{%
    \MemopMemcpy.
}{%

    \assume{%
      $[[ ret def= sigma y : loc .: y = inj ptr1 /\ ipred_term1 ( oarg ) * ipred_term2 ( oarg ) *o I ]]$\\
      $[[ cdot ; L0 ; N ; nR |- res_term | memcpy ( ptr1 , ptr2 , int ) => ret ]]$\\
      $[[ alloct | < h + f ; res_term > ||v < heap' + h1 ; < ipred_term1 , ipred_term2 > > ]]$\\
      where $[[ h1 def= { ipred_term1 ( _t ) & cdot } + { ipred_term2 ( oarg ) & cdot } ]]$.\\[\baselineskip]}

    $[[ exists ]] [[ h'' ]] , [[ nR'' ]]$ such that
    $[[ heap' + h1 ]] = [[ h'' + f ]]$,
    $[[ alloct |- h'' <= nR'' ]]$
    and $[[ cdot ; L0 ; N ; nR'' |- < ipred_term1 , ipred_term2 > => ipred_term1 ( _t ) * ipred_term2 ( oarg ) ]]$,
    by \lemmaref{subsec:res_term_red_isolated}.\\[\baselineskip]

    $[[ nR'' ]] = [[ _x : ipred_term1 ( _t ) , _x : ipred_term2 ( oarg ) ]]$ by Lemma~\ref{subsec:non_cond_res_det_ctx_val}
    and $[[ h'' ]] = [[ h1 ]]$ by Lemma~\ref{subsec:norm_ctx_det_heap}.
    This means $[[ heap' ]] = [[ f ]]$.\\

    \pflet{%
        $[[ nR' ]] = [[ _x : ipred_term1 ( oarg ) , _x : ipred_term2 ( oarg ) ]]$,\\
        $[[ h' ]] = [[ { ipred_term1 ( oarg ) & cdot } + { ipred_term2 ( oarg ) & cdot } ]]$.\\
        This means $[[ heap ]] = [[ h' + f ]]$ and $[[ alloct |- h' <= nR' ]]$ (by \HeapIPredOwned{} twice, \HeapConcat).\\[\baselineskip]}

    \prove{%
        $[[ cdot ; L0 ; N ; nR' |- < ptr1 , < ipred_term1 , ipred_term2 > > <= ret ]]$}}}

    \begin{pfproof}

    \step{<2>1}{$[[ cdot |- ptr1 => loc ]]$ by \PureValObjPtr{} and \PureValObj.}

    \step{<2>2}{$[[ smt ( N => inj ptr1 = inj ptr1 ) ]]$ trivally.}

    \step{<2>4}{$[[ cdot ; L0 ; N ; nR'  |- < ipred_term1 , ipred_term2 > <= ipred_term1 ( oarg ) * ipred_term2 ( oarg ) ]]$ by
        \ResSynIPred{} and \ResChkSwitch{} twice, then \ResChkSepConj.}

    \step{<2>6}{Prove typing with \SpineRet; \stepref{<2>4} -- \stepref{<2>1} with % chktex 8
        \SpineRes, \SpinePhi, \SpineComp{} respectively; \StmtRetT{}.}

    \end{pfproof}


\step{<1>19b}{\case{%
    \MemopMemcmp.
}{%

    \assume{%
      $[[ ret def= sigma y : bool .: y = memcmp ( inj ptr1 , inj ptr2 , int ) /\ ipred_term1 ( oarg1 )  *o ipred_term2 ( oarg2 ) *o I ]]$\\
      $[[ cdot ; L0 ; N ; nR |- res_term | memcmp ( ptr1 , ptr2 , int ) => ret ]]$\\
      $[[ alloct | < h ; res_term > ||v < heap' + h1 ; < ipred_term1 , ipred_term2 > > ]]$\\
      where $[[ h1 def= { ipred_term1 ( oarg1 ) & cdot } + { ipred_term2 ( oarg2 ) & cdot } ]]$.\\[\baselineskip]}

    $[[ exists ]] [[ h' ]] , [[ nR' ]]$ such that
    $[[ heap' + h1 ]] = [[ h' + f ]]$,
    $[[ alloct |- h' <= nR' ]]$
    and $[[ cdot ; L0 ; N ; nR' |- < ipred_term1 , ipred_term2 > => ipred_term1 ( oarg1 ) * ipred_term2 ( oarg2 ) ]]$,
    by \lemmaref{subsec:res_term_red_isolated}.\\[\baselineskip]

    $[[ nR' ]] = [[ _x : ipred_term1 ( oarg1 ) , _x : ipred_term2 ( oarg2 ) ]]$ by Lemma~\ref{subsec:non_cond_res_det_ctx_val}
    and $[[ h' ]] = [[ h1 ]]$ by Lemma~\ref{subsec:norm_ctx_det_heap}.\\
    This means $[[ heap' ]] = [[ f ]]$ and $[[ alloct |- h' <= nR' ]]$ (by \HeapIPredOwned, \HeapConcat).\\[\baselineskip]

    \prove{%
        $[[ cdot ; L0 ; N ; nR' |- < bool_value , < ipred_term1 , ipred_term2 > > <= ret ]]$}}}

    \begin{pfproof}

    \step{<2>1}{$[[ cdot |- bool_value => bool ]]$ by \PureValTrue/\PureValFalse.}

    \step{<2>2}{$[[ smt ( N => inj ptr1 = inj ptr1 ) ]]$ trivally.}

    \step{<2>4}{$[[ cdot ; L0 ; N ; nR'  |- < ipred_term1 , ipred_term2 > <= ipred_term1 ( oarg1 ) * ipred_term2 ( oarg2 ) ]]$ by
        \ResSynIPred{} and \ResChkSwitch{} twice, then \ResChkSepConj.}

    \step{<2>6}{Prove typing with \SpineRet; \stepref{<2>4} -- \stepref{<2>1} with % chktex 8
        \SpineRes, \SpinePhi, \SpineComp{} respectively; \StmtRetT{}.}

    \end{pfproof}

\step{<1>20}{\case{%
    \ExprCCall.
}{%
    \assume{%
        $[[ P ( id ) = </ xi // i  /> |-> stmt : fon ]]$\\
        $[[ cdot ; L0 ; N ; nR |- </ xi = spine_elemi // i /> :: fon >> subs1 ; ret1 ]]$.\\
        $[[ alloct <= N ]]$\\
        $[[ < alloct ; h ; ccall ( ct , id , </ spine_elemi // i /> ) > --> < alloct ; h ; subs2 ( stmt ) : ret2 > ]]$\\
        $[[ cdot ; L0 ; N ; nR |- subs1 ( stmt ) <= ret1 ]]$
        (all functions are well-typed assumption).\\[\baselineskip]}

    \prove{%
        $[[ cdot ; L0 ; N ; nR' |- subs2 ( stmt ) <= ret2 ]]$.\\[\baselineskip]}

    \pf{} By \lemmaref{subsec:wt_spine_sub} and $[[ alloct <= N ]]$.}}

\step{<1>21}{\case{%
    \ExprProc.
}{%
    \pf{}  Similar to \ExprCCall.}}

\step{<1>22}{\case{%
    \ExprMemop, \ExprAction, \ExprPure, \StmtPure.
}{%
    \pf{} By induction.}}

\step{<1>23}{\case{%
    \StmtExpr.
}{%
\pf{} See \StmtLet{} for a more general case and proof.}}

\step{<1>24}{\case{%
    \StmtLet.
}{%
    \assume{%
        $[[cdot ; L0 ; N ; nR1 , nR2 |- let </ ret_pati // i /> : ret1 = < </ ret_termi // i /> > in stmt2 <= ret2]]$\\
        so $[[ cdot ; L0 ; N ; nR1 |- < </ ret_termi // i /> > <= ret1 ]]$\\
        and $[[ N |- ret_pat : ret1 ~> C3 ; L3 ; N3 ; R3 ]]$\\
        and $[[ C3 ; L0 , L3 ; N , N3 ; nR2 , R3 |- stmt2 <= ret2 ]]$ (by inversion).\\[\baselineskip]}

    $[[ alloct |- h <= nR1, nR2 ]]$ so $[[ h ]] = [[ h1 + h2 ]]$ where $[[ alloct |- h1 <= nR1 ]]$ and $[[ alloct |- h2 <= nR2 ]]$
    by \lemmaref{subsec:norm_ctx_det_heap}.\\
    $[[ < alloct ; h + f ; let </ ret_pati // i /> : ret1 = < </ ret_termi // i /> > in stmt > --> < alloct' ; heap ; subs ( stmt ) > ]]$.\\
    where $[[ < h ; </ ret_pati = ret_termi // i /> > ~> < heap ; subs > ]]$.\\[\baselineskip]

    \prove{$[[ exists ]] [[ N' ]] , [[ h' ]] , [[ nR' ]] [[ .: ]]$\\
        $\quad [[ cdot ; L0 ; N ; cdot [= cdot ; L0 ; N' ; cdot ]]$\\
        $\quad [[ heap ]] = [[ h' + f ]]$ and $[[ alloct |- h' <= nR' ]]$\\
        $\quad [[ cdot ; L0 ; N' ; nR' |- subs ( stmt2 ) <= subs ( ret2 ) ]]$.\\[\baselineskip]} % chktex 9

    $[[ exists ]] [[ h1' ]], [[ nR1' ]] [[ .: ]] [[ heap ]] = [[ h1' + h2 + f ]]$,
    $[[ alloct |- h1' <= nR1' ]]$ and $[[ cdot ; L0 ; N ; nR1' |- subs <= ( C3 ; L3 ; R3 ) ]]$\\
    by \lemmaref{subsec:wt_values_pat_match}.\\[\baselineskip]
    This means $[[ cdot ; L0 ; [ id ,subs ] ( N , N3 ) ; nR1' , nR2 |- [ id , subs ] <= ( C3 ; L0 , L3 ; nR2 , R3 ) ]]$
    by \SubsChkConcat{} and \lemmaref{sec:weakening}.\\[\baselineskip]

    \pflet{$[[ N' ]] = [[ N , subs ( N3 ) ]]$, $[[ h' ]] = [[ h1' + h2 ]]$ and $ [[ nR' ]] = [[ nR1' , nR2 ]]$.}
    By \lemmaref{subsec:sub}, and $[[ subs ( N ) ]] = [[ N ]]$
    because it is well-formed w.r.t $[[ cdot ]] ; [[ L0 ]]$.}}

\step{<1>25}{\case{%
    \StmtLet.
}{%
    \assume{%
        $[[ cdot ; L0 ; N ; nR1 , nR2 |- let </ ret_pati // i /> : ret1 = stmt1 in stmt2 <= ret2 ]]$\\
        so $[[ cdot ; L0 ; N ; nR1 |- stmt1 <= ret1 ]]$\\
        and $[[ h ]] = [[ h1 + h2 ]]$ where $[[ alloct |- h1 <= nR1 ]]$ and $[[ alloct |- h2 <= nR2 ]]$
        by \lemmaref{subsec:norm_ctx_det_heap}.\\
        $[[ < s ; stmt1 > --> < s' ; stmt1' > ]]$.\\[\baselineskip]}

    Proceed by induction, instantiating the frame from the inductive hypothesis
    with $[[ h2 + f ]]$.\\}}

\step{<1>26}{\case{%
    \StmtCase.
}{%
    \assume{%
        $[[ cdot ; L0 ; N ; nR |- case pval of </ | pati => stmti // i /> end <= ret ]]$\\
        $[[ indexed </ pati : base_type1 ~> Ci with termi // i /> ]]$\\
        $[[ indexed </ C , Ci ; L ; N , termi = inj pval ; R |- stmti <= ret // i /> ]]$.\\[\baselineskip]

        $[[ patj = pval ~> subsj ]]$ and
        $[[ forall i lt j .: not ( pati = pval ~> subsi ) ]]$.\\[\baselineskip]}

    \pflet{$[[ N' ]] = [[ N , subsj ( termj = inj pval ) ]]$, $[[ h' ]] = [[ h ]]$ and $[[ nR' ]] = [[ nR ]]$.}
    $[[ cdot ; L0 ; N' ; nR |- [ id , subsj ] <= ( Cj ; L0 ; nR ) ]]$\\
    by \lemmaref{subsec:wt_values_pat_match}\\
    \lemmaref{sec:weakening},
    and $[[ subsj ( N ) ]] = [[ N ]]$ because it is well-formed w.r.t $[[ cdot ]] ; [[ L0 ]]$.

    Hence $[[ cdot ; L0 ; N ; cdot [= cdot ; L0 ; N' ; cdot ]]$ and
    $[[ cdot ; L0 ; N' ; nR |- subsj ( stmtj ) <= subsj ( ret ) ]]$
    by \lemmaref{subsec:sub}.}} % chktex 9

\step{<1>27}{\case{%
    \StmtIf.
}{
    See \StmtCase{} for more general case and proof.}}

\step{<1>28}{\case{%
    \StmtRun.
}{%
    \pf{} Similar to \ExprCCall.}}

\end{pfproof} % chktex 17
